{\rtf1\ansi
{\fonttbl\f0\fswiss Helvetica;}

\f0\pard\qc{\fs45\b LitDev 1.2.17.0 DE Extension API}\par

\f0\pard\sb300\shading2000{\fs36\b LD3DView}\par
\f0\pard{\fs20 3D Visualisierung im GraphicsWindow.{\line}{\line}Standardkoordinaten (Rechtssystem) haben folgende Richtungen und keinen Bezug zu GraphicsWindow Koordinaten:{\line}x	- Links	 0  Rechts +{\line}y	- Unten	 0  Oben +{\line}z	- Hinten 0  Vorne +{\line}{\line}Weitere Details zu untergeordneten Methoden s. http://msdn.microsoft.com/library/ms747437.aspx (?bersicht 3D-Grafiken).{\line}Einige Add...-Methoden verwenden HelixToolkit (rekompiliert und angepasst f?r SB, http://www.helix-toolkit.org).{\line}S.a. 'LDVector' f?r algebraische Vektormethoden.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 3D-samples\\*.sb{\line}http://blogs.msdn.microsoft.com/smallbasic/2016/06/19/3d-visualisation/{\line}http://msdn.microsoft.com/library/system.windows.media.media3d.aspx{\line}http://msdn.microsoft.com/library/system.windows.controls.viewport3d.aspx{\line}http://csharphelper.com/blog/2014/10/understand-three-dimensional-drawing-with-wpf-xaml-and-c{\line}http://paulbourke.net}\par

\f0\pard\sb180\shading1000{\fs30\b AddAmbientLight(shapeName,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine umgebende Lichtquelle hinzu, f?r gleichm??ige Beleuchtung aller Objekte aus allen Richtungen. Oft mit Farbe geringer Helligkeit zB. (Light)Gray, "#404040". Ungeeignet f?r spiegelnde Materialien "S" (Intern: Light#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Lichtfarbe (zB. "#808040").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der 3DView Lichtname.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Reflektierter Farbwert = Material Farbwert * Licht Farbwert / 255}\par
\f0\pard\sb180\shading1000{\fs30\b AddArrow(shapeName,length,diameter,arrowLength,arrowDiameter,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Pfeil Geometrieobjekt hinzu, aufw?rts gerichtet (+y, stehend auf x,z Ebene) beginnend an (0,0,0) (Intern: Geometry#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b length}\par
\f0\pard{\fs20 Die Gesamtl?nge des Pfeils.}\par
\f0\pard\sb75{\fs24\b diameter}\par
\f0\pard{\fs20 Der Schaftdurchmesser des Pfeils.}\par
\f0\pard\sb75{\fs24\b arrowLength}\par
\f0\pard{\fs20 Die L?nge der Pfeilspitze.}\par
\f0\pard\sb75{\fs24\b arrowDiameter}\par
\f0\pard{\fs20 Der untere Durchmesser der Pfeilspitze.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 Die Anzahl radialer Teilbereiche f?r den Pfeil (>3, Standard: 18, nicht "").}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddCone(shapeName,baseRadius,topRadius,height,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein solides Kegel(stumpf) Geometrieobjekt hinzu, aufrecht (+y, stehend auf x,z Ebene) mit der Basis zentriert in (0,0,0) (Intern: Geometry#).{\line}Info: Ein Zylinder entspricht einem Konus mit baseRadius = topRadius.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b baseRadius}\par
\f0\pard{\fs20 Der Radius der Grundfl?che.}\par
\f0\pard\sb75{\fs24\b topRadius}\par
\f0\pard{\fs20 Der obere Radius (Standard: 0, Kegel),{\line}> 0		Kegelstumpf{\line}= baseRadius	Zylinder}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Konus.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 Die Anzahl radialer Teilbereiche f?r den Konus (Standard: 18).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddCube(shapeName,sideLength,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein W?rfel Geometrieobjekt hinzu, zentriert in (0,0,0) (Intern: Geometry#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b sideLength}\par
\f0\pard{\fs20 Die Kantenl?nge f?r den W?rfel.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddDirectionalLight(shapeName,colour,xDir,yDir,zDir) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine gerichtete Lichtquelle hinzu, zur Beleuchtung durch weit entfernte Lichtquelle aus einer Richtung zB. Sonnenlicht (Intern: Light#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Lichtfarbe (zB. "#FFFF80", "#C0C0C0").}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 Der x-Richtungsvektor [-1,1] entlang dem der Lichteffekt wirkt (Standard: 0).}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] entlang dem der Lichteffekt wirkt (Standard: 0).}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 Der z-Richtungsvektor [-1,1] entlang dem der Lichteffekt wirkt (Standard: -1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der 3DView Lichtname.}\par
\f0\pard\sb180\shading1000{\fs30\b AddGeometry(shapeName,points,indices,normals,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein math. Geometrieobjekt hinzu. Position und Dimension entsprechend 'points' Definition. (Intern: Geometry#).{\line}s. http://sol.gfxile.net/sphere/index.html (Sphere Mesh Creation).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b points}\par
\f0\pard{\fs20 Eine Leerzeichen- oder Doppelpunkt- begrenzte Liste aller Eckpunkt-Koordinaten (zB. "x0:y0:z0 x1:y1:z1 ..").}\par
\f0\pard\sb75{\fs24\b indices}\par
\f0\pard{\fs20 Eine Leerzeichen- oder Doppelpunkt- begrenzte Liste von Eckpunkt-Indizes f?r jedes Dreieck (ab 0, im Gegenuhrzeigersinn je Au?enfl?che).}\par
\f0\pard\sb75{\fs24\b normals}\par
\f0\pard{\fs20 Optionale Leerzeichen- oder Doppelpunkt- begrenzte Liste von Ausw?rtsnormalen f?r jeden Gitterpunkt (points) oder "".}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst vom Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen Geometrieobjekts in der 3DView bei Erfolg, sonst "" und Fehlermeldung.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Tetraeder{\line}'Kante 2, zentriert im Ursprung{\line}pts= "1:0:-.707 -1:0:-.707 0:1:.707 0:-1:.707"{\line}'Kante 1, Basis zentriert im Ursprung{\line}pts= "0:.82:0 0:0:.58 .5:0:-.29 -.5:0:-.29"{\line}'schr?g liegend{\line}pts= "1:1:1 1:-1:-1 -1:1:-1 -1:-1:1"{\line}idcs= "0:1:2 0:2:3 0:3:1 1:3:2"{\line}'Pyramide H?he h, Basisl?nge 2*s{\line}pts= "0:h:0 -s:0:-s -s:0:s s:0:s s:0:-s"{\line}idcs= "0:1:2 0:2:3 0:3:4 0:4:1 1:3:2 1:4:3"}\par
\f0\pard\sb180\shading1000{\fs30\b AddIcosahedron(shapeName,radius,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein regelm??iges Ikosaeder (20Fl?chner) Geometrieobjekt hinzu, zentriert in (0,0,0) (Intern: Geometry#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Der Radius des Ikosaeder.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddImage(shapeName,geometryName,textures,imageName,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Bild zu einem Geometrieobjekt hinzu (Seite der Ausw?rtsnormalen). S.a. 'ResetMaterial'.{\line}Eine geometrische 'Ansicht' kann verschiedene Segmentbilder in einem Bild beinhalten.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b textures}\par
\f0\pard{\fs20 Eine Leerzeichen- oder Doppelpunkt- begrenzte Liste der 2D Texturkoordinaten f?r jeden 3D-Eckpunkt (points).{\line}Jeder Knoten hat 2 Werte (zwischen 0 und 1) welche die x,y Abbildung des Bildes zum Knoten bestimmen (zB. "0:1 1:1 1:0 0:0" f?r Gesamtbild auf 4eck).{\line}Kann "" (Standard) sein, wenn die Textur zuvor bereits gesetzt wurde.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Das im Geometrieobjekt zu ladende Bild oder ein Gradientpinsel (Brush).{\line}R?ckgabewert von ImageList.LoadImage, lokale oder Netzwerk- Bilddatei bzw. Brushname.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst vom Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://paulbourke.net/texture_colour/{\line}http://archivetextures.net{\line}http://www.reinerstilesets.de{\line}{\line}'Vollbild auf 4eck (Breite w, H?he h, y Pos){\line}pt4= "-w:y:h w:y:h w:y:-h -w:y:-h"{\line}pt6= "-w:y:h w:y:h w:y:-h  -w:y:h w:y:-h -w:y:-h"{\line}ptN= LDText.Replace(ptN, "w",w/2){\line}ptN= LDText.Replace(ptN, "h",h/2){\line}ptN= LDText.Replace(ptN, "y",y){\line}id4= "0:1:2 3:4:5"{\line}id6= "0:1:2 0:2:3"{\line}tx4= "0:1 1:1 1:0 0:0"{\line}tx6= "0:1 1:1 1:0  0:1 1:0 0:0"{\line}rec= AddGeometry(view, ptN,idN,"", col,"D"){\line}LD3DView.AddImage(view, rec,txN, img,"D"){\line}{\line}0:1 1:1 1:0 0:0 'Strd (tx4){\line}1:1 1:0 0:0 0:1 '90? reRo{\line}1:0 0:0 0:1 1:1 '180? Ro{\line}0:0 0:1 1:1 1:0 '270? reRo = 90? liRo{\line}1:1 0:1 0:0 1:0 'flipY{\line}0:1 0:0 1:0 1:1 'flipY 90? reRo{\line}0:0 1:0 1:1 0:1 'flipY 180? Ro = flipX{\line}1:0 1:1 0:1 0:0 'flipY 270? reRo = flipY 90? liRo}\par
\f0\pard\sb180\shading1000{\fs30\b AddPipe(shapeName,length,innerDiameter,outerDiameter,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein (Hohl)Zylinder/Rohr Geometrieobjekt hinzu, aufrecht (+y, stehend auf x,z Ebene) mit der Basis zentriert in (0,0,0) (Intern: Geometry#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b length}\par
\f0\pard{\fs20 Die L?nge des Rohres/Prismas.}\par
\f0\pard\sb75{\fs24\b innerDiameter}\par
\f0\pard{\fs20 Der innere Rohrdurchmesser (0 Vollzylinder/-prisma).}\par
\f0\pard\sb75{\fs24\b outerDiameter}\par
\f0\pard{\fs20 Der ?u?ere Rohrdurchmesser.{\line}= innerD.  Mantel{\line}< innerD.  umgest?lpt}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 Die Anzahl radialer Teilbereiche f?r das Rohr (>2, Standard: 18).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPointLight(shapeName,colour,xPos,yPos,zPos,range) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine ungerichtete Punktlichtquelle hinzu, begrenzte Reichweite, Intensit?t nimmt mit Entfernung ab (Intern: Light#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Lichtfarbe.}\par
\f0\pard\sb75{\fs24\b xPos}\par
\f0\pard{\fs20 Die x-Position des Lichtes.}\par
\f0\pard\sb75{\fs24\b yPos}\par
\f0\pard{\fs20 Die y-Position des Lichtes.}\par
\f0\pard\sb75{\fs24\b zPos}\par
\f0\pard{\fs20 Die z-Position des Lichtes.}\par
\f0\pard\sb75{\fs24\b range}\par
\f0\pard{\fs20 Der Lichtwirkungsbereich in alle Richtungen (Entfernung bis zu welcher der Lichteffekt wirkt).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der 3DView Lichtname.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPyramid(shapeName,sideLength,height,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Pyramide Geometrieobjekt hinzu, aufrecht (+y, stehend auf x,z Ebene) mit der Basis zentriert in (0,0,0).{\line}Ohne Basisfl?che, mit einw?rts gerichteten Normalen (Intern: Geometry#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b sideLength}\par
\f0\pard{\fs20 Die Kantenl?nge an der Basis.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRectangle(shapeName,width,height,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Rechteck (einseitige Ebene) Geometrieobjekt hinzu, zentriert in (0,0,0), liegt in x,y Ebene mit H?he z=0, Normale in +z Richtung (Intern: Geometry#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des Rechtecks (entlang x).}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Rechtecks (entlang y).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt (nur Seite der Ausw?rtsnormalen, Gegenseite wirkt transparent).}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRevolute(shapeName,path,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Revolute Geometrieobjekt hinzu. Dies ist eine (offene/geschlossene) Oberfl?che beginnend an (0,0,0) und aufw?rts gerichtet.{\line}Die Form ist definiert durch eine Punktemenge (Y,Z), wobei Y die vertikale Distanz entlang der Oberfl?che ab 0 beschreibt, Z ist der Mantelradius.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Eine Leerzeichen- oder Doppelpunkt- begrenzte Liste von 2D Punktkoordinaten zur Beschreibung der Revolutenform, zB. "y1:r1 y2:r2 ..." (y H?he, r Umkreisradius).}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 Die Anzahl radialer Teilbereiche (>2, zB. 3 Fl?che, Standard: 10, beeinflusst Anzahl der Dreiecke und Glattheit).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 '3-st?ckiger Baum{\line}path = "0:0 0:0.5 1:0.5 1:3 3:1 3:2.5 5:1 5:2 8:0"{\line}'Regelm. n-Prisma/-(Doppel)Pyramide{\line}path= "0:0 0:r h:r h:0"{\line}path= "0:0 0:r h:0" 'Pyram{\line}path= "0:0 h:r H:0" 'DoPyr{\line}AddRevolute(view, path,n+1, "Red","D")}\par
\f0\pard\sb180\shading1000{\fs30\b AddSphere(shapeName,radius,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Kugel Geometrieobjekt zentriert in (0,0,0) hinzu (Intern: Geometry#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Der Kugelradius.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 Die Anzahl der Raumbereiche (>1, Standard: 10, beeinflusst Anzahl der Dreiecke und Glattheit).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddSpotLight(shapeName,colour,xPos,yPos,zPos,xDir,yDir,zDir,angle,range) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine gerichtete Punktlichtquelle hinzu, begrenzter Lichtkegel und Reichweite, Intensit?t nimmt mit Entfernung ab (Intern: Light#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Lichtfarbe.}\par
\f0\pard\sb75{\fs24\b xPos}\par
\f0\pard{\fs20 Die x-Position des Lichtes.}\par
\f0\pard\sb75{\fs24\b yPos}\par
\f0\pard{\fs20 Die y-Position des Lichtes.}\par
\f0\pard\sb75{\fs24\b zPos}\par
\f0\pard{\fs20 Die z-Position des Lichtes.}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 Der x-Richtungsvektor [-1,1] der Lichtprojektion (Standard: 0).}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] der Lichtprojektion (Standard: 0).}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 Der z-Richtungsvektor [-1,1] der Lichtprojektion (Standard: -1).}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Lichtkegel des Strahls [Grad].}\par
\f0\pard\sb75{\fs24\b range}\par
\f0\pard{\fs20 Der Lichtwirkungsbereich (Entfernung bis zu welcher der Lichteffekt wirkt).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der 3DView Lichtname.}\par
\f0\pard\sb180\shading1000{\fs30\b AddTube(shapeName,path,diameter,divisions,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein rohr-/schlauchf?rmiges Geometrieobjekt hinzu (Intern: Geometry#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Eine Leerzeichen- oder Doppelpunkt- begrenzte Liste von 3D Punktkoordinaten, zB. "x1:y1:z1 x2:y2:z2 ...".}\par
\f0\pard\sb75{\fs24\b diameter}\par
\f0\pard{\fs20 Der Rohr-/Schlauchdurchmesser.}\par
\f0\pard\sb75{\fs24\b divisions}\par
\f0\pard{\fs20 Die Anzahl radialer Rohrbereiche (>1, Standard: 10, beeinflusst Anzahl der Dreiecke und Glattheit).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe oder ein Gradientpinsel (Brush) f?r das Objekt.}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b AddView(width,height,performance) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine 3DView Shape im GraphicsWindow hinzu, worin 3D Geometrieobjekte eingebunden und animiert werden k?nnen (Intern: View3D#).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b performance}\par
\f0\pard{\fs20 Vorzug von Schnelligkeit ?ber Qualit?t?  "True" oder "False" (Standard, 3DView fixiert auf definierte Breite/H?he).{\line}"True" entfernt visuelles Clipping (-> Gr??en?nderung mit GW), 'HitTest' (nicht verwendet) und Antialias (nicht ben?tigt).{\line}"False" zum Ablegen+Laden einer 3D-Modelldatei (s. LDControls.AllowDrop, -.FileDropped).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateRotation(shapeName,geometryName,xDir,yDir,zDir,startAngle,endAngle,duration,repeats) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein Geometrieobjekt auf animierte 3D-Rotation um einen Achsenvektor (asynchron, s. 'RotationCompleted' Ereignis).{\line}Verwendet die zweite Rotation "R2". Die erste ist weiterhin verf?gbar f?r eine andere Achsrotation.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des zu drehenden Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 Der x-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 Der z-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b startAngle}\par
\f0\pard{\fs20 Der Startwinkel [Grad] vom Grundzustand (Standard: 0).}\par
\f0\pard\sb75{\fs24\b endAngle}\par
\f0\pard{\fs20 Der Endwinkel [Grad] vom Grundzustand, zB. 360 (Standard: 0).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Dauer [sec] f?r einen vollen Rotationszyklus (0 beendet).}\par
\f0\pard\sb75{\fs24\b repeats}\par
\f0\pard{\fs20 Die Anzahl der Rotationszyklen (-1 f?r stetig).}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateRotation2(shapeName,geometryName,xDir,yDir,zDir,startAngle,endAngle,duration,repeats) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein Geometrieobjekt auf animierte 3D-Rotation um einen Achsenvektor (asynchron, s. 'RotationCompleted' Ereignis).{\line}Verwendet die dritte Rotation "R3". Die erste ist weiterhin verf?gbar f?r eine andere Achsrotation.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des zu drehenden Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 Der x-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 Der z-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b startAngle}\par
\f0\pard{\fs20 Der Startwinkel [Grad] vom Grundzustand (Standard: 0).}\par
\f0\pard\sb75{\fs24\b endAngle}\par
\f0\pard{\fs20 Der Endwinkel [Grad] vom Grundzustand (Standard: 0), zB. 360.}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Dauer [sec] f?r einen vollen Rotationszyklus (0 beendet).}\par
\f0\pard\sb75{\fs24\b repeats}\par
\f0\pard{\fs20 Die Anzahl der Rotationszyklen (-1 f?r stetig).}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateTranslation(shapeName,geometryName,x,y,z,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein Geometrieobjekt auf animierte geradlinige 3D-Bewegung (asynchron, s. 'TranslationCompleted' Ereignis).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des zu bewegenden Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Zielpunktes.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Zielpunktes.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Die z-Koordinate des Zielpunktes.}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Dauer [sec] der Animation (0 beendet).}\par
\f0\pard\sb180\shading1000{\fs30\b AutoControl(pitchRoll,shift,keyDistance,speed) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt automatische Steuerung f?r die Kamera.{\line}Dieser Modus ist zur allg. Kamerasteuerung, haupts?chlich zum Bewegen (?berflug) in einer 3D Szene.{\line}Vor-|R?ckw?rtsbewegung per Mausrad (+Umsch/Strg Taste f?r 5x schneller/langsamer).{\line}L|R Gieren (Yaw) und Auf|Ab Neigen (Pitch) Kamerabewegung mit L-Maus.{\line}L|R Gieren mit A,D oder Links,Rechts Taste.{\line}Vor-|R?ckw?rtsbewegung mit W,S oder Auf,Ab Taste.{\line}Rollen (Drehen) Kamerabewegung mit R-Maus.{\line}L-Doppelklick auf Objekt zur Zentrierung/Auswahl (Zentrum f?r Rotation R1).{\line}R-Doppelklick zum Zur?cksetzen der Aufw?rts-Richtung zu y (yUp=1).{\line}L|R Gieren (Yaw) und Auf|Ab Neigen (Pitch) Szenenbewegung mit Umsch+LMaus nach Objektwahl (worum die Szene dedreht wird).{\line}X,Y,Z Taste setzt diese Ansichts-/Aufw?rts-Richtung (Blick nach 0,0,0); +Umsch in die Gegenrichtung.}\par
\f0\pard\sb75{\fs24\b pitchRoll}\par
\f0\pard{\fs20 Auf|Ab Neigen und Rollen Bewegung erlauben?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b shift}\par
\f0\pard{\fs20 Umsch/Strg Tasten zur Maussteuerung erlauben?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b keyDistance}\par
\f0\pard{\fs20 Kameraabstand und Tastensteuerung:{\line}>0  Kameraabstand zum Ursprung bei X,Y,Z Taste (Init: 0,0,10){\line}=0  blockt X,Y,Z Tasten (Standard, ""){\line}<0  blockt auch A,D,W,S und Pfeiltasten}\par
\f0\pard\sb75{\fs24\b speed}\par
\f0\pard{\fs20 Vor/Zur?ck Schrittfaktor f?r W,Up,Rad? bzw. S,Down,Rad?:{\line}>0  zB. 0.833=1/1.2=5/6 f?r dStep=1{\line}=0  blockt W,S, Up,Down, Mausrad (Standard){\line}<0  Gegenrichtung}\par
\f0\pard\sb180\shading1000{\fs30\b AutoControl2(keyDistance,speed) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt automatische Steuerung f?r die Kamera.{\line}Dieser Modus ist eher f?r Drehen und Ansicht einer 3D Szene (Inspektion), als zum Bewegen durch die Szene.{\line}Rein|Raus Zoom per Mausrad (+Umsch/Strg Taste f?r 5x schneller/langsamer).{\line}L|R Schwenk mit A,D oder Links,Rechts Taste. Auf|Ab Schwenk mit W,S oder Auf,Ab Taste.{\line}L-Doppelklick auf Objekt zur Zentrierung/Auswahl (Zentrum f?r Rotation R1).{\line}R-Doppelklick zum Zur?cksetzen der Aufw?rts-Richtung zu y (yUp=1).{\line}L|R Gieren (Yaw) und Auf|Ab Neigen (Pitch) Szenenbewegung mit LMaus nach Objektwahl (worum die Szene dedreht wird).{\line}Rollen (Drehen) Szenenbewegung mit R-Maus.{\line}X,Y,Z Taste setzt diese Ansichts-/Aufw?rts-Richtung (Blick Richtung gew?hlten Zentrums); +Umsch in die Gegenrichtung.}\par
\f0\pard\sb75{\fs24\b keyDistance}\par
\f0\pard{\fs20 Kameraabstand und Tastensteuerung:{\line}>0  Kameraabstand zum Ursprung bei X,Y,Z Taste (Init: 0,0,10){\line}=0  blockt X,Y,Z Tasten (Standard, ""){\line}<0  blockt auch A,D,W,S und Pfeiltasten}\par
\f0\pard\sb75{\fs24\b speed}\par
\f0\pard{\fs20 Vor/Zur?ck Schrittfaktor f?r A,D,W,S, Pfeiltasten, Mausrad:{\line}>0  zB. 0.833=1/1.2=5/6 f?r dStep=1{\line}=0  blockt A,D,W,S, Pfeiltasten, Mausrad (Standard){\line}<0  Gegenrichtung}\par
\f0\pard\sb180\shading1000{\fs30\b BoundingBox(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Abmessungen und Position des umgebenden H?llk?rpers f?r ein einzelnes Geometrieobjekt (s. GetPosition).{\line}Dies sind die aktuellen Werte/Koordinaten (nach allen Transformationen).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 6-elementiger Array (ab 1) folgender Dimensionen/Position bei Erfolg, sonst "FAILED":{\line}{\line}dimX = box[1]	(Breite){\line}dimY = box[2]	(H?he){\line}dimZ = box[3]	(Tiefe){\line}minX = box[4]{\line}minY = box[5]{\line}minZ = box[6]}\par
\f0\pard\sb180\shading1000{\fs30\b CameraProperties(shapeName,nearDistance,farDistance,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den horizontalen Blickwinkel der Kamera, sowie Clipping Abst?nde (Entfernung zur nahen/fernen Ausschneideebene).{\line}Die fundamentalen Eigenschaften f?r perspektivische Kamerasicht.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b nearDistance}\par
\f0\pard{\fs20 Der nahe Clipping Abstand (kann nahes Objekt verbessern zB. Maueraufprall Erkennung).{\line}Bei -angle ist 0.001 (Standard: 0.125, sonst >=0.001).}\par
\f0\pard\sb75{\fs24\b farDistance}\par
\f0\pard{\fs20 Der ferne Clipping Abstand (kann Leistung verbessern).{\line}Bei -angle ist unendlich (Standard, sonst >= nearDistance).}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Sichtkegel der Kamera [Grad]. Beeinflusst den perspektivischen Fluchtpunkt (Standard: 60).{\line}Falls negativ, wird eine orthographische Kamera (Parallelprojektion mit Sichtbreite -angle) verwendet (statt perspektivische Zentralprojektion).}\par
\f0\pard\sb180\shading1000{\fs30\b CloneObject(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine komplette Kopie eines einzelnen Geometrieobjekts mit all seinen Eigenschaften (Intern: Geometry#+1).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des zu kopierenden Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen kopierten Geometrieobjekts in der 3DView bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Freeze(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Einfrieren eines Geometrieobjekts zur kleinen Leistungsverbesserung. Dieses kann danach in keiner Weise modifiziert werden.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des einzufrierenden Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Nichts (Fehlermeldung bei Mi?erfolg)}\par
\f0\pard\sb180\shading1000{\fs30\b GetCameraDirection(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Blickrichtung der Kamera (Richtungsvektor) als Array der Komponenten "1=xDir;2=yDir;3=zDir;".{\line}xDir*xDir + yDir*yDir + zDir*zDir = 1 (Einheitsvektor)}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 3-elementiger Array mit dem Richtungsvektor der Kamerasicht (Standard: "1=0;2=0;3=-1;").}\par
\f0\pard\sb180\shading1000{\fs30\b GetCameraPosition(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Kameraposition als Array der Koordinaten "1=xPos;2=yPos;3=zPos;".}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 3-elementiger Array mit den Positionskoordinaten der Kamera (Standard: "1=0;2=0;3=10;").}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Radius zum Ursprung (0,0,0){\line}P = LD3DView.GetCameraPosition(view){\line}r = Math.SquareRoot(P[1]*P[1] + P[2]*P[2] + P[3]*P[3]){\line}{\line}'Abstand 2er Punkte (Vektorl?nge){\line}a = Math.SquareRoot(dx*dx + dy*dy + dz*dz){\line}{\line}'Koord. von P2 ab P,r,dir (Vektorverschiebung){\line}x2 = P[1] + r * dir[1]{\line}y2 = P[2] + r * dir[2]{\line}z2 = P[3] + r * dir[3]}\par
\f0\pard\sb180\shading1000{\fs30\b GetCameraUpDirection(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Aufw?rts-Richtungsvektor in der Szenenprojektion als Array der Komponenten "1=xUp;2=yUp;3=zUp;".{\line}xUp*xUp + yUp*yUp + zUp*zUp = 1 (Einheitsvektor)}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 3-elementiger Array mit dem Aufw?rts Richtungsvektor der 3DView (Standard: "1=0;2=1;3=0;").}\par
\f0\pard\sb180\shading1000{\fs30\b GetPosition(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die transformierte (aktuelle) Zentrumsposition f?r ein bestehendes Geometrieobjekt (s. BoundingBox).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 3-elementiger Array (ab 1) der transformierten Position bei Erfolg, sonst "FAILED":{\line}{\line}centX = pos[1]{\line}centY = pos[2]{\line}centZ = pos[3]}\par
\f0\pard\sb180\shading1000{\fs30\b HitTest(shapeName,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ein Auftreffen auf ein Geometrieobjekt in der 3DView. s. LD3DView.AddView(w,h, "").{\line}Ein negativer Wert f?r eine Koordinate bezieht sich auf die Mitte der 3DView (Kameraansicht).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate im GraphicsWindow (innerhalb der 3DView).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate im GraphicsWindow (innerhalb der 3DView).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2-elementiger Array mit dem Name des Zielobjekts und seiner Entfernung (zB. "1=Geometry#;2=dist;") oder "" f?r keinen Treffer.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 3D-samples\\LD3DView.sb, LD3DMazeGame.sb}\par
\f0\pard\sb180\shading1000{\fs30\b LastRotationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name des Geometrieobjekts welches zuletzt eine animierte Volldrehung beendete.}\par
\f0\pard\sb180\shading1000{\fs30\b LastTranslationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name des Geometrieobjekts welches zuletzt eine animierte Vollbewegung beendete.}\par
\f0\pard\sb180\shading1000{\fs30\b LoadModel(shapeName,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?dt ein geometrisches Modell von einer Datei und f?gt dieses an (0,0,0) in der 3DView hinzu (Intern: Geometry#+1).{\line}Unterst?tzte Formate: 3ds, lwo, obj, (obj.gz ->)objz, off, stl. Position und Dimension entsprechend vorgegebener Geometrieeigenschaften.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu ladenden Modelldatei.{\line}Oft sind auch (gleichnamige) Bilddateien usw. im selben Ordner erforderlich.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Namen der hinzugef?gten Geometrieobjekte bzw. Teilobjekte.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 3D-samples\\LD3DViewImport.sb{\line}http://archive3d.net{\line}http://archibase.co{\line}http://free3d.com{\line}http://leopoly.com{\line}http://tf3dm.com{\line}http://yobi3d.com}\par
\f0\pard\sb180\shading1000{\fs30\b ModifyObject(shapeName,geometryName,action) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Durchf?hren einer Aktion an einem Geometrie- oder Lichtobjekt.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrie- oder Lichtobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b action}\par
\f0\pard{\fs20 Die durchzuf?hrende Aktion:{\line}"H"  Verbergen{\line}"S"  Anzeigen{\line}"X"  Entfernen}\par
\f0\pard\sb180\shading1000{\fs30\b MoveCamera(shapeName,yaw,pitch,roll,move) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ndert die Blickrichtung und Position der Kamera relativ zur aktuellen Ausrichtung/Position.{\line}Winkelangaben im Bereich [0,-/+180] oder [0,-/+360], zB. 10|-350 bzw. -10|350.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b yaw}\par
\f0\pard{\fs20 Die Links/Rechts ? Schwenkung [Grad] ab aktueller Ausrichtung (Gierung, Standard: 0).{\line}+  Kamera rechts, Szene links{\line}-   Kamera links, Szene rechts}\par
\f0\pard\sb75{\fs24\b pitch}\par
\f0\pard{\fs20 Die Rauf/Runter ? Neigung [Grad] ab aktueller Ausrichtung (Standard: 0).{\line}+  Kamera rauf, Szene runter{\line}-   Kamera runter, Szene rauf}\par
\f0\pard\sb75{\fs24\b roll}\par
\f0\pard{\fs20 Die Verdrehung in Blickrichtung [Grad] ab aktueller Ausrichtung (Standard: 0).{\line}+  Kamera/Szene im/gegen Uhrzeigersinn{\line}-   Kamera/Szene gegen/im Uhrzeigersinn}\par
\f0\pard\sb75{\fs24\b move}\par
\f0\pard{\fs20 Die Vor-/R?ckw?rts Bewegung [Pxl] in Kamerakoordinaten (entlang Blickrichtung) ab aktueller Position.{\line}+  Kamera vorw?rts{\line}-   Kamera r?ckw?rts}\par
\f0\pard\sb180\shading1000{\fs30\b QueuedRotationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der aktuell abgeschlossenen animierten Volldrehungen.}\par
\f0\pard\sb180\shading1000{\fs30\b QueuedTranslationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der aktuell abgeschlossenen animierten Vollbewegungen.}\par
\f0\pard\sb180\shading1000{\fs30\b ResetCamera(shapeName,xPos,yPos,zPos,xDir,yDir,zDir,xUp,yUp,zUp) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Position und Blickrichtung der Kamera, sowie (optional) die Aufw?rtsrichtung der Ansicht.{\line}Standard: Position in (0,0,10), zentrierte Ansicht entlang -z Achse abw?rts, +y oben und +x rechts.{\line}Mindestens ein Dir Vektor mu? <>0 sein, alle anderen Pos/Dir Werte k?nnen dann "" sein.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b xPos}\par
\f0\pard{\fs20 Die x-Position der Kamera (Standard: 0).}\par
\f0\pard\sb75{\fs24\b yPos}\par
\f0\pard{\fs20 Die y-Position der Kamera (Standard: 0).}\par
\f0\pard\sb75{\fs24\b zPos}\par
\f0\pard{\fs20 Die z-Position der Kamera (Standard: 10).}\par
\f0\pard\sb75{\fs24\b xDir}\par
\f0\pard{\fs20 Der x-Richtungsvektor [-1,1] der Kamerasicht (-/+ Links/Rechts, Standard: 0).}\par
\f0\pard\sb75{\fs24\b yDir}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] der Kamerasicht (-/+ Runter/Rauf, Standard: 0).}\par
\f0\pard\sb75{\fs24\b zDir}\par
\f0\pard{\fs20 Der z-Richtungsvektor [-1,1] der Kamerasicht (-/+ Rein/Raus, Standard: -1).}\par
\f0\pard\sb75{\fs24\b xUp}\par
\f0\pard{\fs20 Optionaler x-Richtungsvektor [-1,1], definiert Aufw?rts-Richtung der Szenenprojektion (Standard: 0).}\par
\f0\pard\sb75{\fs24\b yUp}\par
\f0\pard{\fs20 Optionaler y-Richtungsvektor [-1,1], definiert Aufw?rts-Richtung der Szenenprojektion (Standard: 1).}\par
\f0\pard\sb75{\fs24\b zUp}\par
\f0\pard{\fs20 Optionaler z-Richtungsvektor [-1,1], definiert Aufw?rts-Richtung der Szenenprojektion (Standard: 0).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Z-Taste (Standard Ansicht):{\line}ResetCamera(view, 0,0,10, 0,0,-1, 0,1,0){\line}ResetCamera(view, "","",10, "","",-1, "",1,""){\line}'Umsch+Z:{\line}ResetCamera(view, 0,0,-10, 0,0,1, 0,1,0){\line}'X-Taste:{\line}ResetCamera(view, 10,0,0, -1,0,0, 0,1,0){\line}'Umsch+X:{\line}ResetCamera(view, -10,0,0, 1,0,0, 0,1,0){\line}'Y-Taste:{\line}ResetCamera(view, 0,10,0, 0,-1,0, 0,0,1){\line}'Umsch+Y:{\line}ResetCamera(view, 0,-10,0, 0,1,0, 0,0,1)}\par
\f0\pard\sb180\shading1000{\fs30\b ResetMaterial(shapeName,geometryName,colour,materialType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 (Er)Setzt das Material/Farbe f?r ein bestehendes Geometrieobjekt. S.a. 'LoadImage'.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die neue Farbe oder ein Gradientpinsel (Brush) f?r das Objekt (nur Seite der Ausw?rtsnormalen).}\par
\f0\pard\sb75{\fs24\b materialType}\par
\f0\pard{\fs20 Der neue Materialtyp:{\line}"E"  Emissiv, konstante Helligkeit{\line}"D"  Diffus, beeinflusst durch Licht{\line}"S"  Spiegelnd, zus?tzliche Glanzpunkte}\par
\f0\pard\sb180\shading1000{\fs30\b ReverseNormals(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Umkehren aller Ausw?rtsnormalen (1/Gitterpunkt) f?r ein Geometrieobjekt.{\line}Macht zB. die Innenoberfl?che eines K?rpers sichtbar anstatt der Au?enoberfl?che (zB. SkyDome).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts dessen Normalen umgekehrt werden.}\par
\f0\pard\sb180\shading1000{\fs30\b RotateGeometry(shapeName,geometryName,x,y,z,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotiert ein Geometrieobjekt um dessen Zentrum (erste Rotation "R1", relativ ab Originalposition).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Der x-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Der z-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Drehwinkel vom Grundzustand [Grad] ab Originalposition.{\line}Blick entlang +/- Drehachse -> im/gegen Uhrzeigersinn}\par
\f0\pard\sb180\shading1000{\fs30\b RotateGeometry2(shapeName,geometryName,x,y,z,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotiert ein Geometrieobjekt um dessen Zentrum (zweite Rotation "R2", relativ ab aktueller Position).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Der x-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Der z-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Drehwinkel [Grad] ab aktueller Position.{\line}Blick entlang +/- Drehachse -> im/gegen Uhrzeigersinn}\par
\f0\pard\sb180\shading1000{\fs30\b RotateGeometry3(shapeName,geometryName,x,y,z,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotiert ein Geometrieobjekt um dessen Zentrum (dritte Rotation "R3", relativ ab aktueller Position).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Der x-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Der y-Richtungsvektor [-1,1] der Drehachse.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Drehwinkel [Grad] ab aktueller Position.{\line}Blick entlang +/- Drehachse -> im/gegen Uhrzeigersinn}\par
\f0\pard\sb180\shading1000{\fs30\b RotationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Beendigung einer Drehanimation (AnimateRotation(2)).}\par
\f0\pard\sb180\shading1000{\fs30\b ScaleGeometry(shapeName,geometryName,scaleX,scaleY,scaleZ) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Skaliert (zoomt) ein Geometrieobjekt an dessen Zentrum. s. SetCentre(..,"S")}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 Der x-Skalierungsfaktor (Standard: 1).}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 Der y-Skalierungsfaktor (Standard: 1).}\par
\f0\pard\sb75{\fs24\b scaleZ}\par
\f0\pard{\fs20 Der z-Skalierungsfaktor (Standard: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b SetBillBoard(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein Geometrieobjekt auf kontinuierliche Rotation zur Kameraverfolgung.{\line}Verwendet die zweite und dritte Rotation "R2R3".}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts in der 3DView.}\par
\f0\pard\sb180\shading1000{\fs30\b SetCentre(shapeName,geometryName,x,y,z,options) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt das Zentrum von Rotate- und ScaleGeometry Transformationen f?r ein Geometrieobjekt.{\line}Standardm??ig ist dies das Zentrum des H?llk?rpers f?r das Geometrieobjekt (meist 0,0,0).{\line}Das Zentrum wird mittels der Koordinaten bei Erstellung des Geometrieobjekts definiert und kann auch au?erhalb des Geometrieobjekts liegen.{\line}Ist ein Koordinatenwert auf "" gesetzt, wird daf?r der Standardwert f?r das Zentrum verwendet.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des zu transformierenden Geometrieobjekts.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Zentrums.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Zentrums.}\par
\f0\pard\sb75{\fs24\b z}\par
\f0\pard{\fs20 Die z-Koordinate des Zentrums.}\par
\f0\pard\sb75{\fs24\b options}\par
\f0\pard{\fs20 Optionen zur Steuerung der Zentrierung (auch Mehrfachwerte, zB. "R1R2R3" zum Setzen f?r alle drei Rotationen):{\line}"R1"  RotateGeometry{\line}"R2"  RotateGeometry2, AnimateRotation{\line}"R3"  RotateGeometry3, AnimateRotation2{\line}"S"   ScaleGeometry}\par
\f0\pard\sb180\shading1000{\fs30\b SpecularExponent \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Spiegelungsexponent bei Verwendung von spiegelndem Material "S" f?r Geometrieobjekte (Standard: 5).{\line}Dieser Exponent definiert den rel. Anteil der Glanzkomponente des Beleuchtungsmodells f?r ein Material.{\line}Ist zu setzen bevor ein neues Geometrieobjekt mit dieser Eigenschaft erstellt wird, danach unver?nderbar.}\par
\f0\pard\sb180\shading1000{\fs30\b SwapUpDirection(shapeName,geometryName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotiert (Wechselt) die y<->z Richtungen f?r ein Geometrieobjekt (zB. der Reihe nach: +y, -z, -y, +z, .., entspricht 90? Linksdrehung(en) um x-Achsvektor).{\line}Hilfreich f?r Geometrieobjekte, die nach zUp=1 Regel erstellt wurden. Konvertiert diese zur yUp=1 Richtung (wie in LD3DView verwendet).{\line}Direkt nach Erstellung/Laden anwenden, da skalierte Objekte dabei auf Originalgr??e zur?ckgesetzt werden.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Rechtssystem_(Mathematik){\line}RotateGeometry(view, geo, 1,0,0, -90) 'SwapUpDirection(view, geo)}\par
\f0\pard\sb180\shading1000{\fs30\b TranslateGeometry(shapeName,geometryName,dX,dY,dZ) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt ein Geometrieobjekt geradlinig an dessen Zentrum, relativ ab Originalposition.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der 3DView Shape.}\par
\f0\pard\sb75{\fs24\b geometryName}\par
\f0\pard{\fs20 Der Name des Geometrieobjekts, zB. model[1].}\par
\f0\pard\sb75{\fs24\b dX}\par
\f0\pard{\fs20 Der Versatz in x-Richtung ab Originalposition.}\par
\f0\pard\sb75{\fs24\b dY}\par
\f0\pard{\fs20 Der Versatz in y-Richtung ab Originalposition.}\par
\f0\pard\sb75{\fs24\b dZ}\par
\f0\pard{\fs20 Der Versatz in z-Richtung ab Originalposition.}\par
\f0\pard\sb180\shading1000{\fs30\b TranslationCompleted \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Beendigung einer geradlinigen Bewegungsanimation (AnimateTranslation).}\par
\f0\pard\sb300\shading2000{\fs36\b LDArray}\par
\f0\pard{\fs20 Ein 1D LDArray der schneller operiert als gew?hnliche SB-Arrays. LDArrays und SB-Arrays sind unterschiedlich definiert.{\line}Ein neuer LDArray mu? zuerst mit 'Create' erstellt werden (Intern: Array#, s. FastArray).{\line}N?tzlich f?r Arrays mit mehr als 100 bis 1000 Elementen (Zahl, String, Var). Unterst?tzt auch Leerwerte ("").{\line}Bei Fehler wird "FAILED" zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDUnits.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Copy(array1,array2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert einen LDArray in einen bestehenden LDArray.{\line}Beide LDArrays m?ssen gleich dimensioniert sein.}\par
\f0\pard\sb75{\fs24\b array1}\par
\f0\pard{\fs20 Der zu kopierende LDArray (Quellarray).}\par
\f0\pard\sb75{\fs24\b array2}\par
\f0\pard{\fs20 Der LDArray in den die Daten kopiert werden (Zielarray).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CopyNew(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert einen LDArray in einen neuen LDArray (Intern: Array#+1).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu kopierende LDArray.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen LDArrays (Kopie) bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CopyToSBArray(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert einen LDArray in einen neuen SB-Array. Ein bestehender SB-Array wird dabei ?berschrieben.{\line}Die Umkehrung (SB-Array zu LDArray) ist problematisch, da SB-Arrays nicht zwangsl?ufig durch fortlaufendee Ganzzahlen indexiert sind.{\line}SB-Arrays k?nnen keine Leerwerte ("") enthalten, daher werden diese Werte nicht mitkopiert.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der Name des LDArrays (Quelle).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des SB-Arrays (Ziel) bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Count(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl nicht-leerer Elemente in einem LDArray.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der Name des LDArrays.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente, die Werte enthalten.}\par
\f0\pard\sb180\shading1000{\fs30\b Create(maxSize) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen neuen LDArray zur Verwendung mit Zahlen oder Strings. Ein neuer LDArray mu? hiermit zuerst erstellt werden (Intern: Array#).}\par
\f0\pard\sb75{\fs24\b maxSize}\par
\f0\pard{\fs20 Die maximale Anzahl der Elemente im Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des LDArrays bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromIndices(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen neuen LDArray aus den Indizes eines SB-Arrays (Intern: Array#+1).}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 Der SB-Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen LDArrays bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromValues(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen neuen LDArray aus den Werten eines SB-Arrays (Intern: Array#+1).}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 Der SB-Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen LDArrays bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Delete(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht einen bestehenden LDArray aus dem Arbeitsspeicher (nicht unbedingt n?tig, zur Freigabe von Speicherplatz bei Verwendung vieler Arrays).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der Name des zu l?schenden LDArrays.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetIndex(sbArray,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den ersten Index f?r einen Wert in einem SB-Array.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 Der SB-Array.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu suchende Arraywert (buchstabengetreu).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der erste Index f?r den Wert im SB-Array oder "" (nicht gefunden), sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetValue(array,index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen Wert in einem LDArray.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der Name des LDArrays.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index des Elementes, dessen Wert zu ermitteln ist (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ermittelte Arraywert bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Load(array,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?dt einen LDArray aus einer Datei.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der LDArray in den die Daten geladen werden. Dieser mu? bereits bestehen.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad zum Laden des LDArrays.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl geladener Arrayelemente.}\par
\f0\pard\sb180\shading1000{\fs30\b Save(array,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert einen LDArray in eine Datei.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu speichernde LDArray.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad zum Speichern des LDArrays.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl gespeicherter Arrayelemente.}\par
\f0\pard\sb180\shading1000{\fs30\b Search(array,searchString,match) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen LDArray mit Indizes der Werte, welche den Suchstring beinhalten. Gro?-/Kleinschreibung egal (keine Unterscheidung).{\line}Der Eingabearray bleibt unver?ndert und der Trefferarray mu? bereits bestehen (gleiche Gr??e wie durchsuchter LDArray).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der nach Treffern zu durchsuchende LDArray.}\par
\f0\pard\sb75{\fs24\b searchString}\par
\f0\pard{\fs20 Die zu suchende Zeichenfolge.}\par
\f0\pard\sb75{\fs24\b match}\par
\f0\pard{\fs20 Ein LDArray mit den Indizes der Trefferwerte.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl gefundener Suchtreffer.}\par
\f0\pard\sb180\shading1000{\fs30\b SetValue(array,index,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen Wert in einem bestehenden LDArray. Ein neuer LDArray mu? zuerst mit 'Create' erstellt werden.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der Name des LDArrays.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index des zu ?ndernden Elementes im LDArray (ab 1).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Sort(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sortiert einen LDArray.{\line}Standard ist alphabetische Sortierung, daher kommt "10" vor "2".{\line}Um nach Zahlenwert zu sortieren, m?ssen alle Werte numerisch sein (oder leer).{\line}Leerwerte sind am Ende der Sortierung angereiht.{\line}Der angegebene LDArray wird durch den sortierten LDArray ersetzt.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Zu sortierender LDArray.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SortIndex(array,index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?llt einen LDArray mit den sortierten Indizes eines zu sortierenden LDArrays.{\line}Standard ist alphabetische Sortierung, daher kommt "10" vor "2".{\line}Um nach Zahlenwert zu sortieren, m?ssen alle Werte numerisch sein (oder leer).{\line}Leerwerte sind am Ende der Sortierung angereiht.{\line}Der angegebene LDArray bleibt unver?ndert und der Indizes-beinhaltende LDArray mu? zuvor auf die gleiche Gr??e wie der zu sortierende dimensioniert werden.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der LDArray welcher nach Sortierung die Reihenfolge der Indizes beinhaltet.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Ein LDArray mit der Reihenfolge des sortierten LDArrays.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDBits}\par
\f0\pard{\fs20 Bitweise Logik zum Speichern bin?rer Flags als Bits in einer einzelnen -/+ Ganzzahl.{\line}Intern wird dazu eine 32 Bit -/+ Ganzzahl (Int32, -2147483648 bis 2147483647, -2^31 bis 2^31-1) verwendet.{\line}Index 32 ist Vorzeichenbit (wenn gesetzt -> neg. Ganzzahl als Zweierkomplement).{\line}Vergleichbar mit 32-elementigem Array aus 1 und 0 Werten, gespeichert als einzelne Zahl.{\line}Die 32 Bits (1 bis 32) werden ab 1 indexiert. Arraywerte (0|1) sind die gesetzten 2er Potenzen von 0 bis 30:{\line}bit1..2^0, bit2..2^1, bit3..2^2, usw.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://www.catonmat.net/blog/low-level-bit-hacks-you-absolutely-must-know/{\line}http://graphics.stanford.edu/~seander/bithacks.html}\par

\f0\pard\sb180\shading1000{\fs30\b AndBits(var1,var2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bitweise And (&, Und) Verkettung zweier Zahlen.{\line}0 & 0 = 0{\line}0 & 1 = 0{\line}1 & 0 = 0{\line}1 & 1 = 1}\par
\f0\pard\sb75{\fs24\b var1}\par
\f0\pard{\fs20 Die erste Zahl.}\par
\f0\pard\sb75{\fs24\b var2}\par
\f0\pard{\fs20 Die zweite Zahl.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die And Zahl (Bit gesetzt, wenn beide Eingabebits gesetzt).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 1100 (12) And{\line}1010 (10) ={\line}1000  (8){\line}{\line}LDBits.AndBits(15, 255) '15{\line}(0F & FF = 0F, 00001111 & 11111111 = 00001111){\line}'n Geradzahl?{\line}LDBits.AndBits(n,1) '0 gerade, 1 ungerade}\par
\f0\pard\sb180\shading1000{\fs30\b GetBit(var,bit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen einzelnen Bitwert in einer angegebenen Zahl (s. GetBits f?r alle).}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 Die zu ?berpr?fende Zahl.}\par
\f0\pard\sb75{\fs24\b bit}\par
\f0\pard{\fs20 Der Index f?r das abzufragende Bit (1 bis 32, f?r 2er Potenzen 0-31).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Bitwert:{\line}0	(ungesetzt){\line}1	(gesetzt)}\par
\f0\pard\sb180\shading1000{\fs30\b GetBits(var) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle Bitwerte einer angegebenen Zahl als Array (s. GetBit f?r Einzelbit).{\line}Info: Der Arrayindex ist NICHT die 2er Potenz des Bits, diese ist Index-1.}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 Die zu ?berpr?fende Zahl.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die einzelnen Bitwerte (0 oder 1) als 32-elementiger Array (ab 1).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 GetBits(6) ' "1=0;2=1;3=1;4=0;.."{\line}Unteres Halbbyte/Nibble: 0+2^1+2^2+0 = 6}\par
\f0\pard\sb180\shading1000{\fs30\b Not(var) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bitweise Not (~, Nicht) Umkehrung f?r eine Zahl.{\line}~0 = 1{\line}~1 = 0}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 Die umzukehrende Zahl.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Not Zahl (alle Bits umgekehrt).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Not 1100 (12) ={\line}..110011 (-13){\line}{\line}LDBits.Not(0) 'gibt -1 (alle Bits gesetzt)}\par
\f0\pard\sb180\shading1000{\fs30\b OrBits(var1,var2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bitweise Or (|, Oder) Verkettung zweier Zahlen.{\line}0 | 0 = 0{\line}0 | 1 = 1{\line}1 | 0 = 1{\line}1 | 1 = 1}\par
\f0\pard\sb75{\fs24\b var1}\par
\f0\pard{\fs20 Die erste Zahl.}\par
\f0\pard\sb75{\fs24\b var2}\par
\f0\pard{\fs20 Die zweite Zahl.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Or Zahl (Bit gesetzt, wenn bereits ein Eingabebit gesetzt).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 1100 (12) Or{\line}1010 (10) ={\line}1110 (14){\line}{\line}LDBits.OrBits(15, 255) '255{\line}(0F | FF = FF, 00001111 | 11111111 = 11111111)}\par
\f0\pard\sb180\shading1000{\fs30\b SetBit(var,bit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein Bit in einer Zahl (Setzen auf 1).}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 Die Zahl in der das Bit gesetzt wird.}\par
\f0\pard\sb75{\fs24\b bit}\par
\f0\pard{\fs20 Der Index f?r das zu setzende Bit (1 bis 32).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ge?nderte Zahl mit neu gesetztem Bit.}\par
\f0\pard\sb180\shading1000{\fs30\b UnsetBit(var,bit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt ein Bit in einer Zahl (Setzen auf 0).}\par
\f0\pard\sb75{\fs24\b var}\par
\f0\pard{\fs20 Die Zahl von der das Bit entfernt wird.}\par
\f0\pard\sb75{\fs24\b bit}\par
\f0\pard{\fs20 Der Index f?r das zu entfernende Bit (1 bis 32).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ge?nderte Zahl nach entferntem Bit.}\par
\f0\pard\sb180\shading1000{\fs30\b XOrBits(var1,var2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bitweise XOr (^, eXklusivOder) Verkettung zweier Zahlen.{\line}0 ^ 0 = 0{\line}0 ^ 1 = 1{\line}1 ^ 0 = 1{\line}1 ^ 1 = 0}\par
\f0\pard\sb75{\fs24\b var1}\par
\f0\pard{\fs20 Die erste Zahl.}\par
\f0\pard\sb75{\fs24\b var2}\par
\f0\pard{\fs20 Die zweite Zahl.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die XOr Zahl (Bit gesetzt, wenn nur ein Eingabebit gesetzt).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 1100 (12) XOr{\line}1010 (10) ={\line}0110  (6){\line}{\line}LDBits.XOrBits(15, 255) '240{\line}(0F ^ FF = F0, 00001111 ^ 11111111 = 11110000){\line}{\line}'Komplement?rfarbe zu col{\line}compl = LDBits.XOrBits(col, "#FFFFFF"){\line}'2x Anwendung -> Identit?t{\line}LDBits.XOrBits(LDBits.XOrBits(var1,var2),var2) 'var1}\par
\f0\pard\sb300\shading2000{\fs36\b LDBlueTooth}\par
\f0\pard{\fs20 BlueTooth Steuerung.{\line}Die erweiterten Features beziehen sich auf Nicht-Datei?bertragung (effektiv Schreiben eines Ger?tetreibers).{\line}Zur Kommunikation mit einem Bluetooth USB-Stick mu? das externe Bluetooth Ger?t angeschlossen und auf 'sichtbar' gesetzt sein, bevor das SB-Programm gestartet wird.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDBlueTooth.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Connect() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbindet ein externes Ger?t und Dienst mit dem Bluetooth USB-Stick (Erweitertes Feature).{\line}Zuerst mu? die Initialisierung erfolgen, dann Setzen des Ger?tes, des Dienstes und der Codierung.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" bei Erfolg, sonst "False".}\par
\f0\pard\sb180\shading1000{\fs30\b DataAvailable \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl empfangener Datenbytes in der Warteschlange zum Lesen.{\line}Dies kann in einem Timer angewandt werden zur ?berpr?fung auf empfangene Daten.}\par
\f0\pard\sb180\shading1000{\fs30\b Device \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das aktuelle Bluetooth Ger?t.}\par
\f0\pard\sb180\shading1000{\fs30\b Encode \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die aktuelle Bluetooth Datencodierung (Erweitertes Feature).}\par
\f0\pard\sb180\shading1000{\fs30\b GetDevices() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste von erkannten Bluetooth Ger?ten.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von Ger?ten bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetEncodings() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste verf?gbarer Codierungen (Erweitertes Feature).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von Codierungen bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetServices() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste verf?gbarer Dienstprotokolle (Erweitertes Feature).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von Diensten bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Initialise() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Initialisiert einen Bluetooth USB-Stick und erkennt sichtbare externe Ger?te.{\line}Sobald Ger?te aus/in Reichweite gelangen, wird die Liste aktualisiert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False", f?r Erfolg oder Fehler bei Konfiguration einer Bluetooth Schnittstelle.}\par
\f0\pard\sb180\shading1000{\fs30\b InRange \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein Bluetooth Ger?t in Reichweite gelangt (Scheint unerwartet zu feuern).}\par
\f0\pard\sb180\shading1000{\fs30\b LastDevice \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das letzte Ger?t in- oder au?erhalb der Reichweite.}\par
\f0\pard\sb180\shading1000{\fs30\b LastError \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die letzte Fehlermeldung. Fehlermeldungen k?nnen f?r verschiedene Fehlfunktionen gesetzt sein.}\par
\f0\pard\sb180\shading1000{\fs30\b OutOfRange \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein Bluetooth Ger?t au?er Reichweite gelangt (Scheint nicht wie beabsichtigt zu funktionieren).}\par
\f0\pard\sb180\shading1000{\fs30\b ReceiveData() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Empf?ngt (holt) Daten von einem Bluetooth Ger?t (Erweitertes Feature).{\line}Das Ger?t mu? initialisiert und verbunden sein. Die Codierung sollte ebenfalls gesetzt sein.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein String empfangener Zeichen bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b ReceiveFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Empf?ngt (holt) eine Datei von einem angeschlossenen externen Bluetooth Ger?t.{\line}Zuerst mu? Initialisierung erfolgen, dann Setzen des Ger?tes.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der Ort zum Speichern der empfangenen Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Ergebnis Statusmeldung, "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SendData(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet Daten an ein Bluetooth Ger?t (Erweitertes Feature).{\line}Das Ger?t mu? initialisiert und verbunden sein. Die Codierung sollte ebenfalls gesetzt sein.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Ein String zu sendender Zeichen.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Ergebnis Statusmeldung, "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SendFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet eine Datei an ein angeschlossenes externes Bluetooth Ger?t.{\line}Zuerst mu? Initialisierung erfolgen, dann Setzen des Ger?tes.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Die zu sendende Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Ergebnis Statusmeldung, "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Service \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den aktuellen Bluetooth Dienst (Erweitertes Feature).}\par
\f0\pard\sb300\shading2000{\fs36\b LDCall}\par
\f0\pard{\fs20 (Rekursiver) Aufruf von Funktionen (Subs auch als Variablen) mit 1-5 optionalen Argumenten, mit/ohne R?ckgabewert(e), bzw. asynchron von einer beliebigen Extension oder vorkompilierten SB Exe.{\line}s. LDCall.Function f?r weitere Infos.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDCall.sb, LDCallAsync.sb{\line}{\line}args = ""{\line}a = 3{\line}b = 4{\line}sum = LDCall.Function2("Addition", a,b){\line}{\line}Sub Addition{\line}  return = args[1] + args[2]{\line}EndSub}\par

\f0\pard\sb180\shading1000{\fs30\b CallAsync(dll,extension,obj,method,arguments) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Asynchroner Aufruf einer Extension Methode oder Programm Sub.{\line}Sind 'dll', 'extension', 'obj' und 'arguments' alle "", dann kann 'method' eine Sub im SB Programm sein.}\par
\f0\pard\sb75{\fs24\b dll}\par
\f0\pard{\fs20 Die Extension Dll (zB. "LitDev.dll" oder "SmallBasicLibrary.dll") oder "".}\par
\f0\pard\sb75{\fs24\b extension}\par
\f0\pard{\fs20 Der Namespace der Extension (gew?hnlich wie Dll Name, zB. "LitDev" oder "Microsoft.SmallBasic.Library" in SmallBasicLibrary.dll) oder "".}\par
\f0\pard\sb75{\fs24\b obj}\par
\f0\pard{\fs20 Der Name des Extension Objekts (zB. "LDCall") oder "".}\par
\f0\pard\sb75{\fs24\b method}\par
\f0\pard{\fs20 Der Name der Extension Methode (zB. "Function") oder Name einer Sub im Programm (s.o., LDCall.Include).}\par
\f0\pard\sb75{\fs24\b arguments}\par
\f0\pard{\fs20 Ein Array mit Argumenten zur ?bergabe oder "" f?r ohne. Ein einzelnes Argument mu? nicht als Array ?bergeben werden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "PENDING" bei Erfolg, sonst eine Fehlermeldung.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDCallAsync.sb}\par
\f0\pard\sb180\shading1000{\fs30\b CallComplete \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn der Aufruf einer asynchronen Methoden-Sub beendet ist.}\par
\f0\pard\sb180\shading1000{\fs30\b CallInclude(include,method) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufruf einer Methode in einer eingebundenen vorkompilierten Assembly (s. LDCall.Include).{\line}Zur Argument?bergabe globale Variablennamen (R?ckgabewerte) in beiden Programmen verwenden.}\par
\f0\pard\sb75{\fs24\b include}\par
\f0\pard{\fs20 Der Name der eingebundenen Assembly (R?ckgabewert von 'Include' Methode, Intern: Include#).}\par
\f0\pard\sb75{\fs24\b method}\par
\f0\pard{\fs20 Der Name der aufzurufenden Sub Methode (in der eingebundenen Exe) in "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Compile(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kompiliert eine angegebene SB Quelldatei in ihrem Elternordner (incl. Kontrolle auf Existenz und ?nderungszeit der .exe).{\line}Voraussetzung ist, da? SmallBasic im STANDARDPFAD f?r das aktuelle Betriebssystem installiert ist.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der volle Pfad f?r die zu kompilierende SB Quelldatei (.sb).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Pfad der kompilierten Programmdatei (.exe) bei Erfolg, sonst "" (zB. .exe ?nderungszeit >1 sec).}\par
\f0\pard\sb180\shading1000{\fs30\b Function(funcName,arg1) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufruf einer SB Sub als Funktion mit 1 ?bergabeargument, oder Sub als Variablenname.{\line}Alle Variablen (R?ckgabewerte) bleiben global. Eingabeargument(e) wird(en) in Array 'args' kopiert.{\line}Ein (optionales) Ergebnis wird innerhalb der Sub in Variable (od. Array) 'return' ?bergeben.{\line}Die Variable (Array) 'args' mu? bei Programmstart mit "" belegt werden.{\line}Eingabeparameter bleibt(en) unver?ndert, w?hrend 'args' und 'return' nach R?ckgabe auf "" gesetzt werden.{\line}Achtung: NICHT schachteln (2. LDCall aus LDCall-Sub), wegen ?berkreuzender R?ckgabewerte.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 Der Name der aufzurufenden SB Sub in "" (auch als Variable).}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 Der Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Ergebnis der Funktion wird als optionale Variable "return" oder Fehlermeldung zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Aufruf der Subs Func1 bis Func3:{\line}For n = 1 to 3{\line}  LDCall.Function("Func"+n, ""){\line}EndFor{\line}{\line}Sub Func1{\line}  ...{\line}EndSub{\line}{\line}Sub fUNC2{\line}  ...{\line}EndSub{\line}'usw.}\par
\f0\pard\sb180\shading1000{\fs30\b Function2(funcName,arg1,arg2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufruf einer SB Sub als Funktion mit 2 Argumenten zur ?bergabe.{\line}s. LDCall.Function f?r weitere Infos.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 Der Name der aufzurufenden SB Sub in "".}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 1. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg2}\par
\f0\pard{\fs20 2. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Ergebnis der Funktion wird als Variable "return" oder Fehlermeldung zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDCall.sb{\line}{\line}'Wert von 1D R?ckgabearray{\line}args = ""{\line}arr = LDUtilities.ColourList(){\line}val = LDCall.Function2("Val1D", arr,i){\line}'Einzelfarbe arr[i]{\line}{\line}Sub Val1D{\line}  return = args[1][args[2]]{\line}EndSub}\par
\f0\pard\sb180\shading1000{\fs30\b Function3(funcName,arg1,arg2,arg3) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufruf einer SB Sub als Funktion mit 3 Argumenten zur ?bergabe.{\line}s. LDCall.Function f?r weitere Infos.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 Der Name der aufzurufenden SB Sub in "".}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 1. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg2}\par
\f0\pard{\fs20 2. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg3}\par
\f0\pard{\fs20 3. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Ergebnis der Funktion wird als Variable "return" oder Fehlermeldung zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDCall.sb{\line}{\line}'Wert von 2D R?ckgabearray{\line}args = ""{\line}arr = LDFile.ReadCSV(csv){\line}val = LDCall.Function3("Val2D", arr,y,x){\line}'Zellenwert in Zeile y, Spalte x{\line}{\line}Sub Val2D{\line}  return = args[1][args[2]][args[3]]{\line}EndSub}\par
\f0\pard\sb180\shading1000{\fs30\b Function4(funcName,arg1,arg2,arg3,arg4) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufruf einer SB Sub als Funktion mit 4 Argumenten zur ?bergabe.{\line}s. LDCall.Function f?r weitere Infos.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 Der Name der aufzurufenden SB Sub in "".}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 1. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg2}\par
\f0\pard{\fs20 2. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg3}\par
\f0\pard{\fs20 3. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg4}\par
\f0\pard{\fs20 4. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Ergebnis der Funktion wird als Variable "return" oder Fehlermeldung zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDCall.sb}\par
\f0\pard\sb180\shading1000{\fs30\b Function5(funcName,arg1,arg2,arg3,arg4,arg5) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufruf einer SB Sub als Funktion mit 5 Argumenten zur ?bergabe.{\line}s. LDCall.Function f?r weitere Infos.}\par
\f0\pard\sb75{\fs24\b funcName}\par
\f0\pard{\fs20 Der Name der aufzurufenden SB Sub in "".}\par
\f0\pard\sb75{\fs24\b arg1}\par
\f0\pard{\fs20 1. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg2}\par
\f0\pard{\fs20 2. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg3}\par
\f0\pard{\fs20 3. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg4}\par
\f0\pard{\fs20 4. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b arg5}\par
\f0\pard{\fs20 5. Eingabewert (oder Array).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Ergebnis der Funktion wird als Variable "return" oder Fehlermeldung zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDCall.sb}\par
\f0\pard\sb180\shading1000{\fs30\b Include(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?dt/Referenziert ein anderes, zuvor kompiliertes SB Programm(.exe) zur Verwendung einer darin enthaltenden Sub(routine) Methode (Intern: Include#).{\line}Zum Methodenaufruf s. CallInclude.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der volle Pfad der untergeordneten, kompilierten SBAnwendung(.exe) zur Verwendung als Assembly.{\line}Dateierweiterung .exe kann beliebig umbenannt sein (zB. dll, sbsub, incl).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der eingebundenen Assembly bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Test 'IsSBExe' (_SmallBasicProgram Typ):{\line}incl = LDCall.Include(pfad){\line}bIsSBExe = LDLogic.NE(incl,"") 'True|False}\par
\f0\pard\sb180\shading1000{\fs30\b LastCall \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name des letzen asynchronen Aufrufs (als "Namespace.Objekt.Methode(arg)" bei Methode, sonst "SubName()").}\par
\f0\pard\sb180\shading1000{\fs30\b LastResult \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den R?ckgabewert des letzten asynchronen Aufrufs, sonst "".}\par
\f0\pard\sb300\shading2000{\fs36\b LDChart}\par
\f0\pard{\fs20 Methoden zur Darstellung von Daten als Kreis-/Tortendiagramm, Zeilen oder Histogramm.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDChart.sb{\line}http://blogs.msdn.microsoft.com/smallbasic/2014/11/15/small-basic-chart-extension/}\par

\f0\pard\sb180\shading1000{\fs30\b AddChart(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Kreisdiagramm im GraphicsWindow hinzu (Intern: Control#).{\line}Aktuelle GraphicsWindow.BackgroundColor wird f?r den Hintergrund verwendet.{\line}Aktuelle GraphicsWindow.PenColor und -.Font.. Eigenschaften werden f?r die Textbezeichnung verwendet, zB:{\line}GraphicsWindow.FontName = "Segoe UI"{\line}GraphicsWindow.FontBold = "False"}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des Chart Steuerelements.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Chart Steuerelements.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Chart Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b ColourMap(chartName,hue,saturation,lightness,hsl,start,end,centralColour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Farbgebung f?r ein Kreisdiagramm.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 Der Name der Chart.}\par
\f0\pard\sb75{\fs24\b hue}\par
\f0\pard{\fs20 Der Farbton (0 bis 360 [Grad], Standard: 0 f?r Rot).}\par
\f0\pard\sb75{\fs24\b saturation}\par
\f0\pard{\fs20 Die Farbs?ttigung (Intensit?t 0 bis 1, Standard: 0.5).}\par
\f0\pard\sb75{\fs24\b lightness}\par
\f0\pard{\fs20 Die rel. Helligkeit (0 bis 1, Standard: 0.5).}\par
\f0\pard\sb75{\fs24\b hsl}\par
\f0\pard{\fs20 Der Parameter f?r Farbabstufung der verschiedenen Segmente:{\line}"Hue"	(Standard) Regenbogenfarben{\line}"Saturation" steigende Farbintensit?t{\line}"Lightness"	steigende Helligkeit}\par
\f0\pard\sb75{\fs24\b start}\par
\f0\pard{\fs20 Der Startwert f?r Farbvariation im Bereich [0,1] (Standard: 0).}\par
\f0\pard\sb75{\fs24\b end}\par
\f0\pard{\fs20 Der Endwert f?r Farbvariation im Bereich [0,1] (Standard: 1).}\par
\f0\pard\sb75{\fs24\b centralColour}\par
\f0\pard{\fs20 Die Farbe f?r optionalen kreisf?rmigen Farbgradient zentriert auf der Chart (Standard: "").}\par
\f0\pard\sb180\shading1000{\fs30\b DoughnutFraction \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den radialen Faktor f?r Sektorausschub beim 'Doughnut'-Chart Stil (Standard: 0.7).}\par
\f0\pard\sb180\shading1000{\fs30\b Highlight(chartName,label,fraction) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hebt ein Diagrammelement hervor (Sektor wird ausger?ckt).}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 Der Name des Charts.}\par
\f0\pard\sb75{\fs24\b label}\par
\f0\pard{\fs20 Die Beschriftung f?r das Segment.}\par
\f0\pard\sb75{\fs24\b fraction}\par
\f0\pard{\fs20 Radialer Faktor f?r Sektorausschub des ausger?ckten Elementes (0 f?r zur?cksetzen).}\par
\f0\pard\sb180\shading1000{\fs30\b HighlightDuration \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Animationsdauer [ms] f?r die Hervorhebung/Ausr?ckung (Standard: 100).}\par
\f0\pard\sb180\shading1000{\fs30\b LastChart \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name des zuletzt geklickten Chart Steuerelements.}\par
\f0\pard\sb180\shading1000{\fs30\b LastLabel \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Beschriftung des zuletzt geklickten Chartsegments.}\par
\f0\pard\sb180\shading1000{\fs30\b Legend(chartName,scale,legend,background) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Eigenschaften f?r die Legende zu den Sektoren.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 Der Name der Chart.}\par
\f0\pard\sb75{\fs24\b scale}\par
\f0\pard{\fs20 Der Skalierungsfaktor f?r Legende und Textbezeichnungen (Standard: 1).}\par
\f0\pard\sb75{\fs24\b legend}\par
\f0\pard{\fs20 Der Stil der Legende:{\line}"None"		Ohne Legende{\line}"Legend"	Eigenst?ndige Legende{\line}"Overlay"	Name ?berlagert Sektor{\line}"Percent"	Prozentsatz ?berlagert Sektor{\line}"Legend_Percent" (Standard) Separate Legende UND Prozentsatz ?berlagert Sektor.}\par
\f0\pard\sb75{\fs24\b background}\par
\f0\pard{\fs20 Farbiger Texthintergrund f?r Legende Beschriftung?  "True" oder "False" (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b Properties(chartName,style,scale) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Eigenschaften f?r ein Kreisdiagramm.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 Der Name der Chart.}\par
\f0\pard\sb75{\fs24\b style}\par
\f0\pard{\fs20 Der Chartstil:{\line}"Pie"	      Kreis (Standard){\line}"Doughnut"  Ring{\line}"Bubble"      Einzelkreise{\line}"Bar"	      Zeilen{\line}"Column"     Histogramm}\par
\f0\pard\sb75{\fs24\b scale}\par
\f0\pard{\fs20 Der Skalierungsfaktor f?r die Chart (Standard: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b SetData(chartName,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Daten f?r ein Kreisdiagramm.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 Der Name der Chart.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die zu setzenden Daten als 1D Array, indexiert durch die Elementnamen, zB.{\line}data["Fred"] = 25{\line}data["Mary"] = 15{\line}data["John"] = 40}\par
\f0\pard\sb180\shading1000{\fs30\b Update(chartName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Neuzeichnen (aktualisieren) eines Charts.{\line}Setzt alle hervorgehoben Segmente zur?ck oder betrifft alle ge?nderten Chart Eigenschaften.}\par
\f0\pard\sb75{\fs24\b chartName}\par
\f0\pard{\fs20 Der Name der Chart.}\par
\f0\pard\sb180\shading1000{\fs30\b ValueClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Anklicken eines Chartsegments.}\par
\f0\pard\sb300\shading2000{\fs36\b LDClient}\par
\f0\pard{\fs20 Server- und Klient Kommunikation zwischen Computern.{\line}F?r Server und Klient sind separate Programme erforderlich. Diese Klasse ist f?r den Klient (Intern: Client#). S.a. LDServer.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 client-server\\*.sb}\par

\f0\pard\sb180\shading1000{\fs30\b CheckServer(server) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Testet ob ein Server f?r eine Verbindung zur Verf?gung steht.{\line}Diese Methode nicht mit hoher Frequenz (> 1x/sec) aufrufen.}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 Die Server Verbindung als "IP:Port" (zB. "192.168.1.60:100").{\line}Dieser Wert wird von von LDServer.Start zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "AVAILABLE" oder "UNAVAILABLE".}\par
\f0\pard\sb180\shading1000{\fs30\b CloseDelay \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt eine Verz?gerung [ms] (Standard: 100) bei Trennung, um das Senden einer Nachricht zu erlauben, bevor die Verbindung getrennt wird (Disconnect).{\line}Diese Verz?gerung sollte auch f?r den Server (LDServer.CloseDelay) gesetzt werden.}\par
\f0\pard\sb180\shading1000{\fs30\b Connect(server,auto) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbindet zu einem Server.}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 Die Server Verbindung als "IP:Port" (zB. "192.168.1.60:100").{\line}Dieser Wert wird von 'LDServer.Start' zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b auto}\par
\f0\pard{\fs20 Automatiche Nachrichten?bergabe?  "True" oder "False".{\line}Bei (empfohlener) Verwendung werden alle Klientdaten via Server an alle anderen Klienten ?bergeben{\line}und es ist keine weitere Verarbeitung von Senden- und Empfangen Ereignissen erforderlich.{\line}Die Daten werden in Arrays (indexiert durch Klientname) aktualisiert, die von den 'Update..' Methoden zur?ckgegeben werden.{\line}Die 'auto' Option sollte f?r Server und alle Klienten gleich sein.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" oder "ALREADY_CONNECTED".}\par
\f0\pard\sb180\shading1000{\fs30\b Disconnect() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Trennt den Klient vom Server ab.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" oder "NOT_CONNECTED".}\par
\f0\pard\sb180\shading1000{\fs30\b Disconnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn der Server diesen Klient abtrennt.}\par
\f0\pard\sb180\shading1000{\fs30\b GetClients() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste aller aktuell verbundenen Klienten.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit aktuellen Klientnamen oder "" f?r 'keiner'.}\par
\f0\pard\sb180\shading1000{\fs30\b LastServerMessage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die letzte Server Nachricht.}\par
\f0\pard\sb180\shading1000{\fs30\b Name \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den eigenen Klientname.}\par
\f0\pard\sb180\shading1000{\fs30\b SendMessage(message) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet eine Nachricht an den Server.}\par
\f0\pard\sb75{\fs24\b message}\par
\f0\pard{\fs20 Die Nachricht. Kann eine beliebige Variable (auch Array) sein.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" oder "NOT_CONNECTED".}\par
\f0\pard\sb180\shading1000{\fs30\b ServerMessage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn der Server eine Nachricht an diesen Klient sendet.}\par
\f0\pard\sb180\shading1000{\fs30\b UpdateDynamic(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aktualisiert Klientdaten bei Verwendung der 'auto' Nachrichten?bergabe (LDClient.Connect).{\line}Verwendung f?r kleinere Anzahl von h?ufig wechselnden Daten (zB. Sprite Koordinaten).{\line}Diese Methode verwendet klientseitg zuletzt aktualisierte Daten und ist daf?r schnell.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die Daten dieses Klienten zur ?bergabe an andere Klienten.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array (indexiert durch Klientname) mit aktuellen Daten f?r jeden existierenden Klient.}\par
\f0\pard\sb180\shading1000{\fs30\b UpdateStatic(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aktualisiert Klientdaten bei Verwendung der 'auto' Nachrichten?bergabe.{\line}Verwendung f?r gr??ere Anzahl von selten wechselnden Daten (zB. Klient Konfiguration).{\line}Diese Methode verwendet serverseitig gespeicherte und abgerufene Daten.{\line}Kann langsamer als UpdateDynamic sein, da auf serverseitig abgerufene Daten gewartet wird,{\line}um sicherzustellen, da? alle Klientdaten voll synchronisiert werden.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die Daten dieses Klienten zur ?bergabe an andere Klienten.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array (indexiert durch Klientname) mit aktuellen Daten f?r jeden existierenden Klient.}\par
\f0\pard\sb300\shading2000{\fs36\b LDClipboard}\par
\f0\pard{\fs20 Methoden zur Verwendung der System Zwischenablage.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDClipboard.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Clear() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht den Inhalt der Zwischenablage. 'ClipboardChanged' Event wird immer ausgel?st.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ClipboardChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Status?nderung in der Zwischenablage.}\par
\f0\pard\sb180\shading1000{\fs30\b GetFileList() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle Pfade von Datei-/Ordnerobjekt(en) in der Zwischenablage als Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit Datei-/Ordnerpfad(en) oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetImage() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?dt ein Bild von der Zwischenablage in ImageList (Intern: ImageList#+1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen Bildes in ImageList oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetText() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Text aus der Zwischenablage.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Text aus der Zwischenablage oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ImageTransparency \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Verwendung eines erweiterten Bildformats f?r 'SetImage', welches Transparenz unterst?tzt?  "True" (Standard) oder "False".{\line}Dieses Bildformat wird ev. von manchen Anwendungen (zB. ClipboardViewer) beim Einf?gen nicht erkannt.{\line}Ist ev. vor Aufruf von LDClipboard.SetImage zu setzen.}\par
\f0\pard\sb180\shading1000{\fs30\b SetFileList(fileList) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt mittels einer Liste von Pfaden deren Datei-/Ordnerobjekt(e) in die Zwischenablage.}\par
\f0\pard\sb75{\fs24\b fileList}\par
\f0\pard{\fs20 Ein einzelner Pfad oder Array mit vollen Datei-/Ordnerpfaden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetImage(imageName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein ImageList Bild in die Zwischenablage (bzgl. Transparenz s. 'ImageTransparency').{\line}'ClipboardChanged' Event wird immer ausgel?st.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Der Name des ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetText(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen angegebenen Text in die Zwischenablage. 'ClipboardChanged' Event wird immer ausgel?st.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der in die Zwischenablage zu kopierende Text.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDColours}\par
\f0\pard{\fs20 Bietet Standard SB-Farben und farbbezogene Methoden.{\line}(LDColours.)Farbname steht f?r HexWert #(AA)RRGGBB einer SB-Farbe (bzw. #00FFFFFF f?r Transparent).{\line}Farbeingabe als (LDColours.)Farbname oder "#(AA)RRGGBB" (s. LDDialogs.Colour, LDUtilities.ColourList) f?r 141 CSS3 Farben (incl. Transparent).{\line}#RGB (=> #RRGGBB = #FFRRGGBB) f?r 216 Websichere Farben.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 3D-samples\\LD3DMazeGame.sb{\line}http://msdn.microsoft.com/library/System.Windows.Media.Colors.aspx{\line}http://i.msdn.microsoft.com/dynimg/IC24340.png{\line}http://de.wikipedia.org/wiki/Webfarbe}\par

\f0\pard\sb180\shading1000{\fs30\b AliceBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Eis-/Wei?blau{\line}#F0F8FF - RGB: 240,248,255 (HSL: 208,1,0.97)}\par
\f0\pard\sb180\shading1000{\fs30\b AntiqueWhite \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Antikwei?{\line}#FAEBD7 - RGB: 250,235,215 (HSL: 34.29,0.78,0.91)}\par
\f0\pard\sb180\shading1000{\fs30\b Aqua \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 T?rkis, HTML4 Farbe, Websafe{\line}#00FFFF - RGB: 0,255,255 (HSL: 180,1,0.5), s. Cyan, 11=Cyan in TW}\par
\f0\pard\sb180\shading1000{\fs30\b Aquamarine \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aquamarin{\line}#7FFFD4 - RGB: 127,255,212 (HSL: 159.84,1,0.75)}\par
\f0\pard\sb180\shading1000{\fs30\b Azure \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Azurblau{\line}#F0FFFF - RGB: 240,255,255 (HSL: 180,1,0.97)}\par
\f0\pard\sb180\shading1000{\fs30\b Beige \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Beige{\line}#F5F5DC - RGB: 245,245,220 (HSL: 60,0.56,0.91)}\par
\f0\pard\sb180\shading1000{\fs30\b Bisque \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Fischcreme{\line}#FFE4C4 - RGB: 255,228,196 (HSL: 32.54,1,0.88)}\par
\f0\pard\sb180\shading1000{\fs30\b Black \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schwarz, HTML4 Farbe, Websafe{\line}#000000 - RGB: 0,0,0 (HSL: 0,0,0), 0=Black in TW}\par
\f0\pard\sb180\shading1000{\fs30\b BlanchedAlmond \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mandel blanchiert{\line}#FFEBCD - RGB: 255,235,205 (HSL: 36,1,0.9)}\par
\f0\pard\sb180\shading1000{\fs30\b Blue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blau, HTML4 Farbe, Websafe{\line}#0000FF - RGB: 0,0,255 (HSL: 240,1,0.5), 9=Blue in TW}\par
\f0\pard\sb180\shading1000{\fs30\b BlueViolet \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blauviolett{\line}#8A2BE2 - RGB: 138,43,226 (HSL: 271.15,0.76,0.53)}\par
\f0\pard\sb180\shading1000{\fs30\b Brown \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Braun{\line}#A52A2A - RGB: 165,42,42 (HSL: 0,0.59,0.41)}\par
\f0\pard\sb180\shading1000{\fs30\b BurlyWood \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wurzelholz{\line}#DEB887 - RGB: 222,184,135 (HSL: 33.79,0.57,0.7)}\par
\f0\pard\sb180\shading1000{\fs30\b CadetBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kadettenblau{\line}#5F9EA0 - RGB: 95,158,160 (HSL: 181.85,0.25,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b Chartreuse \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blass Apfelgr?n{\line}#7FFF00 - RGB: 127,255,0 (HSL: 90.12,1,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b Chocolate \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schokolade{\line}#D2691E - RGB: 210,105,30 (HSL: 25,0.75,0.47)}\par
\f0\pard\sb180\shading1000{\fs30\b Coral \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Koralle{\line}#FF7F50 - RGB: 255,127,80 (HSL: 16.11,1,0.66)}\par
\f0\pard\sb180\shading1000{\fs30\b CornflowerBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kornblumenblau{\line}#6495ED - RGB: 100,149,237 (HSL: 218.54,0.79,0.66)}\par
\f0\pard\sb180\shading1000{\fs30\b Cornsilk \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Maisfaden{\line}#FFF8DC - RGB: 255,248,220 (HSL: 48,1,0.93)}\par
\f0\pard\sb180\shading1000{\fs30\b Crimson \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Karmesinrot{\line}#DC143C - RGB: 220,20,60 (HSL: 348,0.83,0.47)}\par
\f0\pard\sb180\shading1000{\fs30\b Cyan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Cyan, HTML4 Farbe, Websafe{\line}#00FFFF - RGB: 0,255,255 (HSL: 180,1,0.5), s. Aqua, 11=Cyan in TW}\par
\f0\pard\sb180\shading1000{\fs30\b DarkBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelblau{\line}#00008B - RGB: 0,0,139 (HSL: 240,1,0.27)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkCyan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelcyan{\line}#008B8B - RGB: 0,139,139 (HSL: 180,1,0.27)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkGoldenrod \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkel Goldrute{\line}#B8860B - RGB: 184,134,11 (HSL: 42.66,0.89,0.38)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkGray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelgrau (heller als Gray){\line}#A9A9A9 - RGB: 169,169,169 (HSL: 0,0,0.66)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelgr?n{\line}#006400 - RGB: 0,100,0 (HSL: 120,1,0.2)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkKhaki \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelkhaki{\line}#BDB76B - RGB: 189,183,107 (HSL: 55.61,0.38,0.58)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkMagenta \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelmagenta{\line}#8B008B - RGB: 139,0,139 (HSL: 300,1,0.27)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkOliveGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelolivgr?n{\line}#556B2F - RGB: 85,107,47 (HSL: 82,0.39,0.3)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkOrange \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelorange{\line}#FF8C00 - RGB: 255,140,0 (HSL: 32.94,1,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkOrchid \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelorchidee{\line}#9932CC - RGB: 153,50,204 (HSL: 280.13,0.61,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkRed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelrot{\line}#8B0000 - RGB: 139,0,0 (HSL: 0,1,0.27)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkSalmon \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkel Lachsrosa{\line}#E9967A - RGB: 233,150,122 (HSL: 15.14,0.72,0.7)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkSeaGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkel Meergr?n{\line}#8FBC8F - RGB: 143,188,143 (HSL: 120,0.25,0.65)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkSlateBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkel Schieferblau{\line}#483D8B - RGB: 72,61,139 (HSL: 248.46,0.39,0.39)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkSlateGray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkel Schiefergrau{\line}#2F4F4F - RGB: 47,79,79 (HSL: 180,0.25,0.25)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkTurquoise \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelt?rkis{\line}#00CED1 - RGB: 0,206,209 (HSL: 180.86,1,0.41)}\par
\f0\pard\sb180\shading1000{\fs30\b DarkViolet \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkelviolett{\line}#9400D3 - RGB: 148,0,211 (HSL: 282.09,1,0.41)}\par
\f0\pard\sb180\shading1000{\fs30\b DeepPink \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkel-/Tiefrosa{\line}#FF1493 - RGB: 255,20,147 (HSL: 327.57,1,0.54)}\par
\f0\pard\sb180\shading1000{\fs30\b DeepSkyBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Tiefhimmelblau{\line}#00BFFF - RGB: 0,191,255 (HSL: 195.06,1,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b DimGray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ged?mpftes Grau{\line}#696969 - RGB: 105,105,105 (HSL: 0,0,0.41)}\par
\f0\pard\sb180\shading1000{\fs30\b DodgerBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dodgerblau{\line}#1E90FF - RGB: 30,144,255 (HSL: 209.6,1,0.56)}\par
\f0\pard\sb180\shading1000{\fs30\b Firebrick \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ziegelrot{\line}#B22222 - RGB: 178,34,34 (HSL: 0,0.68,0.42)}\par
\f0\pard\sb180\shading1000{\fs30\b FloralWhite \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bl?tenwei?{\line}#FFFAF0 - RGB: 255,250,240 (HSL: 40,1,0.97)}\par
\f0\pard\sb180\shading1000{\fs30\b ForestGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Waldgr?n{\line}#228B22 - RGB: 34,139,34 (HSL: 120,0.61,0.34)}\par
\f0\pard\sb180\shading1000{\fs30\b Fuchsia \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Fuchsie, HTML4 Farbe, Websafe{\line}#FF00FF - RGB: 255,0,255 (HSL: 300,1,0.5), s. Magenta, 13=Magenta in TW}\par
\f0\pard\sb180\shading1000{\fs30\b Gainsboro \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blassgrau{\line}#DCDCDC - RGB: 220,220,220 (HSL: 0,0,0.86)}\par
\f0\pard\sb180\shading1000{\fs30\b GetBlue(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Blauanteil einer Farbe.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Farbe deren Blauanteil zu ermitteln ist, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Blauanteil (0 bis 255).}\par
\f0\pard\sb180\shading1000{\fs30\b GetGreen(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Gr?nanteil einer Farbe.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Farbe deren Gr?nanteil zu ermitteln ist, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Gr?nanteil (0 bis 255).}\par
\f0\pard\sb180\shading1000{\fs30\b GetHue(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Farbton (Hue) einer Farbe im HSL Farbraum (zB. "Transparent" ergibt 0).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Der Hex Farbwert, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Farbton [0,360] [Grad], wobei 0 = 360 = Red.}\par
\f0\pard\sb180\shading1000{\fs30\b GetLightness(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die relative Helligkeit (Lightness) einer Farbe im HSL Farbraum (zB. "Transparent" ergibt 1).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Der Hex Farbwert, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die rel. Helligkeit [0,1] [%/100], wobei 0=Black, 1=White, mit L = (Max(R,G,B) + Min(R,G,B))/2/255.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Hellwert (Value) im HSV Farbraum: V = Max(R,G,B)/255 = 2*L - Min(R,G,B)/255 [0,1].}\par
\f0\pard\sb180\shading1000{\fs30\b GetOpacity(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Deckkraft (Alphawert) einer Farbe (zB. "Transparent" ergibt 0).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Farbe deren Deckkraft zu ermitteln ist, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Deckkraft der Farbe (0 bis 255). 0 ist v?llig transparent (#00) und 255 ist v?llig deckend (#FF).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Farbdeckkraft [%] = GetOpacity * 100/255}\par
\f0\pard\sb180\shading1000{\fs30\b GetRed(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Rotanteil einer Farbe.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Farbe deren Rotanteil zu ermitteln ist, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Rotanteil (0 bis 255).}\par
\f0\pard\sb180\shading1000{\fs30\b GetSaturation(colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die S?ttigung (Saturation) einer Farbe im HSL Farbraum (zB. "Transparent" ergibt 0).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Der Hex Farbwert, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Farbs?ttigung [0,1] [%/100], wobei 0=Gray, 1=hell.}\par
\f0\pard\sb180\shading1000{\fs30\b GhostWhite \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Phantomwei?{\line}#F8F8FF - RGB: 248,248,255 (HSL: 240,1,0.99)}\par
\f0\pard\sb180\shading1000{\fs30\b Gold \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gold{\line}#FFD700 - RGB: 255,215,0 (HSL: 50.59,1,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b Goldenrod \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Goldrute{\line}#DAA520 - RGB: 218,165,32 (HSL: 42.9,0.74,0.49)}\par
\f0\pard\sb180\shading1000{\fs30\b Gray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Grau, HTML4 Farbe{\line}#808080 - RGB: 128,128,128 (HSL: 0,0,0.5), 8=DarkGray in TW}\par
\f0\pard\sb180\shading1000{\fs30\b Green \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gr?n, HTML4 Farbe{\line}#008000 - RGB: 0,128,0 (HSL: 120,1,0.25), 2=DarkGreen in TW}\par
\f0\pard\sb180\shading1000{\fs30\b GreenYellow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gr?ngelb{\line}#ADFF2F - RGB: 173,255,47 (HSL: 83.65,1,0.59)}\par
\f0\pard\sb180\shading1000{\fs30\b Honeydew \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Honigtau{\line}#F0FFF0 - RGB: 240,255,240 (HSL: 120,1,0.97)}\par
\f0\pard\sb180\shading1000{\fs30\b HotPink \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Warmrosa{\line}#FF69B4 - RGB: 255,105,180 (HSL: 330,1,0.71)}\par
\f0\pard\sb180\shading1000{\fs30\b HSLtoRGB(H,S,L) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert HSL Farbwerte aus Farbton, S?ttigung, relative Helligkeit (Hue, Saturation, Lightness = HSL) zu ?blichen Rot, Gr?n, Blau Werten (RGB), wie in SB verwendet.}\par
\f0\pard\sb75{\fs24\b H}\par
\f0\pard{\fs20 Farbton / Hue (0 bis 360 [Grad], mit 0 = 360 = Red). Automatisch begrenzt auf [0,360].}\par
\f0\pard\sb75{\fs24\b S}\par
\f0\pard{\fs20 S?ttigung / Saturation (0 bis 1, Gray bis satt). Automatisch begrenzt auf [0,1].}\par
\f0\pard\sb75{\fs24\b L}\par
\f0\pard{\fs20 Rel. Helligkeit / Lightness (0 bis 1, Black bis White). Automatisch begrenzt auf [0,1].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die RGB Farbe als #RRGGBB HexWert.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/HSV-Farbraum}\par
\f0\pard\sb180\shading1000{\fs30\b IndianRed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Indischrot{\line}#CD5C5C - RGB: 205,92,92 (HSL: 0,0.53,0.58)}\par
\f0\pard\sb180\shading1000{\fs30\b Indigo \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Indigoblau{\line}#4B0082 - RGB: 75,0,130 (HSL: 274.62,1,0.25)}\par
\f0\pard\sb180\shading1000{\fs30\b Ivory \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Elfenbein{\line}#FFFFF0 - RGB: 255,255,240 (HSL: 60,1,0.97)}\par
\f0\pard\sb180\shading1000{\fs30\b Khaki \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Khaki{\line}#F0E68C - RGB: 240,230,140 (HSL: 54,0.77,0.75)}\par
\f0\pard\sb180\shading1000{\fs30\b Lavender \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Lavendel{\line}#E6E6FA - RGB: 230,230,250 (HSL: 240,0.67,0.94)}\par
\f0\pard\sb180\shading1000{\fs30\b LavenderBlush \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Lavendelblut{\line}#FFF0F5 - RGB: 255,240,245 (HSL: 340,1,0.97)}\par
\f0\pard\sb180\shading1000{\fs30\b LawnGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rasengr?n{\line}#7CFC00 - RGB: 124,252,0 (HSL: 90.48,1,0.49)}\par
\f0\pard\sb180\shading1000{\fs30\b LemonChiffon \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zitronenchiffon{\line}#FFFACD - RGB: 255,250,205 (HSL: 54,1,0.9)}\par
\f0\pard\sb180\shading1000{\fs30\b LightBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hellblau{\line}#ADD8E6 - RGB: 173,216,230 (HSL: 194.74,0.53,0.79)}\par
\f0\pard\sb180\shading1000{\fs30\b LightCoral \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hellkoralle{\line}#F08080 - RGB: 240,128,128 (HSL: 0,0.79,0.72)}\par
\f0\pard\sb180\shading1000{\fs30\b LightCyan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hellcyan{\line}#E0FFFF - RGB: 224,255,255 (HSL: 180,1,0.94)}\par
\f0\pard\sb180\shading1000{\fs30\b LightGoldenrodYellow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hell Goldrutengelb{\line}#FAFAD2 - RGB: 250,250,210 (HSL: 60,0.8,0.9)}\par
\f0\pard\sb180\shading1000{\fs30\b LightGray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hellgrau{\line}#D3D3D3 - RGB: 211,211,211 (HSL: 0,0,0.83)}\par
\f0\pard\sb180\shading1000{\fs30\b LightGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hellgr?n{\line}#90EE90 - RGB: 144,238,144 (HSL: 120,0.73,0.75)}\par
\f0\pard\sb180\shading1000{\fs30\b LightPink \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hellrosa (dunkler als Pink){\line}#FFB6C1 - RGB: 255,182,193 (HSL: 350.96,1,0.86)}\par
\f0\pard\sb180\shading1000{\fs30\b LightSalmon \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hell Lachs{\line}#FFA07A - RGB: 255,160,122 (HSL: 17.14,1,0.74)}\par
\f0\pard\sb180\shading1000{\fs30\b LightSeaGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hell Meergr?n{\line}#20B2AA - RGB: 32,178,170 (HSL: 176.71,0.7,0.41)}\par
\f0\pard\sb180\shading1000{\fs30\b LightSkyBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hell Himmelblau{\line}#87CEFA - RGB: 135,206,250 (HSL: 202.96,0.92,0.75)}\par
\f0\pard\sb180\shading1000{\fs30\b LightSlateGray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hell Schiefergrau{\line}#778899 - RGB: 119,136,153 (HSL: 210,0.14,0.53)}\par
\f0\pard\sb180\shading1000{\fs30\b LightSteelBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hell Stahlblau{\line}#B0C4DE - RGB: 176,196,222 (HSL: 213.91,0.41,0.78)}\par
\f0\pard\sb180\shading1000{\fs30\b LightYellow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hellgelb{\line}#FFFFE0 - RGB: 255,255,224 (HSL: 60,1,0.94)}\par
\f0\pard\sb180\shading1000{\fs30\b Lime \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Limette, HTML4 Farbe, Websafe{\line}#00FF00 - RGB: 0,255,0 (HSL: 120,1,0.5), 10=Green in TW}\par
\f0\pard\sb180\shading1000{\fs30\b LimeGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Limettengr?n{\line}#32CD32 - RGB: 50,205,50 (HSL: 120,0.61,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b Linen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Leinen{\line}#FAF0E6 - RGB: 250,240,230 (HSL: 30,0.67,0.94)}\par
\f0\pard\sb180\shading1000{\fs30\b Magenta \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Magenta, HTML4 Farbe, Websafe{\line}#FF00FF - RGB: 255,0,255 (HSL: 300,1,0.5), s. Fuchsia, 13=Magenta in TW}\par
\f0\pard\sb180\shading1000{\fs30\b Maroon \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kastanienbraun, HTML4 Farbe{\line}#800000 - RGB: 128,0,0 (HSL: 0,1,0.25), 4=DarkRed in TW}\par
\f0\pard\sb180\shading1000{\fs30\b MediumAquamarine \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittel Aquamarin{\line}#66CDAA - RGB: 102,205,170 (HSL: 159.61,0.51,0.6)}\par
\f0\pard\sb180\shading1000{\fs30\b MediumBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittelblau{\line}#0000CD - RGB: 0,0,205 (HSL: 240,1,0.4)}\par
\f0\pard\sb180\shading1000{\fs30\b MediumOrchid \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittel Orchidee{\line}#BA55D3 - RGB: 186,85,211 (HSL: 288.1,0.59,0.58)}\par
\f0\pard\sb180\shading1000{\fs30\b MediumPurple \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittel Purpurrot/Lila{\line}#9370DB - RGB: 147,112,219 (HSL: 259.63,0.6,0.65)}\par
\f0\pard\sb180\shading1000{\fs30\b MediumSeaGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittel Meergr?n{\line}#3CB371 - RGB: 60,179,113 (HSL: 146.72,0.5,0.47)}\par
\f0\pard\sb180\shading1000{\fs30\b MediumSlateBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittel Schieferblau{\line}#7B68EE - RGB: 123,104,238 (HSL: 248.51,0.8,0.67)}\par
\f0\pard\sb180\shading1000{\fs30\b MediumSpringGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittel Fr?hlingsgr?n{\line}#00FA9A - RGB: 0,250,154 (HSL: 156.96,1,0.49)}\par
\f0\pard\sb180\shading1000{\fs30\b MediumTurquoise \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittelt?rkis{\line}#48D1CC - RGB: 72,209,204 (HSL: 177.81,0.6,0.55)}\par
\f0\pard\sb180\shading1000{\fs30\b MediumVioletRed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mittel Violettrot{\line}#C71585 - RGB: 199,21,133 (HSL: 322.25,0.81,0.43)}\par
\f0\pard\sb180\shading1000{\fs30\b MidnightBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mitternachtsblau{\line}#191970 - RGB: 25,25,112 (HSL: 240,0.64,0.27)}\par
\f0\pard\sb180\shading1000{\fs30\b MintCream \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Minzcreme{\line}#F5FFFA - RGB: 245,255,250 (HSL: 150,1,0.98)}\par
\f0\pard\sb180\shading1000{\fs30\b MistyRose \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Nebelrose{\line}#FFE4E1 - RGB: 255,228,225 (HSL: 6,1,0.94)}\par
\f0\pard\sb180\shading1000{\fs30\b Moccasin \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Mokassin{\line}#FFE4B5 - RGB: 255,228,181 (HSL: 38.11,1,0.85)}\par
\f0\pard\sb180\shading1000{\fs30\b NavajoWhite \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Navajowei?{\line}#FFDEAD - RGB: 255,222,173 (HSL: 35.85,1,0.84)}\par
\f0\pard\sb180\shading1000{\fs30\b Navy \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Marineblau, HTML4 Farbe{\line}#000080 - RGB: 0,0,128 (HSL: 240,1,0.25), 1=DarkBlue in TW}\par
\f0\pard\sb180\shading1000{\fs30\b OldLace \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Alte Spitze{\line}#FDF5E6 - RGB: 253,245,230 (HSL: 39.13,0.85,0.95)}\par
\f0\pard\sb180\shading1000{\fs30\b Olive \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Oliv, HTML4 Farbe{\line}#808000 - RGB: 128,128,0 (HSL: 60,1,0.25), 6=DarkYellow in TW}\par
\f0\pard\sb180\shading1000{\fs30\b OliveDrab \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Olivgr?n, Braunoliv{\line}#6B8E23 - RGB: 107,142,35 (HSL: 79.63,0.6,0.35)}\par
\f0\pard\sb180\shading1000{\fs30\b Orange \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Orange{\line}#FFA500 - RGB: 255,165,0 (HSL: 38.82,1,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b OrangeRed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Orchidee{\line}		}\par
\f0\pard\sb180\shading1000{\fs30\b Orchid \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Orchidee{\line}#DA70D6 - RGB: 218,112,214 (HSL: 302.26,0.59,0.65)}\par
\f0\pard\sb180\shading1000{\fs30\b PaleGoldenrod \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blass Goldrute{\line}#EEE8AA - RGB: 238,232,170 (HSL: 54.71,0.67,0.8)}\par
\f0\pard\sb180\shading1000{\fs30\b PaleGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blassgr?n{\line}#98FB98 - RGB: 152,251,152 (HSL: 120,0.93,0.79)}\par
\f0\pard\sb180\shading1000{\fs30\b PaleTurquoise \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blasst?rkis{\line}#AFEEEE - RGB: 175,238,238 (HSL: 180,0.65,0.81)}\par
\f0\pard\sb180\shading1000{\fs30\b PaleVioletRed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blass Violettrot{\line}#DB7093 - RGB: 219,112,147 (HSL: 340.37,0.6,0.65)}\par
\f0\pard\sb180\shading1000{\fs30\b PapayaWhip \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Papaya Sahne{\line}#FFEFD5 - RGB: 255,239,213 (HSL: 37.14,1,0.92)}\par
\f0\pard\sb180\shading1000{\fs30\b PeachPuff \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pfirsichhauch{\line}#FFDAB9 - RGB: 255,218,185 (HSL: 28.29,1,0.86)}\par
\f0\pard\sb180\shading1000{\fs30\b Peru \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dunkles Sandbraun{\line}#CD853F - RGB: 205,133,63 (HSL: 29.58,0.59,0.53)}\par
\f0\pard\sb180\shading1000{\fs30\b Pink \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rosa{\line}#FFC0CB - RGB: 255,192,203 (HSL: 349.52,1,0.88)}\par
\f0\pard\sb180\shading1000{\fs30\b Plum \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pflaumenblau{\line}#DDA0DD - RGB: 221,160,221 (HSL: 300,0.47,0.75)}\par
\f0\pard\sb180\shading1000{\fs30\b PowderBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pulverblau{\line}#B0E0E6 - RGB: 176,224,230 (HSL: 186.67,0.52,0.8)}\par
\f0\pard\sb180\shading1000{\fs30\b Purple \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Purpurrot, Lila, HTML4 Farbe{\line}#800080 - RGB: 128,0,128 (HSL: 300,1,0.25), 5=DarkMagenta in TW}\par
\f0\pard\sb180\shading1000{\fs30\b Red \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rot, HTML4 Farbe, Websafe{\line}#FF0000 - RGB: 255,0,0 (HSL: 0,1,0.5), 12=Red in TW}\par
\f0\pard\sb180\shading1000{\fs30\b RosyBrown \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rosigbraun{\line}#BC8F8F - RGB: 188,143,143 (HSL: 0,0.25,0.65)}\par
\f0\pard\sb180\shading1000{\fs30\b RoyalBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 K?nigsblau{\line}#4169E1 - RGB: 65,105,225 (HSL: 225,0.73,0.57)}\par
\f0\pard\sb180\shading1000{\fs30\b SaddleBrown \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sattelbraun{\line}#8B4513 - RGB: 139,69,19 (HSL: 25,0.76,0.31)}\par
\f0\pard\sb180\shading1000{\fs30\b Salmon \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Lachsrosa{\line}#FA8072 - RGB: 250,128,114 (HSL: 6.18,0.93,0.71)}\par
\f0\pard\sb180\shading1000{\fs30\b SandyBrown \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sandbraun{\line}#F4A460 - RGB: 244,164,96 (HSL: 27.57,0.87,0.67)}\par
\f0\pard\sb180\shading1000{\fs30\b SeaGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Meergr?n{\line}#2E8B57 - RGB: 46,139,87 (HSL: 146.45,0.5,0.36)}\par
\f0\pard\sb180\shading1000{\fs30\b SeaShell \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Muschelschale{\line}#FFF5EE - RGB: 255,245,238 (HSL: 24.71,1,0.97)}\par
\f0\pard\sb180\shading1000{\fs30\b SetOpacity(colour,opacity) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Deckkraft (Alphawert) einer Farbe, zB. Konvertierung von (LDColours.)Farbname zu #AARRGGBB.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die zu ?ndernde Farbe, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb75{\fs24\b opacity}\par
\f0\pard{\fs20 Deckkraft (0 bis 255). 0 ist v?llig transparent (#00) und 255 ist v?llig deckend (#FF).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ge?nderte Farbe als #AARRGGBB HexWert.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Farbdeckkraft [%] = opacity * 100/255}\par
\f0\pard\sb180\shading1000{\fs30\b Sienna \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ockergelb{\line}#A0522D - RGB: 160,82,45 (HSL: 19.3,0.56,0.4)}\par
\f0\pard\sb180\shading1000{\fs30\b Silver \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Silber, HTML4 Farbe{\line}#C0C0C0 - RGB: 192,192,192 (HSL: 0,0,0.75), 7=Gray in TW}\par
\f0\pard\sb180\shading1000{\fs30\b SkyBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Himmelblau{\line}#87CEEB - RGB: 135,206,235 (HSL: 197.4,0.71,0.73)}\par
\f0\pard\sb180\shading1000{\fs30\b SlateBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schieferblau{\line}#6A5ACD - RGB: 106,90,205 (HSL: 248.35,0.53,0.58)}\par
\f0\pard\sb180\shading1000{\fs30\b SlateGray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schiefergrau{\line}#708090 - RGB: 112,128,144 (HSL: 210,0.13,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b Snow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schneewei?{\line}#FFFAFA - RGB: 255,250,250 (HSL: 0,1,0.99)}\par
\f0\pard\sb180\shading1000{\fs30\b SpringGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Fr?hlingsgr?n{\line}#00FF7F - RGB: 0,255,127 (HSL: 149.88,1,0.5)}\par
\f0\pard\sb180\shading1000{\fs30\b SteelBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stahlblau{\line}#4682B4 - RGB: 70,130,180 (HSL: 207.27,0.44,0.49)}\par
\f0\pard\sb180\shading1000{\fs30\b Tan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hellbraun{\line}#D2B48C - RGB: 210,180,140 (HSL: 34.29,0.44,0.69)}\par
\f0\pard\sb180\shading1000{\fs30\b Teal \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blaugr?n, HTML4 Farbe{\line}#008080 - RGB: 0,128,128 (HSL: 180,1,0.25), 3=DarkCyan in TW}\par
\f0\pard\sb180\shading1000{\fs30\b Thistle \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Distel{\line}#D8BFD8 - RGB: 216,191,216 (HSL: 300,0.24,0.8)}\par
\f0\pard\sb180\shading1000{\fs30\b Tomato \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Tomate{\line}#FF6347 - RGB: 255,99,71 (HSL: 9.13,1,0.64)}\par
\f0\pard\sb180\shading1000{\fs30\b Transparent \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Transparentes 'White'{\line}#00FFFFFF - ARGB: 0,255,255,255 (HSL: 0,0,1)}\par
\f0\pard\sb180\shading1000{\fs30\b Turquoise \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 T?rkis{\line}#40E0D0 - RGB: 64,224,208 (HSL: 174,0.72,0.56)}\par
\f0\pard\sb180\shading1000{\fs30\b Violet \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Violett{\line}#EE82EE - RGB: 238,130,238 (HSL: 300,0.76,0.72)}\par
\f0\pard\sb180\shading1000{\fs30\b Wheat \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Weizen{\line}#F5DEB3 - RGB: 245,222,179 (HSL: 39.09,0.77,0.83)}\par
\f0\pard\sb180\shading1000{\fs30\b White \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wei?, HTML4 Farbe{\line}#FFFFFF - RGB: 255,255,255 (HSL: 0,0,1), 15=White in TW}\par
\f0\pard\sb180\shading1000{\fs30\b WhiteSmoke \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wei?er Rauch{\line}#F5F5F5 - RGB: 245,245,245 (HSL: 0,0,0.96)}\par
\f0\pard\sb180\shading1000{\fs30\b Yellow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gelb, HTML4 Farbe, Websafe{\line}#FFFF00 - RGB: 255,255,0 (HSL: 60,1,0.5), 14=Yellow in TW}\par
\f0\pard\sb180\shading1000{\fs30\b YellowGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gelbgr?n{\line}#9ACD32 - RGB: 154,205,50 (HSL: 79.74,0.61,0.5)}\par
\f0\pard\sb300\shading2000{\fs36\b LDCommPort}\par
\f0\pard{\fs20 Sendet und empf?ngt Daten ?ber einen seriellen Port.{\line}(Originalcode von Nino Carrillo)}\par

\f0\pard\sb180\shading1000{\fs30\b AvailablePorts() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Listet alle verf?gbaren seriellen Ports auf.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Namen aller verf?gbaren seriellen Ports oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b ClosePort() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schliesst den ge?ffneten seriellen Port.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataReceived \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn der serielle Port Daten empf?ngt.}\par
\f0\pard\sb180\shading1000{\fs30\b ErrorReceived \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn der serielle Port einen Fehler empf?ngt.}\par
\f0\pard\sb180\shading1000{\fs30\b LastError \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den letzten Fehler, f?r den ein Fehlerereignis ausgel?st wurde.}\par
\f0\pard\sb180\shading1000{\fs30\b LastPort \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den letzten Portname, f?r den ein Ereignis ausgel?st wurde.}\par
\f0\pard\sb180\shading1000{\fs30\b OpenPort(portName,baudRate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ffnet einen seriellen Port. Setzt 8 Datenbits voraus, keine Parit?t.}\par
\f0\pard\sb75{\fs24\b portName}\par
\f0\pard{\fs20 Der Identifikationsstring f?r den zu ?ffnenden Port als "COM#", zB. "COM3".}\par
\f0\pard\sb75{\fs24\b baudRate}\par
\f0\pard{\fs20 Die ganzzahlige Baud-Rate (zB. 9600).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOSERIALPORTS", "PORTNOTFOUND" oder "CONNECTIONFAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RXAll() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest alle vorhandenen Bytes aus dem Eingabepuffer des ge?ffneten Ports.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein String mit Bytes bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RXByte() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest ein Byte vom ge?ffneten seriellen Port und gibt dessen Wert als Ganzzahl zur?ck.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Ganzzahl (0 bis 255) bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RXChar() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest ein Byte vom ge?ffneten seriellen Port und gibt dessen Wert als Unicode Zeichen zur?ck.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das Unicode Zeichen bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetDataBits(dataBits) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Datenbits f?r den aktuellen Port. 5 bis 8 (Standard).}\par
\f0\pard\sb75{\fs24\b dataBits}\par
\f0\pard{\fs20 Die Datenbits: 5 bis 8 (Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetEncoding(encoding) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Kodierung f?r Textumwandlung beim Senden und Empfangen f?r den aktuellen Port.}\par
\f0\pard\sb75{\fs24\b encoding}\par
\f0\pard{\fs20 Die Kodierung: "Ascii" (Standard), "Unicode", "UTF7", "UTF8", "UTF32" oder "BigEndianUnicode".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetHandshake(handshake) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schaltet die 'Hardware FlowControl' f?r den aktuellen Port an oder aus.}\par
\f0\pard\sb75{\fs24\b handshake}\par
\f0\pard{\fs20 "H"	Hardware FlowControl{\line}"HX"	Hard- und Software FlowControl{\line}"X"	Software FlowControl{\line}Sonstiges Zeichen zum Entfernen}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetParity(parity) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Parit?t f?r den aktuellen Port.}\par
\f0\pard\sb75{\fs24\b parity}\par
\f0\pard{\fs20 Die Parit?t: "None" (Standard), "Even", "Mark", "Odd" oder "Space".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetStopBits(stopBits) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Stopbits f?r den aktuellen Port.}\par
\f0\pard\sb75{\fs24\b stopBits}\par
\f0\pard{\fs20 Die Stopbits: "One" (Standard), "None", "OnePointFive" oder "Two".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SwapPort(portName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Vertauscht den aktuell aktiven Port mit einem zuvor ge?ffneten Port.}\par
\f0\pard\sb75{\fs24\b portName}\par
\f0\pard{\fs20 Ein bereits ge?ffneter Port als String.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "PORTNOTFOUND".}\par
\f0\pard\sb180\shading1000{\fs30\b TXByte(dataByte) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet ein Byte an den seriellen Port.}\par
\f0\pard\sb75{\fs24\b dataByte}\par
\f0\pard{\fs20 Das zu sendende Byte.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b TXString(dataString) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet eine Zeichenfolge an den seriellen Port.}\par
\f0\pard\sb75{\fs24\b dataString}\par
\f0\pard{\fs20 Die zu sendende Zeichenfolge.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "NOCONNECTION" oder "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDController}\par
\f0\pard{\fs20 Ermittelt Eingaben von einem oder mehreren Game Controllern am USB-Anschluss (zB. Joystick oder GamePad).{\line}Bei mehr als einem angeschlossenen Ger?t, werden diese ab 1 durchnummeriert.{\line}{\line}SlimDX (Net 4.0) Laufzeit-Dll mu? installiert sein, um dieses Objekt zu verwenden (http://slimdx.org/download.php).}\par

\f0\pard\sb180\shading1000{\fs30\b Buttons(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den 'Gedr?ckt' Status f?r Controller Buttons.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 Eine Controller Nummer am USB-Anschluss (zB. Joystick oder GamePad) indexiert ab 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von Buttonstatus ("True" oder "False").}\par
\f0\pard\sb180\shading1000{\fs30\b Count \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl angeschlossener USB Controller.}\par
\f0\pard\sb180\shading1000{\fs30\b Position(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Position f?r einen Joystick Controller.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 Eine Controller Nummer am USB-Anschluss (zB. Joystick oder GamePad) indexiert ab 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von (X,Y,Z) Positionswerten (-100 bis 100).}\par
\f0\pard\sb180\shading1000{\fs30\b POV(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die POV (PointOfView) f?r Controller.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 Eine Controller Nummer am USB-Anschluss (zB. Joystick oder GamePad) indexiert ab 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von (X,Y,Z) POV Werten [Grad].}\par
\f0\pard\sb180\shading1000{\fs30\b Rotation(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Rotation f?r einen Joystick Controller.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 Eine Controller Nummer am USB-Anschluss (zB. Joystick oder GamePad) indexiert ab 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von (X,Y,Z) Rotationswerten (-100 bis 100).}\par
\f0\pard\sb180\shading1000{\fs30\b Sliders(controller) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Schieberposition f?r Controller Slider.}\par
\f0\pard\sb75{\fs24\b controller}\par
\f0\pard{\fs20 Eine Controller Nummer am USB-Anschluss (zB. Joystick oder GamePad) indexiert ab 1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von Sliderpositionen (0 bis 100).}\par
\f0\pard\sb300\shading2000{\fs36\b LDControls}\par
\f0\pard{\fs20 Steuerelemente f?r das GraphicsWindow (Intern: Control#).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\DragDrop.sb, ListBox.sb, MediaPlayer.sb, RadioButtons.sb, RichTextBox.sb, RightClickMenu.sb, TreeView.sb}\par

\f0\pard\sb180\shading1000{\fs30\b AddBrowser(width,height,url) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein WebBrowser Steuerelement im GraphicsWindow hinzu. AllowDrop ist voraktiviert (Intern: Control#).{\line}Anzeige (lokaler) Webseiten (htm, mht, xht), Dokumente (pdf, xps), Text- (sb, txt, utf8, xml usw.; ini zuvor umbenennen) Media- (swf, flv), Bilddateien (bmp, gif, ico, svg usw.) oder Ordner (C:\\Temp, cab, zip, ftp).{\line}'BrowserPageLoaded' Ereignis wird ausgel?st, au?er bei Ordner ("file:///Ordner" oder "ftp://").}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des Browserelementes.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Browserelementes.}\par
\f0\pard\sb75{\fs24\b url}\par
\f0\pard{\fs20 Die im Browser zu ladende Webadresse oder lokaler Pfad (zB. "http://smallbasic.com", "litdev.co.uk", "file:///C:\\Pfad\\[Datei.ext]", "ftp://ftp.microsoft.com/").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Browser Steuerelements.}\par
\f0\pard\sb180\shading1000{\fs30\b AddCheckBox(title) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein CheckBox Steuerelement im GraphicsWindow hinzu (Intern: Control#). B: 17 (Text ""), H: 15.}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 Der Titel rechts neben der CheckBox oder "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der CheckBox Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddComboBox(list,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein ComboBox Steuerelement im GraphicsWindow hinzu (Intern: Control#).{\line}Akzeptiert (wenn fokusiert) Pfeiltasten, 'Pos1' und 'Ende' zum Durchscrollen der Optionen.{\line}Linksb?ndige Anzeige aller Eintr?ge (Text wie Zahl).}\par
\f0\pard\sb75{\fs24\b list}\par
\f0\pard{\fs20 Ein Array mit den ComboBox Daten.{\line}Der Arrayindex ist die Reihe/Knotennummer und Arraywert ist der Anzeigetext im aktuellen Knoten:{\line} liste[1] = "Option 1"{\line} liste[2] = "Option 2"{\line} liste[3] = "Option 3"{\line} liste[4] = "Option 4"}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der ComboBox (mind. 20, Buttonstandardh?he bei Standard-FontSize 12: 20).}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die DropDown H?he der ComboBox (Standard: 0).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der ComboBox Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddContextMenu(shapeName,items,images) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einem Steuerelement oder Shape (welches Kontextmen?s unterst?tzt) ein Rechtsklick Kontextmen? hinzu (s.a. LDDialogs.AddRightClickMenu).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b items}\par
\f0\pard{\fs20 Ein Array von Auswahltexten f?r jeden Kontextmen?punkt.}\par
\f0\pard\sb75{\fs24\b images}\par
\f0\pard{\fs20 Optionaler Array von Bildsymbolen, jeder oder alle k?nnen "" sein (Standardgr??e 32x32 Pxl).{\line}Dies k?nnen R?ckgabenamen von ImageList.LoadImage, lokale oder Netzwerk- Bilddateien sein.}\par
\f0\pard\sb180\shading1000{\fs30\b AddDataView(width,height,headings) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein DataView Steuerelement zum GraphicsWindow hinzu (Intern: Control#).{\line}Alle Zeilen und Spalten sind ab 1 indexiert. Daten setzen durch Doppelklick in Zelle, 'DataViewSetRow' oder 'DataViewSetValue'.{\line}Zellenfarbe w?hlbar mit 'LDShapes.PenColour'.{\line}Spaltenbreite automat. nach l?ngster Zelle (incl. Titel).{\line}Liegt immer ?ber allen anderen Objekten im GraphicsWindow (Z-Index).{\line}Rechtsklick Kontextmen?:{\line} C?opy Selected Rows{\line} D?elete Selected Rows{\line} S?elect All  Strg A{\line} C?opy  Strg C{\line} P?aste  Strg V}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der DataView (Scrollleiste wird ev. angezeigt).}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der DataView (Zeilenh?he ca. 20). Ev. gr??er setzen als erwartete H?he (Toleranz), sp?ter erst mit Controls.SetSize skalieren).}\par
\f0\pard\sb75{\fs24\b headings}\par
\f0\pard{\fs20 Die Spaltentitel der DataView als Array ("1=;" oder "" leere DataView).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der DataView Shape.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\DataView.sb}\par
\f0\pard\sb180\shading1000{\fs30\b AddDocumentViewer(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein DocumentViewer Steuerelement (mit Symbolleiste und Suchfunktion) hinzu (Intern: Control#).{\line}Damit k?nnen Xps Dokumente (MS Version von Pdf) angezeigt werden.{\line}AllowDrop ist voraktiviert.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des DocumentViewers.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des DocumentViewers.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der DocumentViewer Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddListBox(list,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein ListBox Steuerelement im GraphicsWindow hinzu (Intern: Control#).{\line}Akzeptiert (wenn fokusiert) Pfeiltasten 'Up' und 'Down', 'Pos1' und 'Ende' zum Durchscrollen der Zeilen.}\par
\f0\pard\sb75{\fs24\b list}\par
\f0\pard{\fs20 Ein Array mit den ListBox Daten.{\line}Der Arrayindex ist die Reihe/Knotennummer und Arraywert ist der Anzeigetext im aktuellen Knoten:{\line} liste[1] = "Option 1"{\line} liste[2] = "Option 2"{\line} liste[3] = "Option 3"{\line} liste[4] = "Option 4"{\line}{\line}Alternativ auch ein LDArray oder eine LDList.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der ListBox.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der ListBox.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der ListBox Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddListView(width,height,headings) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein ListView Steuerelement im GraphicsWindow hinzu (Intern: Control#, s.a. LDDataBase.AddListView).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der ListView.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der ListView.}\par
\f0\pard\sb75{\fs24\b headings}\par
\f0\pard{\fs20 Ein Array mit den Spaltentiteln f?r die ListView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der ListView Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddMediaPlayer(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein MediaPlayer Steuerelement (Abspielen von Musik, Videos usw.) im GraphicsWindow hinzu. AllowDrop ist voraktiviert (Intern: Control#).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des MediaPlayers (Standard: 0).}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des MediaPlayers (Standard: 0).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der MediaPlayer Shape.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\MediaPlayer.sb}\par
\f0\pard\sb180\shading1000{\fs30\b AddMenu(width,height,menuList,iconList,checkList) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Men?leiste Steuerelement im GraphicsWindow hinzu (Intern: Control#).{\line}Farbgebung durch LDShapes.BrushColour bzw. MenuBackground f?r Untermen?s.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der Men?leiste.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der Men?leiste (22 bei Standard Schrifteigenschaften).}\par
\f0\pard\sb75{\fs24\b menuList}\par
\f0\pard{\fs20 Ein 1D Array mit den Men?punkten. Index ist der Text im Men?punkt und Wert ist der Men?text der ?bergeordneten Ebene.{\line}Name der Hauptebene sollte "Main" sein. Alle Namen d?rfen nur einmalig vergeben werden, da diese beim 'MenuClicked'-Ereignis zur?ckgegeben werden.{\line}Trennung mit "-", "--", "---" usw. Diese mu? einmalig sein und kann nicht ausgew?hlt werden.{\line}menu["Datei"] = "Main"{\line}menu["?ffnen"] = "Datei"{\line}menu["-"] = "Datei"{\line}menu["Ende"] = "Datei"{\line}menu["Hilfe"] = "Main"{\line}menu["Hilfe zeigen"] = "Hilfe"}\par
\f0\pard\sb75{\fs24\b iconList}\par
\f0\pard{\fs20 Optionaler Array mit Symbolen (Datei, Url, ImageList) oder "":{\line}icon["Datei"] = dir +"\\Symbol.png"}\par
\f0\pard\sb75{\fs24\b checkList}\par
\f0\pard{\fs20 Optionaler Array mit Auswahlstatus f?r Men?punkte (Haken, nicht exclusiv) oder "".{\line}Der Wert ist der anf?ngliche Auswahlstatus ("True", "False" oder "" f?r keine Statusanzeige):{\line}stat["Hilfe zeigen"] = "True"}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Men?leiste Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPasswordBox(width,height,length) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein PasswordBox Steuerelement hinzu (Intern: Control#).{\line}TextBox ohne Anzeige eingegebener Zeichen. 'PasswordEntered' Ereignis wird erst nach Dr?cken der Eingabetaste ausgel?st.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der PasswordBox.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der PasswordBox.}\par
\f0\pard\sb75{\fs24\b length}\par
\f0\pard{\fs20 Die maximale Zeichenanzahl f?r das einzugebene Passwort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der PasswordBox Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddProgressBar(width,height,orientation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Fortschrittsanzeige Steuerelement (Werte 0-100 [%]) hinzu (Intern: Control#).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der ProgressBar.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der ProgressBar.}\par
\f0\pard\sb75{\fs24\b orientation}\par
\f0\pard{\fs20 Horizontal oder vertikal?  "H" (Standard) oder "V".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der ProgressBar Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRadioButton(title,group) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein RadioButton Steuerelement im GraphicsWindow hinzu. Standard: BxH = 16x15 ohne Text (Intern: Control#).{\line}Je Gruppe kann nur ein RadioButton aktiv gesetzt sein (XOR exklusiv).}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 Der Titel rechts neben dem RadioButton oder "".}\par
\f0\pard\sb75{\fs24\b group}\par
\f0\pard{\fs20 Der Gruppenname f?r den RadioButton in "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der RadioButton Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRichTextBox(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine RichTextBox im GraphicsWindow hinzu. AllowDrop ist voraktiviert. Anzeige von rtf und Textdateien (Intern: Control#).{\line}Bei Bedarf rechte/untere Scrollleiste (Breite: 18).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der RichTextBox.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der RichTextBox.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der RichTextBox Shape.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\RichTextBox.sb}\par
\f0\pard\sb180\shading1000{\fs30\b AddSlider(width,height,orientation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Schieberegler Steuerelement (Standard: 0 - 100 bzw. SliderMaximum) hinzu (Intern: Control#).{\line}Erlaubt Cursortasten Left|Down, Right|Up (um -/+0.1%), sowie PageUp/Next (um -/+1%), Home/End (zu 0/100%).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des Sliders ("V" Optimalbreite 22).}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Sliders ("H" Optimalh?he 22).}\par
\f0\pard\sb75{\fs24\b orientation}\par
\f0\pard{\fs20 Horizontal oder vertikal?  "H" (Standard) oder "V".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Slider Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddTreeView(tree,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Baumansicht Steuerelement im GraphicsWindow hinzu (Intern: Control#).{\line}Akzeptiert (wenn fokusiert) Pfeiltasten, 'Pos1' und 'Ende' zum Durchscrollen der Knoten.}\par
\f0\pard\sb75{\fs24\b tree}\par
\f0\pard{\fs20 Ein 2D Array mit den TreeView Daten:{\line}Der erste Index ist die Reihe/Knotennummer.{\line}Der zweite Index ist der Index des Elternknoten des aktuellen Knoten (0 f?r oberste Ebene).{\line}Der Arraywert ist der angezeigte Text im betreffenden Knoten:{\line} baum[1][0] = "Ebene 1"{\line} baum[2][1] = "Ebene 1 1"{\line} baum[3][1] = "Ebene 1 2"{\line} baum[4][0] = "Ebene 2"}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der TreeView.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der TreeView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der TreeView Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AllowDrop(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Shape um darauf 'Ziehen&Ablegen' (Drag&Drop) zu erlauben.{\line}Folgende UI-Elemente werden unterst?tzt, um (+mit/-ohne FileDropped Ereignis) darauf abgelegte Datei(en)/Ordner zu verarbeiten:{\line}+ Datei-/Orderpfad auf TextBox bzw. mehrere Datei-/Ordnerpfade (als Array) auf MultiLineTextBox oder Textshape.{\line}+ Bilddatei auf Bildshape oder "Background" f?r GW-Hintergrund (Bildansicht).{\line}+ 3D-Modelldatei (s. LD3DView.LoadModel) auf ein Objekt in 3DView.{\line}- Zu ?ffnende Datei auf RichTextBox (voraktiviert, Textansicht).{\line}- Anzuzeigendes Xps Dokument in DocumentViewer (voraktiviert).{\line}- Mediendateien f?r MediaPlayer (wenn g?ltiges Medium bereits geladen, voraktiviert).{\line}- Anzuzeigendes Dokument oder Url in Browser (voraktiviert).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape f?r Dateiablage.{\line}"Background" (automat. DrawResizedImage(bild,0,0,gw,gh) ohne FileDropped Ereignis).}\par
\f0\pard\sb180\shading1000{\fs30\b BrowserHistory(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle zuvor geladenen Adressen im Browserverlauf als Array.{\line}Jede Adresse ist nur einmalig gelistet in der Reihenfolge des Erstbesuchs aber spiegelt nicht die konkrete Adressreihenfolge.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Browser Steuerelements.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den URLs/Pfaden des Verlaufs.}\par
\f0\pard\sb180\shading1000{\fs30\b BrowserNavigate(shapeName,direction) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Navigiert im Inhaltsverlauf eines Browsers um eine Adresse vor (F) oder zur?ck (B) in der Besuchsreihenfolge. 'BrowserPageLoaded' Ereignis wird immer ausgel?st.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Browser Steuerelements.}\par
\f0\pard\sb75{\fs24\b direction}\par
\f0\pard{\fs20 "B" oder "F" f?r R?ck-/Vorw?rts in 'BrowserHistory'.}\par
\f0\pard\sb180\shading1000{\fs30\b BrowserPageLoaded \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf beim Laden einer Browserseite.}\par
\f0\pard\sb180\shading1000{\fs30\b BrowserSetURL(shapeName,url) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Inhalt/Adresse f?r ein WebBrowser Steuerelement. 'BrowserPageLoaded' Ereignis wird immer ausgel?st.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Browser Steuerelements.}\par
\f0\pard\sb75{\fs24\b url}\par
\f0\pard{\fs20 Die im Browser zu ladende Webadresse oder lokaler Pfad (zB. "http://smallbasic.com", "litdev.co.uk", "file:///C:\\Pfad\\[Datei.ext]", "ftp://ftp.microsoft.com/").}\par
\f0\pard\sb180\shading1000{\fs30\b CheckBoxChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Anklicken einer Checkbox (an-/abhaken).}\par
\f0\pard\sb180\shading1000{\fs30\b CheckBoxGetState(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Auswahlstatus einer CheckBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der CheckBox Form.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Status der CheckBox ("True" oder "False").}\par
\f0\pard\sb180\shading1000{\fs30\b CheckBoxState(shapeName,state) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Auswahlstatus f?r eine CheckBox. Bei einer Status?nderung wird auch 'CheckBoxChanged' Event ausgel?st.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der CheckBox Form.}\par
\f0\pard\sb75{\fs24\b state}\par
\f0\pard{\fs20 Der CheckBox Auswahlstatus ("True" oder "False").}\par
\f0\pard\sb180\shading1000{\fs30\b ComboBoxContent(shapeName,list) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ersetzt/Aktualisiert die Liste in einer ComboBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ComboBox Shape.}\par
\f0\pard\sb75{\fs24\b list}\par
\f0\pard{\fs20 Ein Array mit den ComboBox Daten.{\line}Der Arrayindex ist die Reihe/Knotennummer und Arraywert ist der Anzeigetext am aktuellen Knoten:{\line} liste[1] = "Option 1"{\line} liste[2] = "Option 2"{\line} liste[3] = "Option 3"{\line} liste[4] = "Option 4"}\par
\f0\pard\sb180\shading1000{\fs30\b ComboBoxGetSelected(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den aktuell gew?hlten Knoten in einer ComboBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ComboBox.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der gew?hlte Knoten in der ComboBox (Arrayindex, Standard: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b ComboBoxItemChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl?nderung in einer ComboBox oder Anklicken des gew?hlten Elementes.}\par
\f0\pard\sb180\shading1000{\fs30\b ComboBoxSelect(shapeName,node) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen Knoten in einer ComboBox als Auswahl.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ComboBox.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 Der auszuw?hlende Knoten (Arrayindex, Standard: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b ContextMenuClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl eines Rechtsklick-Kontextmenupunktes in einer Form oder Steuerelement .}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewAllowSort(shapeName,allow) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erlaubt Spaltensortierung in einer DataView bei Mausklick auf einen Spaltentitel.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b allow}\par
\f0\pard{\fs20 Sortierung erlauben?  "True" (Standard) oder "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewAllowUserEntry(shapeName,allow) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Benutzereingabe von Daten in der untersten Zeile einer DataView.{\line}Bei "False" wird diese Zeile auch ausgeblendet.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b allow}\par
\f0\pard{\fs20 Benutzereingabe von Daten zulassen?  "True" (Standard) oder "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewButtonClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Anklicken eines DataView Button.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewCellValueChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei ?nderung eines Zellenwertes in einer DataView, nachdem dieser ?bernommen wurde (zB. Auswahl au?erhalb der Zelle).}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewClear(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht alle Zeilen in einer DataView (Spaltentitel bleiben erhalten).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColAlignment(shapeName,col,alignment) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Anzeigeausrichtung f?r eine gesamte Spalte in einer DataView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b alignment}\par
\f0\pard{\fs20 Die Ausrichtung:{\line}"Left"	linksb?ndig (Standard){\line}"Center"	zentriert{\line}"Right"	rechtsb?ndig}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColumnReadOnly(shapeName,col,readOnly) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Schreibschutz f?r eine Spalte in einer DataView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b readOnly}\par
\f0\pard{\fs20 Schreibschutz setzen?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColumnSort(shapeName,col,ascending) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sortiert die Eintr?ge einer DataView nach einer bestimmten Spalte.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer nach der sortiert wird (ab 1).}\par
\f0\pard\sb75{\fs24\b ascending}\par
\f0\pard{\fs20 Sortierrichtung?  Aufsteigend ("True") oder absteigend ("False", Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColumnVisible(shapeName,col,visible) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Sichtbarkeit f?r eine Spalte in einer DataView (nicht f?r linke Indexspalte).{\line}Verwendung um zB. die ID Spalte einer Datenbank zu verbergen.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b visible}\par
\f0\pard{\fs20 Spalte anzeigen?  "True" (Standard) oder "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewColumnWidths(shapeName,widths) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Spaltenbreiten in einer DataView (Linke Indexspalte: 60 Pxl Breite).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b widths}\par
\f0\pard{\fs20 Ein Array mit den einzelnen Spaltenbreiten [Pxl] ("" zur Auto-Anpasssung).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewDeleteRow(shapeName,row) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht eine gesamte Datenzeile aus einem DataView Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewGetFocus(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die aktuell fokusierte Zelle in einer DataView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 1D Array mit aktuell fokusierter Zeilen- und Spaltennummer ("1=Zeile#;2=Spalte#;"), sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewGetRow(shapeName,row) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine gesamte Datenzeile in einem DataView Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit einzelnen Zellenwerten (einer pro Spalte) bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewGetSelected(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste aller ausgew?hlten Zellen in einer DataView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die aktuell gew?hlten Zeilen und Spalten als 2D Array:{\line}zellen[1][1] = zeile# bzw.{\line}zellen[1][2] = spalte#  'Zelle1}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewGetValue(shapeName,row,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Wert in einer angegebenen Zelle einer DataView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Zellenwert oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewReadFromCSV(shapeName,fileName,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt alle Daten aus einer CSV (comma separated values) Textdatei in eine bestehende DataView ein (Zeile f?r Zeile).{\line}Die Spaltentitel m?ssen definiert und ihre Anzahl <= CSV-Spalten sein.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der CSV Datei.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Daten am Ende der DataView anf?gen?  "True" oder "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewRowColours(shapeName,row,background,foreground) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Hinter- und Vordergrundfarbe f?r eine Datenzeile in einer DataView.{\line}Die entsprechenden Zeilen m?ssen bereits definiert/gesetzt sein.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer oder 0 (alle Zeilen abwechselnd).}\par
\f0\pard\sb75{\fs24\b background}\par
\f0\pard{\fs20 Die Hintergrundfarbe.}\par
\f0\pard\sb75{\fs24\b foreground}\par
\f0\pard{\fs20 Die Text-/Vordergrundfarbe (PenColour).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewRowCount(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Zeilenanzahl in einem DataView Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Zeilen.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSaveAsCSV(shapeName,fileName,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert die Gesamtdaten einer DataView in eine CSV (comma separated values) Textdatei.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der CSV Datei.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Daten am Ende der CSV Datei anf?gen?  "True" oder "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSelectionChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl?nderung in einer DataView.{\line}Wird nicht ausgel?st f?r DataView(SetColumn) Button Klicks, daf?r 'DataViewButtonClicked' verwenden.{\line}Wird nicht ausgel?st f?r DataView(SetColumn) CheckBox oder -ComboBox Klicks, daf?r 'DataViewCellValueChanged' verwenden.}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetColumnButton(shapeName,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ndert ein Spaltenelement einer DataView zu Button(s). F?r Ereignis s. DataViewButtonClicked.{\line}Dies sollte gesetzt werden bevor Daten hinzugef?gt werden, nach Erstellung der DataView.{\line}Ist die DataView an die Datenbank gebunden, dann nach dem Setzen von LDDataBase.EditTable setzen.{\line}Die Daten in diesen Zellen werden zu den Buttontiteln.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetColumnCheckBox(shapeName,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ndert ein Spaltenelement einer DataView zu CheckBox(en). F?r Ereignis s. DataViewCellValueChanged.{\line}Dies sollte gesetzt werden bevor Daten hinzugef?gt werden, nach Erstellung der DataView.{\line}Ist die DataView an die Datenbank gebunden, dann nach dem Setzen von LDDataBase.EditTable setzen.{\line}Die Daten f?r diese Zellen sollten "True" oder "False" beinhalten.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetColumnComboBox(shapeName,col,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ndert eine Spalte in einer DataView zu ComboBox(en) mit w?hlbaren Werten. F?r Ereignis s. DataViewCellValueChanged.{\line}Sollte gesetzt werden bevor Daten eingetragen werden, nach Erstellung der DataView.{\line}Ist die DataView an die Datenbank gebunden, dann nach dem Setzen von LDDataBase.EditTable setzen.{\line}Die zu ermittelnden/setzenden Zellendaten sind die unter 'data' Parameter gesetzten Arraywerte.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die gew?hlten Daten f?r die ComboBox(en) als Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetFocus(shapeName,row,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Fokus auf eine angegebene Zelle in einer DataView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetRow(shapeName,row,values) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Datenzeile in einem DataView Steuerelement (hinzu).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).{\line}Ist diese Zeilennummer h?her als die aktuelle Zeilenanzahl, wird eine neue Zeile angef?gt, sonst werden vorhandene Zeilendaten ?berschrieben.}\par
\f0\pard\sb75{\fs24\b values}\par
\f0\pard{\fs20 Ein Array mit einzelnen Zellenwerten (einer pro Spalte).{\line}Leere Zellen/Arraywerte mit " " besetzen/auff?llen.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DataViewSetValue(shapeName,row,col,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Wert in einer angegebenen Zelle einer DataView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DataView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b DocumentViewerLoadXPS(shapeName,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?dt eine Xps Datei zur Ansicht in einen DocumentViewer.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der DocumentViewer Shape.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu ladenden und anzuzeigenden Xps Datei.}\par
\f0\pard\sb180\shading1000{\fs30\b FileDropped \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn Datei(en) oder Ordner auf ein Steuerelement, Bildshape oder 3DView (per AllowDrop) gezogen&abgelegt wurde(n).}\par
\f0\pard\sb180\shading1000{\fs30\b LastBrowser \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzten Browser Shape, worin eine Seite geladen wurde.}\par
\f0\pard\sb180\shading1000{\fs30\b LastBrowserPage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die letzte geladene Browserseite (Url oder file:///C:/lokale/Datei.ext), nachdem die Seite vollst?ndig geladen ist.}\par
\f0\pard\sb180\shading1000{\fs30\b LastCheckBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der zuletzt geklickten CheckBox (An- oder Abwahl).}\par
\f0\pard\sb180\shading1000{\fs30\b LastCheckBoxState \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Auswahlstatus ("True" oder "False") der zuletzt geklickten CheckBox.}\par
\f0\pard\sb180\shading1000{\fs30\b LastComboBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzten ComboBox mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastComboBoxIndex \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den gew?hlten Index (Knotennummer) f?r die letzte ComboBox mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastContextControl \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das Steuerelement/Shape mit dem letzten gew?hlten Rechtsklick-Kontextmen?punkt.}\par
\f0\pard\sb180\shading1000{\fs30\b LastContextItem \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Arrayindex der Kontextauswahl im letzten Steuerelement/Shape mit gew?hltem Rechtsklick-Kontextmen?punkt.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDataBaseTable \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzten Datenbank Tabelle, f?r welche Auswahl?nderung in einer DataView stattfand.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDataView \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzen DataView mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDataViewButtonClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Zeile, Spalte und Wert des zuletzt geklickten DataView Button als 3-elementigen Array.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDataViewCellValueChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Zeile, Spalte und Wert der letzten Zelle einer DataView, deren Wert ge?ndert wurde, als 3-elementigen Array.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDropFiles \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Pfad(en) der zuletzt 'gezogen&abgelegten' Datei(en) als Array.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDropShape \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der Shape, worauf zuletzt eine Datei 'gezogen&abgelegt' wurde (zB. Background, Image#, View3D# usw.).}\par
\f0\pard\sb180\shading1000{\fs30\b LastListBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzten ListBox mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastListBoxIndex \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den gew?hlten Index (Knotennummer) f?r die letzte ListBox mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastListView \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzten ListView mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastListViewColumn \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die zuletzt gew?hlte Spaltennummer in einer ListView.}\par
\f0\pard\sb180\shading1000{\fs30\b LastListViewRow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die zuletzt gew?hlte Zeilennummer in einer ListView.}\par
\f0\pard\sb180\shading1000{\fs30\b LastMediaPlayer \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name des letzten MediaPlayer, f?r den ein Ereignis stattfand.}\par
\f0\pard\sb180\shading1000{\fs30\b LastMenuControl \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name des letzten Men? Steuerelements mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastMenuItem \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name des zuletzt gew?hlten Men?punktes in einem Men? Steuerelement.}\par
\f0\pard\sb180\shading1000{\fs30\b LastPassword \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das zuletzt in eine PasswordBox eingegebene Passwort.}\par
\f0\pard\sb180\shading1000{\fs30\b LastPasswordBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzten PasswordBox mit Eingabeereignis (Eingabetaste gedr?ckt).}\par
\f0\pard\sb180\shading1000{\fs30\b LastRadioButton \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name f?r den letzten gew?hlten RadioButton.}\par
\f0\pard\sb180\shading1000{\fs30\b LastRadioButtonGroup \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Gruppenname f?r den zuletzt gew?hlten RadioButton.}\par
\f0\pard\sb180\shading1000{\fs30\b LastRichTextBox \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der RichTextBox, in der zuletzt Text geschrieben/eingef?gt/ge?ndert wurde.}\par
\f0\pard\sb180\shading1000{\fs30\b LastSlider \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name des letzten Sliders mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastSliderValue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Wert des zuletzt aktiven Sliders (Std: 0-100 bzw. 0-SliderMaximum, 13 Dezimalen).}\par
\f0\pard\sb180\shading1000{\fs30\b LastTreeView \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzten TreeView mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastTreeViewIndex \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Index (Knotennummer) in der letzten TreeView mit Auswahl?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxContent(shapeName,list) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ersetzt/Aktualisiert eine ListBox Liste.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListBox Shape.}\par
\f0\pard\sb75{\fs24\b list}\par
\f0\pard{\fs20 Ein Array mit den ListBox Daten.{\line}Der Arrayindex ist die Reihe/Knotennummer und Arraywert ist der Anzeigetext am aktuellen Knoten:{\line} liste[1] = "Option 1"{\line} liste[2] = "Option 2"{\line} liste[3] = "Option 3"{\line} liste[4] = "Option 4"{\line}{\line}Alternativ auch ein LDArray oder eine LDList.}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxGetSelected(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den gew?hlten Knoten in einer ListBox (Arrayindex).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListBox.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ausgew?hlte Knotennummer(n) in der ListBox.{\line}Bei Mehrfachauswahl (s. ListBoxSelectionMode) ein Array mit Knotennummern oder "" f?r keine Auswahl.}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxItemChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl?nderung in einer ListBox oder Anklicken des gew?hlten Elementes.}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxSelect(shapeName,node) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 W?hlt einen oder mehrere Knoten in einer ListBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListBox.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 Die auszuw?hlende Knotennummer(n) gem?? Arrayindex.{\line}Bei Mehrfachauswahl ein Array mit Knotennummern (s. ListBoxSelectionMode).}\par
\f0\pard\sb180\shading1000{\fs30\b ListBoxSelectionMode(shapeName,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Auswahlmodus f?r eine ListBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListBox.}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 Ein Modus von:{\line}"Single"    Einzelauswahl (Standard){\line}"Multiple"  Mehrfachauswahl mit [Strg] Taste{\line}"Extended"  Erweiterte Auswahl mit [Strg]+[Umsch] Tasten}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewClear(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt alle Zeilen aus einem ListView Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListView.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewColAlignment(shapeName,col,alignment) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Anzeigeausrichtung f?r eine Spalte in einer ListView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListView.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spaltennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b alignment}\par
\f0\pard{\fs20 Die Ausrichtung:{\line}"Left"	linksb?ndig (Standard){\line}"Center"	zentriert{\line}"Right"	rechtsb?ndig}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewDeleteRow(shapeName,row) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht eine Datenzeile aus einem ListView Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).{\line}Ist diese Zeilennummer h?her als die aktuelle Zeilenanzahl, wird keine Aktion durchgef?hrt.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewEdit(shapeName,editable) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den 'Bearbeiten' Status f?r die Zellen in einer ListView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListView.}\par
\f0\pard\sb75{\fs24\b editable}\par
\f0\pard{\fs20 "True" (TextBoxen zur Bearbeitung) oder "False" (nicht bearbeitbare Textbl?cke, Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewGetRow(shapeName,row) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Datenzeile in einem ListView Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Werten (ein Wert pro Spalte) bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewRowCount(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Spaltenanzahl in einem ListView Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Spalten in der ListView.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewSelectionChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl?nderung in einer ListView.}\par
\f0\pard\sb180\shading1000{\fs30\b ListViewSetRow(shapeName,row,values) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Datenzeile in einem ListView Steuerelement hinzu.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der ListView.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeilennummer (ab 1).{\line}Ist diese Zeilennummer h?her als die aktuelle Zeilenanzahl, wird eine neue Zeile hinzugef?gt. Ansonst werden die Zeilendaten ?berschrieben.}\par
\f0\pard\sb75{\fs24\b values}\par
\f0\pard{\fs20 Ein Array mit den Werten (ein Wert pro Spalte).}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerEnded \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein MediaPlayer das Abspielen des aktuellen Mediums beendet.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerLoad(shapeName,media) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?dt ein Medium in ein MediaPlayer Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb75{\fs24\b media}\par
\f0\pard{\fs20 Das zu ladende Medium, zB. eine Bild-, Audio- oder Videodatei (bmp, (anim)gif, ico, jp, png; au, flac, m4a, mid, mp3, ogg, wav, wma; avi, mp4, mpg, wmv usw.)}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerOpened \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein MediaPlayer (ein) neues Medien(um) ?ffnet.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerPause(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pausiert das Abspielen in einem MediaPlayer (f?r aktuell geladenes Medium).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerPlay(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet das Abspielen/Anzeige in einem MediaPlayer (f?r aktuell geladenes Medium).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerPlayTime(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Gesamtspieldauer (f?r aktuell geladenes Medium) in einem MediaPlayer.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Gesamtspieldauer des Mediums [ms].}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerPosition(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die aktuelle Laufzeit (f?r aktuell geladenes Medium) in einem MediaPlayer.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die aktuelle Laufzeit des Mediums [ms].}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerSeek(shapeName,seek) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Abspielposition eines Mediums in einem MediaPlayer (f?r aktuell geladenes Medium).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb75{\fs24\b seek}\par
\f0\pard{\fs20 Die neue Abspielposition [ms].}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerSpeed(shapeName,speed) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Wiedergabegeschwindigkeit f?r einen MediaPlayer.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb75{\fs24\b speed}\par
\f0\pard{\fs20 Die Abspielgeschwindigkeit (0 bis 100). Standard: 1 (normales Abspielen).}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerStop(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt das Abspielen in einem MediaPlayer (f?r aktuell geladenes Medium).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerStretch(shapeName,stretch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Streckung eines visuellen Mediums - wie die Ansicht einen Bereich ausf?llt.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb75{\fs24\b stretch}\par
\f0\pard{\fs20 Die Streckmethode:{\line}"None" - Der Inhalt beh?lt seine Originalgr??e.{\line}"Uniform" - Die Inhaltsgr??e wird angepasst um in die Zielabmessungen zu passen, wobei das nat?rliche Ansichtsverh?ltnis beibehalten wird (Standard).{\line}"Fill" - Die Inhaltsgr??e wird angepasst um die Zielabmessungen auszuf?llen. Das Ansichtsverh?ltnis wird nicht beibehalten.{\line}"UniformToFill" - Die Inhaltsgr??e wird angepasst um die Zielabmessungen auszuf?llen, w?hrend das nat?rliche Ansichtsverh?ltnis beibehalten wird. Mittels Clipping falls n?tig.}\par
\f0\pard\sb180\shading1000{\fs30\b MediaPlayerVolume(shapeName,volume) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Lautst?rke f?r einen MediaPlayer.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des MediaPlayers.}\par
\f0\pard\sb75{\fs24\b volume}\par
\f0\pard{\fs20 Die Lautst?rke (0 bis 1, Standard: 0.5).}\par
\f0\pard\sb180\shading1000{\fs30\b MenuBackground(shapeName,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Hintergrundfarbe f?r Untermen?s.{\line}Das obere Haupmen? kann separat mit LDShapes.BrushColour gef?rbt werden.{\line}Beachte da? Trennungen nicht gef?rbt werden und oft ist es besser nur das Hauptmen? zu f?rben.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Men? Steuerelements.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Hintergrundfarbe (#(AA)RRGGB, aber keine Transparenz).}\par
\f0\pard\sb180\shading1000{\fs30\b MenuChecked(shapeName,itemName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Auswahlstatus eines Men?punktes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Men? Steuerelements.}\par
\f0\pard\sb75{\fs24\b itemName}\par
\f0\pard{\fs20 Der Name des Men?punktes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b MenuClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl eines Men?punktes.}\par
\f0\pard\sb180\shading1000{\fs30\b PasswordEntered \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Eingabe eines Passwortes in eine PasswordBox (nachdem Eingabetaste gedr?ckt).}\par
\f0\pard\sb180\shading1000{\fs30\b ProgressBarValue(shapeName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Wert f?r eine Fortschrittsanzeige (Fortschrittsverlauf).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Fortschrittsanzeige Shape.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der Wert f?r die Fortschrittsanzeige (0 bis 100 [%]).}\par
\f0\pard\sb180\shading1000{\fs30\b RadioButtonClicked \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl?nderung eines RadioButton (anw?hlen).}\par
\f0\pard\sb180\shading1000{\fs30\b RadioButtonGet(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Auswahlstatus eines RadioButton.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der RadioButton dessen Status ermittelt wird.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Status des RadioButton ("True" oder "False").}\par
\f0\pard\sb180\shading1000{\fs30\b RadioButtonSet(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen RadioButton als ausgew?hlt/aktiviert. Bei einer Status?nderung wird auch 'RadioButtonClicked' Event ausgel?st.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der zu setzende RadioButton.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxCaseSensitive \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Beachtung von Gro?-/Kleinschrift bei Wort-/Ausdruckhervorhebung?  "True" oder "False" (Standard).{\line}Ist zu setzen bevor 'RichTextBoxWord' aufgerufen wird.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxClear(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt den gesamten Text aus einer RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der RichTextBox.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxDefault(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Standard Schriftstil mittels aktueller RichTextBox Eigenschaften.{\line}Info: Textdekoration (zB. RichTextBoxFontUnderline) ist f?r diese Option nicht verf?gbar.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der RichTextBox.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontBackground \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Schrift Hintergrundfarbe (Standard: "White").{\line}Vor dem Aufruf von RichTextBoxSelection, RichTextBoxWord oder RichTextBoxDefault setzen.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontBold \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Schriftstil Fettdruck?  "True" oder "False" (Standard).{\line}Vor dem Aufruf von RichTextBoxSelection, RichTextBoxWord oder RichTextBoxDefault setzen.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontFamily \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Schriftart, zB. "Century Gothic" (Standard: "Segoe UI").{\line}Vor dem Aufruf von RichTextBoxSelection, RichTextBoxWord oder RichTextBoxDefault setzen.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontForeground \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Schrift Vordergrundfarbe (Standard: "Black").{\line}Vor dem Aufruf von RichTextBoxSelection, RichTextBoxWord oder RichTextBoxDefault setzen.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontItalic \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Schriftstil Kursiv?  "True" oder "False" (Standard).{\line}Vor dem Aufruf von RichTextBoxSelection, RichTextBoxWord oder RichTextBoxDefault setzen.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontSize \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Schriftgr??e Punkteh?he (Standard: 12).{\line}Vor dem Aufruf von RichTextBoxSelection, RichTextBoxWord oder RichTextBoxDefault setzen.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxFontUnderline \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Schriftstil Unterstreichung (Strg+U)?  "True" oder "False" (Standard).{\line}Vor dem Aufruf von RichTextBoxSelection, RichTextBoxWord oder RichTextBoxDefault setzen.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxGetText(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Text (unformatiert) in einer angegebenen RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der RichTextBox.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Text in der RichTextBox (CrLf wird angef?gt, Tab am Zeilenanfang s. RichTextBoxIndentToTab).}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxIndentToTab \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Umwandlung des ersten Zeileneinzugzeichens zu einem Tab?  "True" (Standard) oder "False".{\line}Ein eingetippter Tab als erstes Zeichen einer RichTextBox Zeile erstellt einen Einzug ("False"), sonst einen Tabulator ("True").}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxLoad(shapeName,fileName,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Laden von Text (mitsamt Formatierung) aus einer Datei (im rtf Format) in eine RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der RichTextBox.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der Dateipfad zum Laden des Textes (mit Formatierung).}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Anf?gen an bestehenden Textinhalt?  "True" oder "False" (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxMargins(left,right,top,bottom) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Randabstand [Pxl] f?r Abs?tze in der RichTextBox.{\line}F?r jeden angef?gten oder erstellten Text (per RichTextBoxSetText) wird ein neuer Absatz erstellt.}\par
\f0\pard\sb75{\fs24\b left}\par
\f0\pard{\fs20 Linker Rand (Standard: 0).}\par
\f0\pard\sb75{\fs24\b right}\par
\f0\pard{\fs20 Rechter Rand (Standard: 0).}\par
\f0\pard\sb75{\fs24\b top}\par
\f0\pard{\fs20 Oberer Rand (Standard: 0).}\par
\f0\pard\sb75{\fs24\b bottom}\par
\f0\pard{\fs20 Unterer Rand (Standard: 0).}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxReadOnly \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den 'Schreibschutz' Status f?r die folgende RichTextBox?  "True" oder "False" (Standard).{\line}Ist zu setzen bevor 'AddRichTextBox' aufgerufen wird.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxSave(shapeName,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert den Text aus einer RichTextBox (mitsamt Formatierung) in eine Datei im rtf Format.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der RichTextBox.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der Dateipfad zum Speichern des Textes (mit Formatierung).}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxSelection(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Schriftstil f?r markierten RichTextBox Text mittels aktueller RichTextBox Eigenschaften.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der RichTextBox.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxSetText(shapeName,text,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Text (unformatiert) in eine RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der RichTextBox.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der zu ladende Text.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 An bestehenden Text anf?gen?  "True" oder "False" (Standard).{\line}F?r jeden angef?gten Text wird ein neuer Absatz erstellt. S. RichTextBoxMargins zum Setzen von Rand f?r den Absatz.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxTextAlignment \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Textausrichtung in der RichTextBox:{\line}"Left"	 linksb?ndig (Standard, Strg+L){\line}"Center" zentriert{\line}"Right"	 rechtsb?ndig (Strg+R){\line}"Justify" Blocksatz{\line}{\line}Ist zu setzen bevor 'AddRichTextBox' aufgerufen wird.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxTextTyped \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn Text in einer RichTextBox eingegeben oder ge?ndert wurde.{\line}Nicht bei Mausklick, Cursortasten, Pos1/Ende usw. Jedoch bei 'Back'(Space), Ausschneiden/Einf?gen.}\par
\f0\pard\sb180\shading1000{\fs30\b RichTextBoxWord(shapeName,text,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Schriftstil f?r ein angegebenes Wort/Ausdruck mittels aktueller RichTextBox Eigenschaften.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der RichTextBox.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der zu ?ndernde Text (Gro?-/Kleinschr. setzen durch RichTextBoxCaseSensitive Parameter).}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 Anwenden f?r Instanzen von Wort/Ausdruck:{\line}0	Alle Instanzen (Standard){\line}1	Erste Instanz{\line}2	Letzte Instanz}\par
\f0\pard\sb180\shading1000{\fs30\b SetButtonStyle(shapeName,brushUnpressed,brushMouseOver,brushPressed,penUnpressed,penMouseOver,penPressed,radius,shine) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt/?ndert den Ansichtsstil f?r einen bestehenden Button. F?r anwendbare Gradientpinsel (Brush) s. LDShapes.BrushGradient/-BrushImage.{\line}Gr??en?nderung mit Controls.SetSize erst danach anwenden (LDShapes.SetSize funktioniert auch davor).{\line}brush- und pen- Parameter d?rfen nicht "" sein. Jeder erstellte Gradientpinsel (Brush) kann nur 1x verwendet werden.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des zu ?ndernden Button.}\par
\f0\pard\sb75{\fs24\b brushUnpressed}\par
\f0\pard{\fs20 Die Hintergrundfarbe f?r den UNgedr?ckten Button, bzw. ein Gradientpinsel (Brush), wie LDShapes.BrushColour.}\par
\f0\pard\sb75{\fs24\b brushMouseOver}\par
\f0\pard{\fs20 Die Hintergrundfarbe des Button beim ?berfahren mit dem Mauszeiger, bzw. ein Gradientpinsel (Brush).}\par
\f0\pard\sb75{\fs24\b brushPressed}\par
\f0\pard{\fs20 Die Hintergrundfarbe des GEdr?ckten Button, bzw. ein Gradientpinsel (Brush).}\par
\f0\pard\sb75{\fs24\b penUnpressed}\par
\f0\pard{\fs20 Die Textfarbe auf dem UNgedr?ckten Button ("Transparent" verbirgt Buttontext, wie LDShapes.PenColour).}\par
\f0\pard\sb75{\fs24\b penMouseOver}\par
\f0\pard{\fs20 Die Textfarbe des Button beim ?berfahren mit dem Mauszeiger ("Transparent" verbirgt Buttontext).}\par
\f0\pard\sb75{\fs24\b penPressed}\par
\f0\pard{\fs20 Die Textfarbe auf dem GEdr?ckten Button ("Transparent" verbirgt Buttontext).}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Der Eckenradius f?r den Button (Standard: 3, "" f?r 0).}\par
\f0\pard\sb75{\fs24\b shine}\par
\f0\pard{\fs20 Leuchteffekt f?r den Button?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetCursorPosition(shapeName,position) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Cursor Einf?gemarke hinter die angegebene Position innerhalb einer (MultiLine)TextBox. Nicht f?r RichTextBox.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der (MultiLine)TextBox Shape.}\par
\f0\pard\sb75{\fs24\b position}\par
\f0\pard{\fs20 Die Cursorposition hinter dem entsprechenden Zeichen (0 ist vor dem ersten Zeichen, h?here Werte zB. 1000 zum Setzen des Cursors ans Textende).}\par
\f0\pard\sb180\shading1000{\fs30\b SetCursorToEnd(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Scrollt die Ansicht in einer MultiLine- oder RichTextBox bis zum Ende des Textinhalts.{\line}Die Cursorposition bleibt dabei unver?ndert.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der TextBox Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b SetSpellCheck(shapeName,state) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Rechtschreibpr?fung f?r eine (Rich)TextBox an/aus.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der (Rich)TextBox Shape.}\par
\f0\pard\sb75{\fs24\b state}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SliderChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn der Wert eines Schiebereglers ge?ndert wurde.{\line}Bei Verschub mit Maus bzw. L-Mausklick (PageUp/Next) um 1%, Cursortasten Left|Down (-), Right|Up (+) um 0.1%, Home/End auf 0/100%.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Trackbar Slider{\line}LDControls.SliderMaximum = 2{\line}slid = LDControls.AddSlider(200,22,""){\line}LDControls.SliderChanged = SlidChange{\line}LDControls.SliderValue(slid, 1) '-0+{\line}{\line}Sub SlidChange{\line}  val = 0.1*Math.Round(LDControls.LastSliderValue/0.1)-1{\line}  GraphicsWindow.Title = val{\line}EndSub}\par
\f0\pard\sb180\shading1000{\fs30\b SliderGetValue(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den aktuellen Wert eines Schiebereglers (Position).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Schieberegler Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert f?r den Schieberegler (Standard: 0, >=0 bis 100 bzw. SliderMaximum).}\par
\f0\pard\sb180\shading1000{\fs30\b SliderMaximum \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Maximalwert f?r einen Slider (Standard: 100). Der Minimalwert ist stets 0.{\line}Vor dem Aufruf von AddSlider setzen/?ndern. Gilt f?r alle weiteren neu erstellten LDSlider bis zur erneuten ?nderung.}\par
\f0\pard\sb180\shading1000{\fs30\b SliderValue(shapeName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Wert f?r einen Schieberegler (Position). Bei Wert-/Positions?nderung wird auch 'SliderChanged' Event ausgel?st.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Schieberegler Shape.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der neue Wert f?r den Schieberegler (Standard: 0, >=0 bis 100 bzw. SliderMaximum).}\par
\f0\pard\sb180\shading1000{\fs30\b TextBoxReadOnly(shapeName,readOnly) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den 'Schreibschutz' Status f?r eine (MultiLine)TextBox (ReadOnly).{\line}Cursor(steuerung) sowie Ausschneiden/Einf?gen (Kontextmen?) deaktiviert. }\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der (MultiLine)TextBox.}\par
\f0\pard\sb75{\fs24\b readOnly}\par
\f0\pard{\fs20 "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Schreibschutz in RichTextBox{\line}LDShapes.SetProperty(rtb, "IsReadOnly","True"){\line}'LDShapes.SetProperty(rtb, "IsReadOnlyCaretVisible","True")}\par
\f0\pard\sb180\shading1000{\fs30\b TextBoxTab(shapeName,acceptsTab) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ob eine (Rich)TextBox einen Tab(ulator) akzepiert oder dieser zum n?chsten Steuerelement weiterspringt.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der (Rich)TextBox.}\par
\f0\pard\sb75{\fs24\b acceptsTab}\par
\f0\pard{\fs20 "True" oder "False" (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewContent(shapeName,tree) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ersetzt/Aktualisiert den Ansichtsbaum in einer TreeView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der TreeView Shape.}\par
\f0\pard\sb75{\fs24\b tree}\par
\f0\pard{\fs20 Ein 2D Array mit den TreeView Daten.{\line}{\line}Der erste Index ist die Reihe/Knotennummer. Der zweite Index ist der Index des Elternknoten des aktuellen Knoten (0 f?r oberste Ebene).{\line}Der Arraywert ist der angezeigte Text im betreffenden Knoten:{\line} baum[1][0] = "Ebene 1"{\line} baum[2][1] = "Ebene 1 1"{\line} baum[3][1] = "Ebene 1 2"{\line} baum[4][0] = "Ebene 2"}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewEdit(shapeName,node,editable) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den ?nderungsstatus f?r Text in einem TreeView Knoten.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der TreeView Shape.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 Der auszuw?hlende Knoten.}\par
\f0\pard\sb75{\fs24\b editable}\par
\f0\pard{\fs20 Knotentext (in TextBox) bearbeiten?  "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewExpand(shapeName,node,expand,recursive) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erweitert/Schliesst Knoten in einem TreeView unterhalb des Eingabeknoten.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der TreeView Shapename.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 Knotennummer zum Erweitern/Schlie?en. 0 erweitert/schliesst rekursiv ALLE Knoten.}\par
\f0\pard\sb75{\fs24\b expand}\par
\f0\pard{\fs20 Erweitern oder Schlie?en?  "True" oder "False"}\par
\f0\pard\sb75{\fs24\b recursive}\par
\f0\pard{\fs20 Rekursives Erweitern/Schlie?en der Knoten (aller Unterknoten)?  "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewGetData(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Daten von einem TreeView Baum.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der TreeView Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D Array mit den TreeView Daten.{\line}{\line}Der erste Index ist die Reihe/Knotennummer. Der zweite Index ist der Index des Elternknoten des aktuellen Knoten (0 f?r oberste Ebene).{\line}Der Arraywert ist der angezeigte Text im betreffenden Knoten:{\line} baum[1][0] = "Ebene 1"{\line} baum[2][1] = "Ebene 1 1"{\line} baum[3][1] = "Ebene 1 2"{\line} baum[4][0] = "Ebene 2"}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewGetSelected(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den gew?hlten Knoten in einem TreeView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der TreeView Shapename.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der gew?hlte Knoten der TreeView.}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewItemChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl?nderung in einer TreeView oder Anklicken des gew?hlten Elementes.}\par
\f0\pard\sb180\shading1000{\fs30\b TreeViewSelect(shapeName,node) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 W?hlt einen Knoten in einem TreeView.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der TreeView Shapename.}\par
\f0\pard\sb75{\fs24\b node}\par
\f0\pard{\fs20 Der auszuw?hlende Knoten.}\par
\f0\pard\sb300\shading2000{\fs36\b LDCursors}\par
\f0\pard{\fs20 Setzt ein Mauszeiger-Symbol im GraphicsWindow (entsprechend aktivem Zeigerstil).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 physics-samples\\pool.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Arrow() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pfeil (Normale Auswahl, Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b ArrowCD() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pfeil mit CD Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b CreateCursor(imageName,xHotSpot,yHotSpot) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen Cursor, welcher mittels 'SetUserCursor' oder 'SetShapeCursor' gesetzt werden kann (Intern: Cursor#).{\line}Die Gr??e eines ImageList Bildes kann mit LDImage.Resize angepasst werden.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Der volle Dateipfad zur Bilddatei oder ImageList Name.}\par
\f0\pard\sb75{\fs24\b xHotSpot}\par
\f0\pard{\fs20 Die x-Position des Hotspot Pixels im Cursor ("" f?r 0).}\par
\f0\pard\sb75{\fs24\b yHotSpot}\par
\f0\pard{\fs20 Die y-Position des Hotspot Pixels im Cursor ("" f?r 0).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der erstellte Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b Cross() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kreuz (Pr?zisionsauswahl).}\par
\f0\pard\sb180\shading1000{\fs30\b Hand() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hand (Verkn?pfungsauswahl, Zeigefinger).}\par
\f0\pard\sb180\shading1000{\fs30\b Help() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hilfe (Hilfeauswahl, Pfeil mit Fragezeichen).}\par
\f0\pard\sb180\shading1000{\fs30\b IBeam() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Einf?gemarke (Textauswahl, I).}\par
\f0\pard\sb180\shading1000{\fs30\b Invalid() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Unm?glich/Verboten (Nicht verf?gbar, Verbotstafel).}\par
\f0\pard\sb180\shading1000{\fs30\b None() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kein Mauszeiger (s. Mouse.HideCursor).}\par
\f0\pard\sb180\shading1000{\fs30\b Pen() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stift (Handschrift, F?llfeder).}\par
\f0\pard\sb180\shading1000{\fs30\b Scroll() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Gr??e ?ndern/Verschieben (4Pfeile-Kreuz).}\par
\f0\pard\sb180\shading1000{\fs30\b SetShapeCursor(shapeName,cursor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Cursor f?r eine Shape oder ein Steuerelement, wenn der Mauszeiger dar?ber steht.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b cursor}\par
\f0\pard{\fs20 Ein mittels 'CreateCursor' erstellter oder Standard Cursor aus diesem Objekt (zB. "ArrowCD") oder{\line}voller Pfad zu einer *.cur oder *.ani Datei zur Verwendung als Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b SetUserCursor(cursor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen benutzerdefinierten Cursor als Zeiger im GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b cursor}\par
\f0\pard{\fs20 Ein mittels CreateCursor erstellter oder Standard Cursor aus diesem Objekt (zB. "ArrowCD") oder{\line}voller Pfad zu einer *.cur oder *.ani Datei zur Verwendung als Cursor.}\par
\f0\pard\sb180\shading1000{\fs30\b SizeAll() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Doppelpfeil Kreuz (Gr??en?nderung, Verschieben).}\par
\f0\pard\sb180\shading1000{\fs30\b SizeNESW() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 NO-SW Doppelpfeil Cursor (Gr??en?nderung).}\par
\f0\pard\sb180\shading1000{\fs30\b SizeNS() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 AufAb Doppelpfeil (Gr??en?nderung).}\par
\f0\pard\sb180\shading1000{\fs30\b SizeNWSE() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 NW-SO Doppelpfeil Cursor (Gr??en?nderung).}\par
\f0\pard\sb180\shading1000{\fs30\b SizeWE() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 LinksRechts Doppelpfeil (Gr??en?nderung).}\par
\f0\pard\sb180\shading1000{\fs30\b Starting() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Start (Hintergrundaktivit?t, Pfeil mit Sanduhr).}\par
\f0\pard\sb180\shading1000{\fs30\b UpArrow() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pfeil nach oben (Einf?gemarke).}\par
\f0\pard\sb180\shading1000{\fs30\b Wait() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Warten (Ausgelastet, Sanduhr).}\par
\f0\pard\sb300\shading2000{\fs36\b LDDataBase}\par
\f0\pard{\fs20 SQL Datenbank mit ListView Steuerelement.{\line}ConnectSQLite f?r SQLite Datenbanken (s. http://zetcode.com/db/sqlite  f?r SQLite Befehle).{\line}ConnectMySQL f?r MySQL Datenbanken (s. http://www.mysql.de  f?r MySQL Downloads und Setup).{\line}ConnectSqlServer f?r SqlServer Datenbanken (s. http://www.microsoft.com/de-de/server-cloud/products/sql-server-editions/sql-server-express.aspx f?r SqlServer Downloads und Setup).{\line}ConnectOleDb f?r Access OleDb Datenbanken.{\line}ConnectOdbc f?r Odbc Datenbanken.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDDataBase.sb{\line}http://blogs.msdn.microsoft.com/smallbasic/2014/05/24/small-basic-database-extension{\line}http://blogs.msdn.microsoft.com/smallbasic/2015/10/15/small-basic-featured-program-database-sample}\par

\f0\pard\sb180\shading1000{\fs30\b AddListView(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein datengebundendes ListView Steuerelement zur Datenbankanzeige im GraphicsWindow hinzu (Intern: ListView#, s.a. LDControls.AddListView).{\line}Dient zur schreibgesch?tzten Anzeige einer Datenbankabfrage (s. 'LDControls.AddDataView' mit Bearbeitungsfunktion).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der ListView.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der ListView.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des ListView Steuerelements.}\par
\f0\pard\sb180\shading1000{\fs30\b Command(database,command) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?hrt einen SQLite, MySQL, SqlServer, OleDb oder Odbc Befehl (keine Abfrage) an einer Datenbank durch.{\line}Bei Anzeige der Datenbank in einer DataView gehen ungespeicherte Benutzer?nderungen verloren, wenn die DataView im Anschluss an diese Operation aktualisiert wird.}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 Bezeichnung der bestehenden Datenbank (s. ConnectSQLite, ConnectMySQL, ConnectSqlServer, ConnectOleDb oder ConnectOdbc).}\par
\f0\pard\sb75{\fs24\b command}\par
\f0\pard{\fs20 Der SQL Befehl.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl aktualisierter Reihen.}\par
\f0\pard\sb180\shading1000{\fs30\b Connection \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?bergeht einen SQL Datenbank Verbindungsstring (nur fortgeschrittene Verwendung).{\line}Ist vor der Verbindung zur Datenbank zu setzen, wenn dieser Verbindungsstring anstatt der eingegebenen Verbindungsparameter zu verwenden ist.{\line}Standard: "" (nicht verwendet).}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectMySQL(server,user,password,database) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbinden zu einer MySQL Datenbank (Intern: DataBase#).{\line}Dies ist vor allen weiteren SQL Methoden aufzurufen.{\line}Der MySQL Dienst mu? laufen und die Datenbank (mitsamt Anmeldeinformationen) bereits erstellt sein. Im Zweifel verwende SQLite.}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 Der MySQL Server (zB. "localhost" bzw. "127.0.0.1").}\par
\f0\pard\sb75{\fs24\b user}\par
\f0\pard{\fs20 Der MySQL Benutzername.}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 Das MySQL Benutzerpasswort oder "".}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 Der Name der MySQL Datenbank.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Bezeichnung zur Identifizierung der Datenbank.}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectOdbc(driver,server,port,user,password,option,database) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbinden zu einer Odbc Treiber verbundenen Datenbank (Intern: DataBase#).{\line}Dies ist vor allen weiteren SQL Methoden aufzurufen.{\line}Der Odbc Dienst mu? laufen und die Datenbank (mitsamt Anmeldeinformationen) bereits erstellt sein. Im Zweifel verwende SQLite.}\par
\f0\pard\sb75{\fs24\b driver}\par
\f0\pard{\fs20 Der Odbc Treiber (zB. "{MySQL ODBC 3.51 Driver}").}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 Der Odbc Server (zB. "localhost").}\par
\f0\pard\sb75{\fs24\b port}\par
\f0\pard{\fs20 Die Odbc Portnummer.}\par
\f0\pard\sb75{\fs24\b user}\par
\f0\pard{\fs20 Der Odbc Benutzername.}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 Das Odbc Benutzerpasswort.}\par
\f0\pard\sb75{\fs24\b option}\par
\f0\pard{\fs20 Die Odbc Optionsnummer zur Steuerung der Odbc Verbindung (zB. 0 oder 3).}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 Der Name der Odbc Datenbank.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Bezeichnung zur Identifizierung der Datenbank.}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectOleDb(provider,server,database) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbinden zu einer Access OleDb Datenbank (Intern: DataBase#).{\line}Dies ist vor allen weiteren SQL Methoden aufzurufen.{\line}Der Access OleDb Dienst mu? laufen und die Datenbank (mitsamt Anmeldeinformationen) bereits erstellt sein. Im Zweifel verwende SQLite.}\par
\f0\pard\sb75{\fs24\b provider}\par
\f0\pard{\fs20 Der OleDb Anbieter (zB. "SQLOLEDB").}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 Der OleDb Server (zB. "localhost").}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 Der Name der OleDb Datenbank.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Bezeichnung zur Identifizierung der Datenbank.}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectSQLite(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt oder ?ffnet eine SQLite Datenbank (Intern: DataBase#).{\line}Dies ist vor allen weiteren SQL Methoden aufzurufen.{\line}Wird eine Tabelle erstellt, so mu? deren erste Spalte "Id INTEGER PRIMARY KEY" sein.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad zur SQLite Datenbankdatei (gew?hnlich mit Erweiterung .db).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Bezeichnung zur Identifizierung der Datenbank.}\par
\f0\pard\sb180\shading1000{\fs30\b ConnectSqlServer(server,database) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbinden zu einer SqlServer Datenbank (Intern: DataBase#).{\line}Dies ist vor allen weiteren SQL Methoden aufzurufen.{\line}Der SqlServer Dienst mu? laufen und die Datenbank (mitsamt Anmeldeinformationen) bereits erstellt sein. Im Zweifel verwende SQLite.}\par
\f0\pard\sb75{\fs24\b server}\par
\f0\pard{\fs20 Der SqlServer Server (zB. "(local)\\SQLEXPRESS").}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 Der Name der SqlServer Datenbank.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Bezeichnung zur Identifizierung der Datenbank.}\par
\f0\pard\sb180\shading1000{\fs30\b EditTable(database,table,dataview) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Anzeige einer Datenbanktabelle zur Bearbeitung in einem 'LDControls' DataView Steuerelement.{\line}Bei Verwendung dieser Methode ist die Datenbank an das DataView Steuerelement gebunden und wird darin gespiegelt.}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 Die Bezeichnung der bestehenden Datenbank (s. ConnectSQLite, ConnectMySQL, ConnectSqlServer, ConnectOleDb oder ConnectOdbc).}\par
\f0\pard\sb75{\fs24\b table}\par
\f0\pard{\fs20 Der Tabellenname f?r die Anzeige und Bearbeitung.}\par
\f0\pard\sb75{\fs24\b dataview}\par
\f0\pard{\fs20 Der Name des DataView Steuerelements.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetDB() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine (nur Lesen) Liste von Datenbanken zur Verwendung au?erhalb von SmallBasic.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 IReadOnlyList/}\par
\f0\pard\sb75{\fs24\b DataBase}\par
\f0\pard{\fs20 }\par
\f0\pard\sb180\shading1000{\fs30\b Query(database,query,listview,getRecords) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?hrt eine SQLite, MySQL, SqlServer, OleDb oder Odbc Abfrage (keinen Befehl) an einer Datenbank durch.}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 Bezeichnung der bestehenden Datenbank (s. ConnectSQLite, ConnectMySQL, ConnectSqlServer, ConnectOleDb oder ConnectOdbc).}\par
\f0\pard\sb75{\fs24\b query}\par
\f0\pard{\fs20 Die SQL Abfrage. zB. "SELECT * FROM myTable;".}\par
\f0\pard\sb75{\fs24\b listview}\par
\f0\pard{\fs20 Eine ListView, um diese mit dem Abfrageergebnis aufzuf?llen oder "" f?r keine.}\par
\f0\pard\sb75{\fs24\b getRecords}\par
\f0\pard{\fs20 Optionale R?ckgabe eines Arrays mit den Ergebnissen?  "True" oder "False".{\line}Beachte, da? gro?e mehrdimensionale Arrays in SB langsam sind.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Optionaler Array mit den Ergebnissen oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b SaveTable(database,dataview) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?bernimmt ?nderungen in einer 'LDControls' DataView in die Datenbank.}\par
\f0\pard\sb75{\fs24\b database}\par
\f0\pard{\fs20 Die Bezeichnung der bestehenden Datenbank (s. ConnectSQLite, ConnectMySQL, ConnectSqlServer, ConnectOleDb oder ConnectOdbc).}\par
\f0\pard\sb75{\fs24\b dataview}\par
\f0\pard{\fs20 Der Name des DataView Steuerelements.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDDateTime}\par
\f0\pard{\fs20 Zeit- und Datumskonvertierungen.{\line}{\line}Datumsformat ist "25.01.2012 22:18:52" (DE) und h?ngt von lokalen Benutzereinstellungen ab.{\line}Der Zeitteil ist optional.{\line}Format f?r USA w?re zB. "01/25/2012 22:18:52".{\line}{\line}Ein OADatum (OLE Automation Date) zeigt die Anzahl der Tage (incl. Teile angebrochener Tage), die seit 30. Dez 1899 vergangen sind. Somit lassen sich Daten einfach addieren oder subtrahieren.}\par

\f0\pard\sb180\shading1000{\fs30\b Add(date,offset) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ein Datum aus einem angegebenen Datum und einem gegebenen Zeitraum in Tagen.}\par
\f0\pard\sb75{\fs24\b date}\par
\f0\pard{\fs20 Ein bestimmtes Datum.}\par
\f0\pard\sb75{\fs24\b offset}\par
\f0\pard{\fs20 Der -/+ Zeitraum in Tagen.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das Zieldatum, resultierend aus vorgegebenem Datum und gegebener Differenz an Tagen.{\line}{\line}Datumsformat ist "25.01.2012 22:18:52" (DE), wobei der Zeitteil optional ist.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDDateTime.Add("30.November 2011", 50){\line}Werden dem 30.November 2011 zB. 50 Tage hinzuaddiert, erh?lt man den 19.J?nner 2012 (zB. als "19.01.12 00:00:00").}\par
\f0\pard\sb180\shading1000{\fs30\b FromOADate(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert ein OADatum zu einem 'gew?hnlichen' Datum.}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das zu konvertierende OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das Datum in gew?hnlicher Schreibweise.{\line}{\line}Datumsformat ist "25.01.2012 22:18:52" (DE), wobei der Zeitteil optional ist.{\line}Der Datumsteil h?ngt von lokalen Einstellungen ab, f?r USA zB. "01/25/2012".}\par
\f0\pard\sb180\shading1000{\fs30\b GetDay(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Tageszahl (im Monat) aus einem OADatum (vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Tageszahl im Monat (1 bis 31).}\par
\f0\pard\sb180\shading1000{\fs30\b GetDayName(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Wochentagname aus einem OADatum (vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wochentagname (zB. Montag).}\par
\f0\pard\sb180\shading1000{\fs30\b GetHour(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Stunde aus einem OADatum (vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Stunde (0 bis 23).}\par
\f0\pard\sb180\shading1000{\fs30\b GetMinute(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Minute aus einem OADatum (vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Minute (0 bis 59).}\par
\f0\pard\sb180\shading1000{\fs30\b GetMonth(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Monatszahl aus einem OADatum (vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Monatszahl (1 bis 12).}\par
\f0\pard\sb180\shading1000{\fs30\b GetMonthName(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Monatsname aus einem OADatum (vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Monatsname (zB. J?nner).}\par
\f0\pard\sb180\shading1000{\fs30\b GetSecond(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Sekunde aus einem OADatum (vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Sekunde (0 bis 59).}\par
\f0\pard\sb180\shading1000{\fs30\b GetYear(OAdate) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Jahreszahl aus einem OADatum (vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b OAdate}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Jahreszahl.}\par
\f0\pard\sb180\shading1000{\fs30\b Now() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das aktuelle Datum und Uhrzeit.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das aktuelle Datum und Uhrzeit [TT.MM.JJ hh:mm:ss].{\line}{\line}Datumsformat ist "25.01.2012 22:18:52" (DE), f?r USA zB. "01/25/2012 22:18:52")}\par
\f0\pard\sb180\shading1000{\fs30\b NowOADate() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das aktuelle OADatum.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der seit 30. Dez 1899 vergangenen und angebrochenen Tage [ttttt.ffffffffff].}\par
\f0\pard\sb180\shading1000{\fs30\b OADate(year,month,day,hour,minute,second) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das OADatum (vergangene und angebrochene Tage seit 30. Dez 1899) aus einzelnen Datums- und Zeitangaben.}\par
\f0\pard\sb75{\fs24\b year}\par
\f0\pard{\fs20 Die Jahreszahl (als JJJJ, zB. 2014).}\par
\f0\pard\sb75{\fs24\b month}\par
\f0\pard{\fs20 Die Monatsnummer (zB. 4 od. 04).}\par
\f0\pard\sb75{\fs24\b day}\par
\f0\pard{\fs20 Die Nummer des Tages (zB. 4 od. 04).}\par
\f0\pard\sb75{\fs24\b hour}\par
\f0\pard{\fs20 Die Stunde (0 bis 23).}\par
\f0\pard\sb75{\fs24\b minute}\par
\f0\pard{\fs20 Die Minute (0 bis 59).}\par
\f0\pard\sb75{\fs24\b second}\par
\f0\pard{\fs20 Die Sekunde (0 bis 59).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das OADatum (Vergangene und angebrochene Tage seit 30. Dez 1899).}\par
\f0\pard\sb180\shading1000{\fs30\b Subtract(date1,date2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der Tage zwischen zwei Kalenderdaten (Der Zeitteil ist optional).}\par
\f0\pard\sb75{\fs24\b date1}\par
\f0\pard{\fs20 Das erste Kalenderdatum/-zeit (sp?ter).}\par
\f0\pard\sb75{\fs24\b date2}\par
\f0\pard{\fs20 Das zweite Kalenderdatum/-zeit (fr?her).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Differenz als ganze und ev. angebrochene Tage (date1-date2). F?r pos. Ergebnis, date1>date2 w?hlen.}\par
\f0\pard\sb180\shading1000{\fs30\b ToOADate(date) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert ein Datum (gew?hnliche Schreibweise) zu einem OADatum.}\par
\f0\pard\sb75{\fs24\b date}\par
\f0\pard{\fs20 Das zu konvertierende Datum (zB. Clock.Date, "02.8.14", "9.Aug.2014", "02.Februar.14" oder LDDateTime.Now){\line}{\line}Datumsformat ist "25.01.2012 22:18:52" (DE), wobei der Zeitteil optional ist.{\line}Der Datumsteil h?ngt von lokalen Einstellungen ab, f?r USA zB. "01/25/2012".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das OADatum als Anzahl vergangener und angebrochener Tage seit 30. Dez 1899.}\par
\f0\pard\sb300\shading2000{\fs36\b LDDebug}\par
\f0\pard{\fs20 Hilfsfunktionen zur Fehlersuche (Debugging).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 debug\\*.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Break(label) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt an dieser Stelle manuell einen Breakpoint, an dem der Programmablauf angehalten wird und Variablen ?berpr?ft werden k?nnen.}\par
\f0\pard\sb75{\fs24\b label}\par
\f0\pard{\fs20 Die Bezeichnung f?r den Breakpoint.{\line}Dies sollte ein String (in "", zB. "MeineMarkierung01") oder eine Indexnummer sein.{\line}Jede Bezeichnung sollte einmalig sein, dh. jeder Breakpoint erh?lt eine eigene Markierung.{\line}F?r Breakpoints innerhalb Ereignis-Subs bestehen einige Einschr?nkungen.}\par
\f0\pard\sb180\shading1000{\fs30\b Instrument(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine gleichnamige Datei 'NAME_debug.sb' mit automatisch eingesetzten Breakpoints.{\line}{\line}Danach diese Datei in SB-IDE laden und zur Fehlersuche starten.{\line}Bei Auftreten eines Problems, kann das Original leicht korrigiert werden. Danach erneut 'LDDebug.Instrument' aufrufen um diese korrigierte Datei weiter zu untersuchen.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu debuggenden Originaldatei (*.sb).}\par
\f0\pard\sb180\shading1000{\fs30\b Start() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet eine 'Debugging Sitzung' ('Debug SmallBasic' GUI wird dabei angezeigt).{\line}Gew?hnlich steht dieser Befehl in der ersten Programmzeile.{\line}Breakpoints (Zeilen an denen der Programmablauf unterbrochen wird) werden gew?hnlich vor Programmstart manuell eingetragen (LDDebug.Break). Die Methode 'LDDebug.Instrument' setzt diese Breakpoints allerdings auch automatisch ein.}\par
\f0\pard\sb300\shading2000{\fs36\b LDDialogs}\par
\f0\pard{\fs20 Diese Klasse bietet verschiedene Methoden f?r Steuerelemente, Dialoge und Popup-Fenster.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\ClockWidget.sb, RichTextBox.sb, RightClickMenu.sb}\par

\f0\pard\sb180\shading1000{\fs30\b AddRightClickMenu(items,images) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Rechtsklick-Kontextmen? f?r das GraphicsWindow hinzu (s.a. LDControls.AddContextMenu). GraphicsWindow MUSS initialisiert sein.{\line}Ein-/Ausblenden durch (Rechts)klick oder 'Apps' Taste.}\par
\f0\pard\sb75{\fs24\b items}\par
\f0\pard{\fs20 Die Titel der Auswahlpunkte im Kontextmen? als Array.}\par
\f0\pard\sb75{\fs24\b images}\par
\f0\pard{\fs20 Optionaler Array von Bildsymbolen. Jeder oder alle k?nnen "" sein. zB. Ergebnis von ImageList.LoadImage, lokale oder Netzwerk-Bilddatei.}\par
\f0\pard\sb180\shading1000{\fs30\b Calendar(start) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Popup-Kalender zur Auswahl eines Datums. Doppelklick oder Eingabe-Taste zur Auswahl eines Datums.}\par
\f0\pard\sb75{\fs24\b start}\par
\f0\pard{\fs20 Das zun?chst angezeigte Datum (zB. "TT.MM.JJ"). "" f?r aktuelles (heute).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das gew?hlte Datum in der Form TT.MM.JJ 00:00:00, das Startdatum bei Abbruch.}\par
\f0\pard\sb180\shading1000{\fs30\b Colour() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Anzeige des Dialogfensters zur Farbauswahl (s. LDColours).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die gew?hlte Farbe als #RRGGBB HexWert oder SB-Farbname (CSS3-Farbname, zB. Red) wenn zutreffend. "" bei Abbruch.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/System.Windows.Media.Colors.aspx{\line}http://i.msdn.microsoft.com/dynimg/IC24340.png}\par
\f0\pard\sb180\shading1000{\fs30\b Confirm(text,title) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt einen Mitteilungsdialog mit Buttons 'Ja', 'Nein' und 'Abbruch' (mit Fragezeichensymbol) und wartet auf Best?tigung. Erlaubt Tastendr?cke 'J?', 'N?', 'Escape (Cancel)', 'Space/Return (J?)'. Unabh?ngig vom GW.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der Mitteilungs-/Abfragetext im Dialogfenster.}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 Der Titel des Dialogfensters.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "Yes", "No" oder "Cancel" f?r den gedr?ckten Button. "Cancel" bei Schlie?en per 'X' Feld.}\par
\f0\pard\sb180\shading1000{\fs30\b EndWait() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schliesst das 'Bitte warten!' Popup-Fenster wieder.}\par
\f0\pard\sb180\shading1000{\fs30\b Font(font) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Anzeige des Dialogfensters zur Auswahl einer Schriftart.}\par
\f0\pard\sb75{\fs24\b font}\par
\f0\pard{\fs20 Die vorgew?hlten Schrifteigenschaften als Array (gleiches Format wie R?ckgabearray) oder "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Abbruch, sonst die gew?hlten Schrifteigenschaften als Array:{\line}schrift[1]	Schriftname{\line}schrift[2]	Schriftgr??e{\line}schrift[3]	Schriftstil Fett?  "True" oder "False"{\line}schrift[4]	Schriftstil Kursiv?  "True" oder "False"}\par
\f0\pard\sb180\shading1000{\fs30\b GetFolder(initialFolder) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dialog zur Auswahl eines Ordners (Verzeichnisses, s. 'LDShell.SelectFolder').}\par
\f0\pard\sb75{\fs24\b initialFolder}\par
\f0\pard{\fs20 Der Startordner oder "" f?r den zuletzt gew?hlten Ordner bzw. Arbeitsplatz. F?r Ordner unter den Benutzerprofilen ist C:\\Documents and Settings\\.. statt C:\\Users\\.. anzugeben (W7).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der volle gew?hlte Ordnerpfad oder "" bei Abbruch.}\par
\f0\pard\sb180\shading1000{\fs30\b LastRightClickMenuItem \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der Index des zuletzt im Rechtsklick-Kontextmen? gew?hlten Auswahlpunktes.}\par
\f0\pard\sb180\shading1000{\fs30\b OpenFile(extension,folder) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Datei-?ffnen Dialog zum ?ffnen einer bestehenden Datei (url, lnk nicht).}\par
\f0\pard\sb75{\fs24\b extension}\par
\f0\pard{\fs20 Die Dateierweiterung (ohne Punkt) zum ?ffnen zB."sb" oder "*".{\line}Oder Array mit Erweiterungen zB. "1=jpg;2=png;" (Standard: extension[1]).{\line}Nach einem "|" Trennzeichen werden Erweiterungen direkt verwendet. zB. "Bilddateien|*.bmp;*.gif;*.jpg;*.png|Alle Dateien (*.*)|*.*".{\line}"" zeigt nur Ordner und Verkn?pfungen (lnk, url).}\par
\f0\pard\sb75{\fs24\b folder}\par
\f0\pard{\fs20 Der Startordner bei ?ffnen des Dialogs. "" f?r aktuellen/letzten Ordner.{\line}Unter Benutzerprofilen ?ffnet ev. entsprechende Bibliothek, sonst f?r Direktpfad hier C:\\Documents and Settings\\.. statt C:\\Users\\.. angeben (W7).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der volle existierende Dateipfad oder "" bei Abbruch.}\par
\f0\pard\sb180\shading1000{\fs30\b RightClickMenu \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auswahl eines Punktes im Rechtsklick-Kontextmen?.}\par
\f0\pard\sb180\shading1000{\fs30\b SaveFile(extension,folder) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Datei-Speichern Dialog bzw. Erstellen einer neuen Datei. Mit R?ckfrage/Best?tigung wenn Datei bereits besteht.}\par
\f0\pard\sb75{\fs24\b extension}\par
\f0\pard{\fs20 Die Dateierweiterung (ohne Punkt) zum Speichern zB."sb" oder "*".{\line}Oder Array mit Erweiterungen zB. "1=jpg;2=png;" (Standard: extension[1]).{\line}Nach einem "|" Trennzeichen werden Erweiterungen direkt verwendet. zB. "Bilddateien|*.bmp;*.gif;*.jpg;*.png|Alle Dateien (*.*)|*.*".{\line}"" zeigt nur Ordner und Verkn?pfungen (lnk, url).}\par
\f0\pard\sb75{\fs24\b folder}\par
\f0\pard{\fs20 Der Startordner bei ?ffnen des Dialogs, "" f?r aktuellen/letzten Ordner.{\line}Unter Benutzerprofilen ?ffnet ev. entsprechende Bibliothek, sonst f?r Direktpfad hier C:\\Documents and Settings\\.. statt C:\\Users\\.. angeben (W7).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der volle gew?hlte Dateipfad oder "" bei Abbruch.}\par
\f0\pard\sb180\shading1000{\fs30\b SetStartupPosition(x,y,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Startkoordinaten (linke obere Ecke) f?r die meisten Dialoge. Ist vor dem Dialogaufruf zu setzen.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate.}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 Der Bezugsmodus:{\line}0  Inaktiv (Standard).{\line}1  Koordinaten relativ zum GraphicsWindow (gem?? GW.MouseX/.MouseY).{\line}2  Koordinaten relativ zum Bildschirm (gem?? Desktop.MouseX/.MouseY).}\par
\f0\pard\sb180\shading1000{\fs30\b ToolTip(shapeName,tip) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen Tooltip (Infotip Kontexthilfe) f?r ein gew?hnliches Shape oder Steuerelement.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b tip}\par
\f0\pard{\fs20 Der im Tooltip anzuzeigende Text (Systemstandard f?r Farbe und Schrifteigenschaften).}\par
\f0\pard\sb180\shading1000{\fs30\b Wait(text,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt ein rahmenloses 'Bitte warten!' Popup-Fenster mit einer Nachricht (ohne Button). GW wird w?hrenddessen blockiert.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Die anzuzeigende Nachricht im Popup Fenster.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Randfarbe des Popup-Fensters, "" f?r lokale Systemeinstellung.}\par
\f0\pard\sb300\shading2000{\fs36\b LDDictionary}\par
\f0\pard{\fs20 Diese Klasse erm?glicht den Zugriff auf einen Online Lexikon-Dienst.{\line}Alternative f?r das SB Dictionary Objekt (Fehlschlag in SB 1.0).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://rr.office.microsoft.com/Research/query.asmx (Research WebService)}\par

\f0\pard\sb180\shading1000{\fs30\b GetDefinition(word) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Definition zu einem Wort in Englisch.}\par
\f0\pard\sb75{\fs24\b word}\par
\f0\pard{\fs20 Das zu definierende Wort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Definition(en) zum angegebenen Begriff bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetDefinitionInFrench(word) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Definition zu einem Wort in Franz?sisch.}\par
\f0\pard\sb75{\fs24\b word}\par
\f0\pard{\fs20 Das zu definierende Wort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Definition(en) zum angegebenen Begriff bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetDefinitionInSpanish(word) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Definition zu einem Wort in Spanisch.}\par
\f0\pard\sb75{\fs24\b word}\par
\f0\pard{\fs20 Das zu definierende Wort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Definition(en) zum angegebenen Begriff bei Erfolg, sonst "".}\par
\f0\pard\sb300\shading2000{\fs36\b LDEffect}\par
\f0\pard{\fs20 Anwenden visueller Effekte f?r eine beliebige Shape (zB. "_turtle" Bild) oder Control/Steuerelement.}\par

\f0\pard\sb180\shading1000{\fs30\b Bloom(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Gl?heffekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}BaseIntensity	(Strd: 1){\line}BaseSaturation	(Strd: 1){\line}BloomIntensity	(Strd: 1.25){\line}BloomSaturation	(Strd: 1){\line}Threshold	(Strd: 0.25)}\par
\f0\pard\sb180\shading1000{\fs30\b Blur(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Verwischungseffekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}KernelType (Strd: "Gaussian", "Box"){\line}Radius	     (Strd: 5)}\par
\f0\pard\sb180\shading1000{\fs30\b Clear(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht angewendete Effekte von einer Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape deren Effekte zu entfernen sind.}\par
\f0\pard\sb180\shading1000{\fs30\b ColourTone(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Einf?rbungseffekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}Desaturation (Strd: 0.5){\line}ToneAmount (Strd: 0.5){\line}LightColor     (Strd: "#FFE580"){\line}DarkColor      (Strd: "#338000")}\par
\f0\pard\sb180\shading1000{\fs30\b DropShaddow(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen perspektivischen Schlagschatten Effekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}BlurRadius	(Strd: 5){\line}Color		(Strd: "Black"){\line}Direction	(Strd: 315){\line}Opacity		(Strd: 1){\line}ShadowDepth	(Strd: 5)}\par
\f0\pard\sb180\shading1000{\fs30\b Embossed(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Pr?geeffekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}Amount	(Standard: 3){\line}Color	(Standard: "Gray"){\line}Height	(Standard: 0.001)}\par
\f0\pard\sb180\shading1000{\fs30\b Magnify(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Lupeneffekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}Amount	      (Strd: 0.5){\line}Center	      (Strd: "X=0.5;Y=0.5;"){\line}InnerRadius  (Strd: 0.2){\line}OuterRadius (Strd: 0.4)}\par
\f0\pard\sb180\shading1000{\fs30\b Monochrome(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Farbfilter Effekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}Color  (Standard: "White")}\par
\f0\pard\sb180\shading1000{\fs30\b Pixelate(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Verpixelungseffekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}Pixelation  (Standard: 0.75)}\par
\f0\pard\sb180\shading1000{\fs30\b Ripple(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Welleneffekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}Center	    (Strd: "X=0.5;Y=0.5;"){\line}Frequency  (Strd: 40){\line}Magnitude (Strd: 0.1){\line}Phase	    (Strd: 10)}\par
\f0\pard\sb180\shading1000{\fs30\b Sharpen(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Bildsch?rfe Effekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}Amount	(Standard: 2){\line}Height	(Standard: 0.0005)}\par
\f0\pard\sb180\shading1000{\fs30\b Swirl(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet einen Wirbeleffekt f?r eine Shape an.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array optionaler Eigenschaften (indexiert durch Eigenschaftsname) oder "":{\line}AngleFrequency	(Strd: 45){\line}Center		(Strd: "X=0.5;Y=0.5;"){\line}TwistAmount	(Strd: 10)}\par
\f0\pard\sb300\shading2000{\fs36\b LDEmail}\par
\f0\pard{\fs20 Methoden zum Senden von eMails.}\par

\f0\pard\sb180\shading1000{\fs30\b Attachment \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Dateipfad f?r optionalen eMail-Anhang oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b Body \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Nachrichtentext der eMail.}\par
\f0\pard\sb180\shading1000{\fs30\b From \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die eMail-Adresse des Absenders.}\par
\f0\pard\sb180\shading1000{\fs30\b Password \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das Passwort f?r das eMail-Senderkonto .}\par
\f0\pard\sb180\shading1000{\fs30\b Port \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die SMTP Portnummer (Standard: 587).}\par
\f0\pard\sb180\shading1000{\fs30\b Recipient \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die eMail-Adresse des Empf?ngers.}\par
\f0\pard\sb180\shading1000{\fs30\b Send() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Versenden einer eMail per SMTP Server.{\line}Voreingestellter SMTP Klient ist "smtp.gmail.com" und voreingestellter Port ist 587. Folgende und auch weitere eMail-Klienten k?nnen ebenso funktionieren:{\line}"smtp.live.com" (Hotmail){\line}"smtp.mail.yahoo.com"{\line}{\line}Ein Minimum der "From, Password und Recipient"- Eigenschaften mu? zuerst festgelegt werden.{\line}Die "From" und "Password"-Eigenschaften sollten den LogIn-Daten des eMail-Anbieters entsprechen.{\line}Zus?tzlich sollten "Subject" (Betreff) und "Body" (Textinhalt der eMail) festgelegt werden.{\line}Die "Attachment" (Anhang)-Eigenschaft kann optional einen Dateipfad oder "" f?r keinen Anhang enthalten.{\line}{\line}Es kann nicht mehr als EINE eMail/min versandt werden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst eine Fehlermeldung.}\par
\f0\pard\sb180\shading1000{\fs30\b Server \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die SMTP Serveradresse (Standard: "smtp.gmail.com").}\par
\f0\pard\sb180\shading1000{\fs30\b Subject \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den 'Betreff' Text (Standard: "Email from SmallBasic").}\par
\f0\pard\sb180\shading1000{\fs30\b UseSSL \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Verwendung einer sicheren ?bertragung?  "True" (Standard) oder "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDEncryption}\par
\f0\pard{\fs20 Methoden zur Dateiverschl?sselung (Ver-/Entschl?sseln von Text oder Passwort) und Generieren von Pr?fsummen.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples/LDEncryption.sb}\par

\f0\pard\sb180\shading1000{\fs30\b AESDecrypt(cypher,password) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entschl?sselt einen AES verschl?sselten Cipher (zuvor verschl?sselt) durch einen Passwortschl?ssel.}\par
\f0\pard\sb75{\fs24\b cypher}\par
\f0\pard{\fs20 Der verschl?sselte Text (Cipher).}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 Der Passwortschl?ssel von der Verschl?sselung.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der unverschl?sselte Originaltext oder "", falls Passwort und Cipher nicht kombinieren.}\par
\f0\pard\sb180\shading1000{\fs30\b AESEncrypt(source,password) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschl?sselt einen Text mittels AES Verschl?sselung und einem Passwortschl?ssel.{\line}Der verschl?sselte Text kann daraufhin in einer Datei gespeichert werden.{\line}Beachte, da? bei Verlust des Passwortes KEINE M?GLICHKEIT der Entschl?sselung mehr besteht!}\par
\f0\pard\sb75{\fs24\b source}\par
\f0\pard{\fs20 Der zu verschl?sselnde Text.}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 Der Passwortschl?ssel f?r die Verschl?sselung oder "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der verschl?sselte Text (Cipher).}\par
\f0\pard\sb180\shading1000{\fs30\b MD5Hash(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen 32-stelligen MD5Hash f?r den angegebenen Text. String-Checksumme (http://de.wikipedia.org/wiki/MD5){\line}Der Hash kann daraufhin in eine Datei gespeichert werden.{\line}Dieser 32-stellige Hash empfiehlt sich, wo ein allgemeiner oder k?rzerer Hash erforderlich ist (Passwort oder Datenintegrit?t).}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der Text f?r den der MD5Hash generiert wird (oft ein Passwort).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der 32-stellige Hex-MD5Hash.}\par
\f0\pard\sb180\shading1000{\fs30\b MD5HashFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen MD5Hash f?r eine angegebene Datei.{\line}Dieser 32-stellige Hash dient zur Integrit?tspr?fung von Dateidaten (zB. ob der Dateiinhalt ver?ndert wurde).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad zur Ermittlung des Hashwertes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der 32-stellige Hex MD5 Hash.}\par
\f0\pard\sb180\shading1000{\fs30\b RSADecrypt(encrypted) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entschl?sselt eine RSA Nachricht.{\line}Erfordert, da? ein pers?nlicher Schl?ssel gesetzt ist.{\line}Ist keiner gesetzt, so wird nur f?r diese Sitzung ein Schl?ssel erstellt und verwendet.}\par
\f0\pard\sb75{\fs24\b encrypted}\par
\f0\pard{\fs20 Die verschl?sselte Nachricht.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der unverschl?sselte Originaltext.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAEncrypt(unencrypted) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschl?sselt eine RSA Nachricht.{\line}Erfordert, da? ein ?ffentlicher Schl?ssel gesetzt ist (Jeder kann mit ?ffentlichem Schl?ssel verschl?sseln).{\line}Ist keiner gesetzt, so wird nur f?r diese Sitzung ein Schl?ssel erstellt und verwendet.}\par
\f0\pard\sb75{\fs24\b unencrypted}\par
\f0\pard{\fs20 Der zu verschl?sselnde Text.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die verschl?sselte Nachricht.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAPrivateKey \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt einen pers?nlichen RSA Schl?ssel.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAPublicKey \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt einen ?ffentlichen RSA Schl?ssel.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAReset() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ersetzt den pers?nlichen und ?ffentlichen Schl?ssel (Zufallsprinzip).}\par
\f0\pard\sb180\shading1000{\fs30\b RSASign(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Signiert eine RSA Nachricht.{\line}Erfordert, da? ein pers?nlicher Schl?ssel gesetzt ist (Nur der Verfasser kann mit pers?nlichem Schl?ssel signieren).{\line}Ist keiner gesetzt, so wird nur f?r diese Sitzung ein Schl?ssel erstellt und verwendet.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die zu signierende Nachricht.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Signierung f?r die Nachricht.}\par
\f0\pard\sb180\shading1000{\fs30\b RSAVerify(data,sign) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verifiziert eine signierte RSA Nachricht.{\line}Erfordert, da? ein ?ffentlicher Schl?ssel gesetzt ist (Jeder kann mit ?ffentlichem Schl?ssel verifizieren).{\line}Ist keiner gesetzt, so wird nur f?r diese Sitzung ein Schl?ssel erstellt und verwendet.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die signierte Nachricht.}\par
\f0\pard\sb75{\fs24\b sign}\par
\f0\pard{\fs20 Die Signierung f?r die Nachricht.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SHA512Hash(password) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen SHA2-512 Hash f?r eine Texteingabe.{\line}Dieser 128-stellige Hash empfiehlt sich zur sichersten Passwortverschl?sselung.}\par
\f0\pard\sb75{\fs24\b password}\par
\f0\pard{\fs20 Der Text f?r den der Hash generiert wird (oft ein Passwort).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der 128-stellige Hex-SHA512 Hash.}\par
\f0\pard\sb180\shading1000{\fs30\b SHA512HashFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen SHA512 Hash f?r eine angegebene Datei.{\line}Dieser 128-stellige Hash dient zur Integrit?tspr?fung von Dateidaten (zB. Dateiinhalt (un)ver?ndert).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad zur Ermittlung des Hashwertes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der 128-stellige Hex SHA512 Hash.}\par
\f0\pard\sb300\shading2000{\fs36\b LDEvents}\par
\f0\pard{\fs20 Zus?tzliche Ereignisaufrufe f?r Maus, GraphicsWindow und Dateisystem.{\line}F?r weitere Tastaturereignisse s. LDTextWindow.KeyDown und .KeyUp (mit .LastKey, LowLevel f?r GW u/o TW dh. auch OHNE Fensterfokus).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 graph_samples\\graph-shapes.sb, graph-statistics.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Error \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Auftreten eines Fehlers bei einer LD Methode (LitDev Erweiterung).{\line}Dies ist zus?tzlich zu Warnungen im TextWindow, welche mit LDUtilties.ShowErrors, LDUtilties.ShowFileErrors und LDUtilties.ShowNoShapeErrors abgeschaltet werden k?nnen.}\par
\f0\pard\sb180\shading1000{\fs30\b FileChange \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn eine Datei erstellt, ge?ndert oder gel?scht wurde.{\line}Das Verzeichnis (s. FilePath) und Dateifilter (s. FileFilter) m?ssen zuvor festgelegt werden, damit dieses Ereignis registriert werden kann.}\par
\f0\pard\sb180\shading1000{\fs30\b FileFilter \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Dateifilter f?r die mit LDEvents.FileChange zu ?berwachenden Dateitypen (Standard: "*.*").}\par
\f0\pard\sb180\shading1000{\fs30\b FilePath \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das Stammverzeichnis welches von LDEvents.FileChange zu ?berwachen ist (Standard: "C:").}\par
\f0\pard\sb180\shading1000{\fs30\b LastError \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Inhalt der letzten aufgetretenen Fehlermeldung.}\par
\f0\pard\sb180\shading1000{\fs30\b LastFileChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den vollen Pfad der zuletzt ge?nderten Datei.}\par
\f0\pard\sb180\shading1000{\fs30\b LastFileChangeType \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Art der letzten ?nderung ("Created", "Changed" oder "Deleted" falls die letzte Datei erstellt, ge?ndert oder gel?scht wurde).}\par
\f0\pard\sb180\shading1000{\fs30\b LastMouseWheelDelta \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die letzte Drehrichtung des Mausrades im GraphicsWindow (1/-1 f?r auf/ab bzw. vor/zur?ck, je Schritt).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'GW/Bild/Shape zoomen:{\line}f = 1	'Faktor{\line}dZ = 1.1	'Zoom delta{\line}w = GraphicsWindow.Width{\line}h = GraphicsWindow.Height{\line}LDEvents.MouseWheel = OnWheel{\line}{\line}Sub OnWheel{\line}  f = f * Math.Power(dZ, LDEvents.LastMouseWheelDelta){\line}  f = Math.Round(100*f)/100	'2 Dez.{\line}  GraphicsWindow.Width = f*w{\line}  GraphicsWindow.Height = f*h{\line}EndSub}\par
\f0\pard\sb180\shading1000{\fs30\b MouseDoubleClick \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein (nur) Doppelklick im GraphicsWindow erfolgt (sowohl Doppelklick links wie rechts, ZeitDiff gem?? Systemeinstellung 500 ms).}\par
\f0\pard\sb180\shading1000{\fs30\b MouseWheel \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn das Mausrad im GraphicsWindow gedreht wird (nicht bei Klick auf Mausrad, s. 'LastMouseWheelDelta').}\par
\f0\pard\sb180\shading1000{\fs30\b Resized \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn die Gr??e des GraphicsWindow ge?ndert wird (auch f?r 'Maximieren' und 'Verkleinern', nicht bei 'Minimieren').}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 graph_samples\\graph-statistics.sb{\line}other-samples\\RichTextBox.sb{\line}{\line}LDEvents.Resized = OnResize{\line}{\line}Sub OnResize{\line}  gw = GraphicsWindow.Width{\line}  gh = GraphicsWindow.Height{\line}  'zB. GW-f?llende Shape{\line}  LDShapes.ReSize(shp, gw,gh){\line}  LDShapes.Centre(shp, gw/2,gh/2){\line}EndSub}\par
\f0\pard\sb300\shading2000{\fs36\b LDFastArray}\par
\f0\pard{\fs20 Bietet weitere schnellere Wege zum Speichern von Werten in Arrays (inkompatibel zu SB Arrays).{\line}Verarbeitet 1D, 2D, 3D und h?her dimensionale Arrays und bietet Methoden zum Lesen und Schreiben von Arrays in Dateien, incl. CSV Format.{\line}Weiters geeignet f?r verschiedene Dimensionen oder Elementanzahl in unterschiedlichen Reihen (Unterarrays, nicht rechteckige/irrregul?re/'Jagged' Arrays), wie in SB Arrays.{\line}Interne Verwendung von Listen, welche es erlauben, die Anfangsgr??en zu erh?hen, soda? die Arraydimension oder -gr??e anfangs nicht gesetzt werden m?ssen. Unterst?tzt auch Leerwerte ("").{\line}Ganzzahlige Indexierung ab 1 (Intern: FastArray#, s. LDArray).{\line}F?r 1D Arrays ist 'LDList' wegen zus?tzlicher Sortiermethoden besser geeignet.{\line}Elemente in Arrays mit Dimension > 3 werden indexiert durch eine 'Komma getrennte Liste' von Indizes oder Index Variablennamen.}\par

\f0\pard\sb180\shading1000{\fs30\b Add() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen neuen FastArray (Intern: FastArray#+1).{\line}Dies ist ein allgemeiner Array zur Verwendung als 1D, 2D, 3D oder h?her dimensionaler Array, abh?ngig von der Datenbesetzung.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen FastArray.}\par
\f0\pard\sb180\shading1000{\fs30\b Collapse(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt alle Leereintr?ge ("") in einem FastArray.{\line}Beachte da? sich Indizes oder ganze Dimensionen ?ndern k?nnen, wenn interne Eintr?ge gel?scht werden.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb180\shading1000{\fs30\b Copy(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert einen FastArray in einen neuen FastArray (Intern: FastArray#+1).}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des zu kopierenden FastArray.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen FastArray.}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromIndices(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert einen SB Array (bis zu 3 Dimensionen) zum entsprechenden FastArray (Intern: FastArray#+1).{\line}Diese Methode erstellt einen FastArray nur aus den Indizes des SB Array.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 Der Name des SB Arrays.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen FastArray bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromValues(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert einen SB Array zum entsprechenden FastArray (Intern: FastArray#+1).{\line}Alle Indizes im SB Array werden durch fortlaufende ganzzahlige Indizes (ab 1) ersetzt.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 Der Name des SB Arrays.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen FastArray bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Dimension(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Dimension eines FastArray.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Dimension des FastArray.}\par
\f0\pard\sb180\shading1000{\fs30\b Get(arrayName,indices) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen Arraywert.{\line}Die Methoden Get1D, Get2D oder Get3D sind etwas schneller f?r Arrays kleinerer Dimensionen.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b indices}\par
\f0\pard{\fs20 Eine Komma- (oder Leerzeichen " ") getrennte Liste von Indexwerten (langsamer) oder Index Variablennamen (schneller).{\line}zB. "3,2,6" oder "i j k".{\line}Wenn auf "" gesetzt, dann werden zuvor gesetzte Indexvariablen verwendet.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ermittelte Arraywert bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Get1D(arrayName,index1) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen 1D Wert in einem FastArray.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 1. Dimension.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Arraywert bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Get2D(arrayName,index1,index2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen 2D Wert in einem FastArray.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 1. Dimension.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 2. Dimension.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Arraywert bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Get3D(arrayName,index1,index2,index3) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen 3D Wert in einem FastArray.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 1. Dimension.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 2. Dimension.}\par
\f0\pard\sb75{\fs24\b index3}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 3. Dimension.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Arraywert bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Read(fileName,binary) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen neuen FastArray aus den Daten einer angegebenen Datei (Intern: FastArray#+1).{\line}F?r eine textbasierte Datei mit anderem Indexierungsformat wie 'Write', wird ein 1D Array mit jeder Zeile erstellt.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu ladenden Datei.}\par
\f0\pard\sb75{\fs24\b binary}\par
\f0\pard{\fs20 Als Bin?rdatei laden?  "True" oder "False" (Standard, Textdatei).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen FastArray.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadCSV(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Einlesen einer CSV (comma separated values) Datei in einen 2D FastArray (Intern: FastArray#+1).{\line}Das Trennzeichen (Standard: "," Komma) kann mit LDUtilities.CSVDeliminator ge?ndert werden.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der CSV Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D FastArray mit den importierten Daten der CSV Datei bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Remove(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht einen bestehenden FastArray.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb180\shading1000{\fs30\b Set(arrayName,indices,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen Arraywert.{\line}Die Methoden Set1D, Set2D oder Set3D sind etwas schneller f?r Arrays kleinerer Dimensionen.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b indices}\par
\f0\pard{\fs20 Eine Komma- (oder Leerzeichen " ") getrennte Liste von Indexwerten (langsamer) oder Index Variablennamen (schneller).{\line}zB. "3,2,6" oder "i j k".{\line}Wenn auf "" gesetzt, dann werden zuvor gesetzte Indexvariablen verwendet.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Arraywert.}\par
\f0\pard\sb180\shading1000{\fs30\b Set1D(arrayName,index1,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen 1D Wert in einem FastArray.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 1. Dimension.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Arraywert.}\par
\f0\pard\sb180\shading1000{\fs30\b Set2D(arrayName,index1,index2,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen 2D Wert in einem FastArray.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 1. Dimension.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 2. Dimension.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Arraywert.}\par
\f0\pard\sb180\shading1000{\fs30\b Set3D(arrayName,index1,index2,index3,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen 3D Wert in einem FastArray.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 1. Dimension.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 2. Dimension.}\par
\f0\pard\sb75{\fs24\b index3}\par
\f0\pard{\fs20 Der ganzzahlige Index in der 3. Dimension.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Arraywert.}\par
\f0\pard\sb180\shading1000{\fs30\b Size(arrayName,indices) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die aktuelle Gr??e einer Dimension.{\line}Die Methoden Size1, Size2 or Size3 sind etwas schneller f?r Arrays kleinerer Dimensionen.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b indices}\par
\f0\pard{\fs20 Eine Komma- (oder Leerzeichen " ") getrennte Liste von Indizes.{\line}zB. "" f?r erste Dimension oder "3" f?r zweite Dimension des 3. Elementes in der 1. Dimension.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Dimensionsgr??e.}\par
\f0\pard\sb180\shading1000{\fs30\b Size1(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die aktuelle Gr??e der ersten Dimension.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Dimensionsgr??e.}\par
\f0\pard\sb180\shading1000{\fs30\b Size2(arrayName,index1) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die aktuelle Gr??e der zweiten Dimension.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 Der erste Index dessen Gr??e zu ermitteln ist. Kann 1 sein, wenn alle Reihen gleiche Gr??e haben.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Dimensionsgr??e.}\par
\f0\pard\sb180\shading1000{\fs30\b Size3(arrayName,index1,index2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die aktuelle Gr??e der dritten Dimension.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b index1}\par
\f0\pard{\fs20 Der erste Index dessen Gr??e zu ermitteln ist. Kann 1 sein, wenn alle Reihen gleiche Gr??e haben.}\par
\f0\pard\sb75{\fs24\b index2}\par
\f0\pard{\fs20 Der zweite Index dessen Gr??e zu ermitteln ist. Kann 1 sein, wenn alle Reihen gleiche Gr??e haben.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Dimensionsgr??e.}\par
\f0\pard\sb180\shading1000{\fs30\b ToArray(arrayName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert einen FastArray zu einem SB Array.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen SB Arrays bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Write(arrayName,fileName,binary) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert einen FastArray in eine Datei.{\line}F?r einen textbasierten 1D Array, wird jeder Eintrag nur als Zeile (ohne Indexierung) geschrieben.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des FastArray.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu speichernden Datei.}\par
\f0\pard\sb75{\fs24\b binary}\par
\f0\pard{\fs20 Als Bin?rdatei speichern?  "True" oder "False" (Standard, Textdatei).}\par
\f0\pard\sb180\shading1000{\fs30\b WriteCSV(arrayName,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert einen 2D FastArray in eine CSV (comma separated values) Datei.{\line}Das Trennzeichen (Standard: "," Komma) kann mit LDUtilities.CSVDeliminator ge?ndert werden.}\par
\f0\pard\sb75{\fs24\b arrayName}\par
\f0\pard{\fs20 Der Name des 2D FastArray.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der CSV Datei.}\par
\f0\pard\sb300\shading2000{\fs36\b LDFastShapes}\par
\f0\pard{\fs20 Schnellere Shape Methoden als die Standard SB Shape Operationen.{\line}Vorrangig zur Bewegung einer gro?en Anzahl von Shapes, die in einem GameLoop (Hauptschleife) aktualisiert werden.{\line}Es werden nur die Haupt-Shapebefehle unterst?tzt, da es diejenigen sind, die im Allgemeinen oft wiederholt werden.{\line}Die Shape wird zuerst erstellt, dann registriert (ShapeIndex) und der dabei zur?ckgegebene, ganzzahlige Index wird f?r die weiteren Methoden verwendet.{\line}Die visuelle Aktualisierung der erfolgten ?nderungen erfolgt dann erst nach Aufruf von 'Update', wodurch alle ?nderungen gemeinsam stattfinden.{\line}Leistungsverbesserung durch die gemeinsame, ganzzahlige Indexierung und Stapel-Aktualisierung.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDFastShapes.sb}\par

\f0\pard\sb180\shading1000{\fs30\b GetLeft(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die linke Koordinate (Ankerpunkt) einer angegebenen Shape.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die linke Koordinate der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b GetOpacity(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Deckkraft einer Shape.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert der Deckkraft (0 bis 100 [%]). 0 ist v?llig transparent und 100 ist v?llig deckend.}\par
\f0\pard\sb180\shading1000{\fs30\b GetTop(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die obere Koordinate (Ankerpunkt) einer angegebenen Shape.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die obere Koordinate der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b HideShape(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blendet eine bereits hinzugef?gte Shape aus.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb180\shading1000{\fs30\b Move(index,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt eine Shape mit dem angegebenen Name unmittelbar an eine neue Position.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der zu verschiebenden Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate der neuen Position.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate der neuen Position.}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(index,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dreht die Shape mit dem angegebenen Name optisch in den angegebenen Winkel um ihren Mittel-/Schwerpunkt.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Winkel [Grad] in den die Shape gedreht wird (+/- f?r im/gegen Uhrzeigersinn, 0 f?r Originalposition 12h).}\par
\f0\pard\sb180\shading1000{\fs30\b SetOpacity(index,level) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Deckkraft mit welcher eine Shape angezeigt wird.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb75{\fs24\b level}\par
\f0\pard{\fs20 Der Wert der Deckkraft (0 bis 100 [%]). 0 ist v?llig transparent und 100 ist v?llig deckend.}\par
\f0\pard\sb180\shading1000{\fs30\b ShapeIndex(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Registriert eine Shape zur Verwendung mit diesem Objekt.{\line}Dieser Befehl ist potentiell langsam und sollte daher VOR den zeitkritischen visuellen Updates erfolgen.{\line}zB. Erstelle und registriere alle Shapes vor Bewegungssimulationen.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der erstellten Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Index (#) zur Weiterverwendung f?r andere Methoden dieses Objekts, oder -1 bei Fehler.{\line}Der Index ist eine Ganzzahl beginnend ab 1, und um 1 erh?ht f?r jede weitere registrierte Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b ShowShape(index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt eine zuvor ausgeblendete Shape wieder an.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb180\shading1000{\fs30\b Update() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aktualisiert alle durch dieses Objekt gesetzten Shape-Eigenschaften, die seit letztem 'Update' ver?ndert wurden.{\line}Die Shapes werden solange nicht visuell aktualisiert, bis diese Methode aufgerufen wurde.}\par
\f0\pard\sb180\shading1000{\fs30\b Zoom(index,scaleX,scaleY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Vergr??ert oder verkleinert eine Shape um die angegebenen Zoomwerte.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index der Shape (R?ckgabewert von ShapeIndex).}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 Der Zoomfaktor in x-Richtung (<1 verkleinert, >1 vergr??ert).}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 Der Zoomfaktor in y-Richtung (<1 verkleinert, >1 vergr??ert).}\par
\f0\pard\sb300\shading2000{\fs36\b LDFigures}\par
\f0\pard{\fs20 Einige weitere Shapes wie Sprechblasen, B?gen und Pfeile (Intern: Figure#).}\par

\f0\pard\sb180\shading1000{\fs30\b AddArc(width,height,startAngle,endAngle,thickness) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Bogen Shape hinzu (Intern: Figure#).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der Shape.}\par
\f0\pard\sb75{\fs24\b startAngle}\par
\f0\pard{\fs20 Der Startwinkel [Grad].}\par
\f0\pard\sb75{\fs24\b endAngle}\par
\f0\pard{\fs20 Der Endwinkel [Grad].}\par
\f0\pard\sb75{\fs24\b thickness}\par
\f0\pard{\fs20 Die Strichdicke des Bogens [Pxl].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Bogen Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddBlockArrow(width,height,thickness,arrowAngle,direction) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Blockpfeil Shape hinzu (Intern: Figure#).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der Shape.}\par
\f0\pard\sb75{\fs24\b thickness}\par
\f0\pard{\fs20 Die relative Dicke des Pfeilschaftes (zB. 0.25).}\par
\f0\pard\sb75{\fs24\b arrowAngle}\par
\f0\pard{\fs20 Der Winkel der Pfeilspitze [Grad].}\par
\f0\pard\sb75{\fs24\b direction}\par
\f0\pard{\fs20 Die Pfeilrichtung ("Up", "Down", "Left" oder "Right").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Blockpfeil Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddCallout(width,height,text,style,anchor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Ballon (Sprechblase/Legende) Shape hinzu (Intern: Figure#).}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der Shape.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der Text in der Sprechblase.}\par
\f0\pard\sb75{\fs24\b style}\par
\f0\pard{\fs20 Der Ballonstil ("Cloud", "Oval", "Rectangle" oder "RoundedRectangle").}\par
\f0\pard\sb75{\fs24\b anchor}\par
\f0\pard{\fs20 Die Ankerposition der Hinweisspitze, relativ zur Ballongr??e (zB. "X=0;Y=1.25;"). Sind beide <1, zB. "x=0;y=0;", weist die Spitze nach innen und ist verborgen.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Ballon Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddLineArrow(width,height,size,bend,startArrow,endArrow,startCorner) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Strichpfeil Shape hinzu (Intern: Figure#) mit Eigenschaften GraphicsWindow.PenColor/PenWidth.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der Shape.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Die Gr??e der Pfeilspitze [Pxl].}\par
\f0\pard\sb75{\fs24\b bend}\par
\f0\pard{\fs20 Die St?rke der Pfeilbiegung (zB. 0 ist gerade, 0.5 ist sanft gebogen).}\par
\f0\pard\sb75{\fs24\b startArrow}\par
\f0\pard{\fs20 Der Startpfeiltyp ("None", "Arrow", "Open", "Oval" oder "Stealth").}\par
\f0\pard\sb75{\fs24\b endArrow}\par
\f0\pard{\fs20 Der Endpfeiltyp ("None", "Arrow", "Open", "Oval" oder "Stealth").}\par
\f0\pard\sb75{\fs24\b startCorner}\par
\f0\pard{\fs20 Die Position der Startecke ("BottomLeft", "BottomRight", "TopLeft" oder "TopRight"). Der Pfeil endet in der gegen?berliegenden Ecke.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Pfeil Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddRegularPolygon(width,height,corners,radius) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine regelm??ige Vieleck Shape hinzu (Intern: Figure#).{\line}S. LDShapes.AddPolygon, -AddStar, -AddRegularPolygon.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der Shape.}\par
\f0\pard\sb75{\fs24\b corners}\par
\f0\pard{\fs20 Die Anzahl der Ecken.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Ein Radius (relativ zum Umkreisradius) f?r Stern Shapes (zB. 1 f?r F?nfeck, 0.5 f?r 5-Punkte Stern).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Vieleck Shape.}\par
\f0\pard\sb300\shading2000{\fs36\b LDFile}\par
\f0\pard{\fs20 Diverse Funktionen zur Datei- und Ordnermanipulation.}\par

\f0\pard\sb180\shading1000{\fs30\b AccessTime(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den letzten Zugriffszeitpunkt auf eine Datei (zB. TT.MM.JJ HH:mm:ss, gem. Systemeinst.).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der letzte Zugriffszeitpunkt auf Datei oder Verzeichnis bei Erfolg, sonst "" (zB. Datei existiert nicht).}\par
\f0\pard\sb180\shading1000{\fs30\b ANSItoUTF8(fileName,BOM) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert eine ANSI kodierte Textdatei zu UTF8 (s.a. ReadANSI).{\line}Sollte auch f?r andere Kodierungen funktionieren.{\line}UTF8 ist die in SB verwendete Standardkodierung f?r Textdateien.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu konvertierenden Datei.}\par
\f0\pard\sb75{\fs24\b BOM}\par
\f0\pard{\fs20 Byte Order Mark (BOM, 'EF BB BF') am Beginn der UTF8 Datei einf?gen?  "True" oder "False" (Standard). SB erstellt ohne BOM.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Pfad der konvertierten Datei (OrigName-UTF8.txt) bei Erfolg, sonst "" (zB. Kodierung wurde nicht richtig erkannt).}\par
\f0\pard\sb180\shading1000{\fs30\b AppDataFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Pfad des Ordners 'Anwendungsdaten' im Benutzerprofil (%APPDATA%, W7: %USERPROFILE%\\AppData\\Roaming).}\par
\f0\pard\sb180\shading1000{\fs30\b CopyDirectory(directoryFrom,directoryTo) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rekursives Kopieren eines Ordners mit gesamtem Inhalt (incl. Unterordner).}\par
\f0\pard\sb75{\fs24\b directoryFrom}\par
\f0\pard{\fs20 Der volle Pfad des Quellordners.}\par
\f0\pard\sb75{\fs24\b directoryTo}\par
\f0\pard{\fs20 Der volle Pfad des Zielordners.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CreationTime(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Erstellungszeitpunkt einer Datei (zB. TT.MM.JJ HH:mm:ss, gem. Systemeinst.).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Erstellungszeitpunkt der Datei bei Erfolg, sonst "" (zB. Datei existiert nicht).}\par
\f0\pard\sb180\shading1000{\fs30\b CSVplaceholder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Platzhalter-Zeichen welches beim Lesen von CSV Dateien (s. LDFile.ReadCSV..) anstelle leerer Arraywerte verwendet wird.{\line}Ein SB-Array kann keine leeren Werte ("") speichern.{\line}Standard: Leerstring "", dh. der resultierende Array enth?lt keine leeren Elemente aus der CSV Datei.}\par
\f0\pard\sb180\shading1000{\fs30\b DocumentsFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Ordnerpfad f?r 'Eigene Dokumente' (W7: %USERPROFILE%\\Documents).}\par
\f0\pard\sb180\shading1000{\fs30\b Exists(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ob der angegebene Ordner- oder Dateipfad existiert (Gro?-/Kleinschreibung egal, auch f?r relative Pfade ausgehend vom SB Installationsordner '.').}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der absolute oder relative Ordner- oder Dateipfad (kein %EnvVar% Pfad).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDFile.Exists("SB.exe") ' "True"{\line}LDFile.Exists(".\\lib") ' "True"{\line}LDFile.Exists("\\windows\\notepad.exe") ' "True"}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllDirectories(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt rekursiv alle Unterordner in einem angegebenen Ordner.{\line}WARNUNG: Keinen vollen Laufwerkscan o?. ausf?hren, sondern ?berschaubare Ordnerstruktur w?hlen.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der volle Pfad des Basisordners.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den vollen Pfaden aller Unterordner oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetExtension(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Dateierweiterung aus einem lokalen oder Netzwerkpfad (auch f?r relative Pfade mit ".", "..", keine Existenzpr?fung, auch f?r Ordner oder Url).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der (volle) Datei-/Ordnerpfad oder -name, zB. Program.Directory +"\\..\\Ordner\\Datei.ext" (bzw. Dateiname.ext im aktuellen Ordner).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Dateierweiterung (ohne Punkt) oder "" (keine Erweiterung).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 url = http://www.microsoft.com/favicon.ico"{\line}ext = LDFile.GetExtension(url) ' "ico"}\par
\f0\pard\sb180\shading1000{\fs30\b GetFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den blanken Dateiname aus einem lokalen oder Netzwerkpfad (auch f?r relative Pfade mit ".", "..", keine Existenzpr?fung, auch f?r Ordner oder Url).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der (volle) Datei-/Ordnerpfad, zB. Program.Directory +"\\..\\Ordner\\Datei.ext" (bzw. Dateiname.ext im aktuellen Ordner).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der reine Dateiname aus einem gegebenen Dateipfad (ohne Ordnerpfad\\ und .ext), Ordnername f?r einen Ordnerpfad.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 fName = LDFile.GetFile(File.GetSettingsFilePath()){\line}dName = LDFile.GetFile(Program.Directory){\line}wwwName = LDFile.GetFile("http://www.microsoft.com/favicon.ico")}\par
\f0\pard\sb180\shading1000{\fs30\b GetFolder(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Elternordnerpfad aus einem lokalen oder Netzwerkpfad (auch f?r relative Pfade mit ".", "..", keine Existenzpr?fung, auch f?r Ordner oder Url).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der (volle) Datei-/Ordnerpfad, zB. "Program.Directory +"\\..\\Ordner\\Datei.ext" (bzw. Dateiname.ext im aktuellen Ordner).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der reine (ev. relative) Ordnerteil f?r den angegebenen Pfad (ohne abschlie?enden "\\").}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 url = http://www.microsoft.com/favicon.ico"{\line}wwwPfad = LDFile.GetFolder(url)}\par
\f0\pard\sb180\shading1000{\fs30\b Length(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der Zeilen (incl. Leerzeilen) in einer Textdatei. 0 bei Leerdatei. Abschlie?endes CrLf wird nicht mitgez?hlt.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der Textdatei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Zeilenanzahl in der Datei bei Erfolg, sonst -1 (zB. Datei existiert nicht, mit Fehlermeldung).}\par
\f0\pard\sb180\shading1000{\fs30\b LoadAllVariables(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stellt die Werte aller Variablen wieder her, wie diese zuvor mit 'SaveAllVariables' gespeichert wurden.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad unter dem die Variablenwerte zuvor gespeichert wurden (auch %EnvVar%).}\par
\f0\pard\sb180\shading1000{\fs30\b ModifiedTime(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den letzten ?nderungszeitpunkt einer Datei (zB. TT.MM.JJ HH:mm:ss, gem. Systemeinst.).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der letzte ?nderungszeitpunkt der Datei bei Erfolg, sonst "" (zB. Datei existiert nicht).}\par
\f0\pard\sb180\shading1000{\fs30\b MusicFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Ordnerpfad f?r 'Eigene Musik' (W7: %USERPROFILE%\\Music).}\par
\f0\pard\sb180\shading1000{\fs30\b PicturesFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Ordnerpfad f?r 'Eigene Bilder' (W7: %USERPROFILE%\\Pictures).}\par
\f0\pard\sb180\shading1000{\fs30\b PrintFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ausdrucken des Inhalts einer Datei.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu druckenden Datei (Die Dateierweiterung sollte mit einer Anwendung verkn?pft sein).}\par
\f0\pard\sb180\shading1000{\fs30\b PublicFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Pfad des 'Public' Ordners (W7: '?ffentlich', XP: 'Gemeinsame Dateien').}\par
\f0\pard\sb180\shading1000{\fs30\b ReadANSI(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest eine ANSI kodierte Textdatei ein (mit Zeichencode >127).{\line}Sollte auch f?r andere Kodierungen incl. UTF8 funktionieren (s.a. ANSItoUTF8).{\line}UTF8 ist die in SB verwendete Standardkodierung f?r Textdateien.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der einzulesenden Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Textinhalt der ANSI Datei bei Erfolg, sonst "" (zB. Kodierung wurde nicht richtig erkannt).}\par
\f0\pard\sb180\shading1000{\fs30\b ReadANSIToArray(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest eine ANSI kodierte Textdatei als Array ein (ein Arrayelement pro Dateizeile).{\line}Sollte auch f?r andere Kodierungen incl. UTF8 funktionieren (s.a. ANSItoUTF8).{\line}Leerzeilen werden als Leerzeichen in den Arraywert ?bernommen.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der einzulesenden Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array (ab 1) mit einem Element pro Dateizeile bei Erfolg, sonst "" (zB. Kodierung wurde nicht richtig erkannt).}\par
\f0\pard\sb180\shading1000{\fs30\b ReadCSV(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Inhalt einer CSV Datei (comma separated values) als Array.{\line}Das Trennzeichen (Standard: "," Komma) kann mit LDUtilities.CSVDeliminator ge?ndert werden.{\line}Abbruch bei erster Leerzeile und "\\" werden entfernt.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der CSV Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D Array mit den Daten der eingelesenen CSV Datei, zB. arr[zeile][spalte].}\par
\f0\pard\sb180\shading1000{\fs30\b ReadCSVTransposed(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Inhalt einer CSV Datei (comma separated values) als Array und vertauscht dabei Zeilen- und Spaltenwerte.{\line}Das Trennzeichen (Standard: "," Komma) kann mit LDUtilities.CSVDeliminator ge?ndert werden.{\line}Abbruch bei erster Leerzeile und "\\" werden entfernt.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der CSV Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D Array mit den transponierten Daten der eingelesenen CSV Datei, zB. arr[spalte][zeile].}\par
\f0\pard\sb180\shading1000{\fs30\b ReadToArray(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Inhalt einer Textdatei zeilenweise als Array, wobei jede Textzeile einem Arrawert entspricht. "" bei Leerdatei oder wenn Datei nicht existiert.{\line}Leerzeilen werden durch Arraywerte mit einem Leerzeichen (" ") dargestellt.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der Textdatei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Zeilen der Datei als Array, indexiert durch die Zeilennummer (ab 1).}\par
\f0\pard\sb180\shading1000{\fs30\b RenameDirectory(directoryFrom,directoryTo) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Umbenennen oder Verschieben eines existierenden Ordners mit gesamtem Inhalt (incl. Unterordner).}\par
\f0\pard\sb75{\fs24\b directoryFrom}\par
\f0\pard{\fs20 Der volle Pfad des zu verschiebenden/umzubenennenden Quellordners.}\par
\f0\pard\sb75{\fs24\b directoryTo}\par
\f0\pard{\fs20 Der volle Zielordnerpfad (ev. mit neuem Ordnername).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RenameFile(fileFrom,fileTo) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Umbenennen oder Verschieben einer existierenden Datei.{\line}Bestehende Zieldateien werden nicht ?berschrieben.}\par
\f0\pard\sb75{\fs24\b fileFrom}\par
\f0\pard{\fs20 Der volle Pfad der zu verschiebenden/umzubenennenden Quelldatei (mit/ohne Erweiterung).}\par
\f0\pard\sb75{\fs24\b fileTo}\par
\f0\pard{\fs20 Der volle Zieldateipfad (ev. mit neuem Dateiname, mit/ohne Erweiterung).{\line}Existiert ein gleichnamiger Ordnerpfad, so kann dieser kein Zieldateipfad mehr sein.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" oder "FAILED" (mit Fehlermeldung).}\par
\f0\pard\sb180\shading1000{\fs30\b SaveAllVariables(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert alle aktuellen Variablen/-werte in eine angegebene Datei (eine Variable/Zeile als "Name Wert" durch Leerzeichen getrennt).{\line}Dies ist der vollst?ndige. aktuelle Programmstatus bis zum Aufruf dieser Methode. Enth?lt bereits alle Variablennamen, jedoch ev. manche noch OHNE Wert.{\line}Kann n?tzlich sein, um einen Spielstand zu speichern oder zum Debuggen (s. LoadAllVariables).{\line}Besser nicht innerhalb einer Ereignis Sub verwenden.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad zum Speichern der Variablen und -werte (auch %EnvVar%). Eine bestehende Datei wird ?berschrieben bzw. neu erstellt.}\par
\f0\pard\sb180\shading1000{\fs30\b Size(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Gr??e einer lokalen Datei in Bytes.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Dateigr??e [Byte] bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b TempFolder \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Pfad des TEMP Ordners im Benutzerprofil (%TEMP% bzw. Ordnerpfad von File.GetTemporaryFilePath).}\par
\f0\pard\sb180\shading1000{\fs30\b UserName \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den aktuellen Benutzername (%USERNAME%).}\par
\f0\pard\sb180\shading1000{\fs30\b WriteCSV(fileName,array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert einen 2D Array in eine CSV Datei (comma separated values).{\line}Das Trennzeichen (Standard: "," Komma) kann mit LDUtilities.CSVDeliminator ge?ndert werden.{\line}Felder mit CrLf, " und , in "" einschlie?en, wobei " -> "" (Escape).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der CSV Datei.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu exportierende 2D Array, zB. arr[zeile][spalte].}\par
\f0\pard\sb300\shading2000{\fs36\b LDFocus}\par
\f0\pard{\fs20 Fokuskontrolle f?r Steuerelemente/Controls (zB. TextBox zur Zeit aktiv f?r Eingabe).{\line}F?r Shapes (Ellipse#, Image#, Text#, View3D# usw.) erm?glicht nach Setzen von:{\line}LDShapes.SetProperty(shp, "Focusable","True")}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 3D-samples\\LD3DMazeGame.sb{\line}other-samples\\LDUnits.sb}\par

\f0\pard\sb180\shading1000{\fs30\b GetFocus() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das aktuell fokusierte Steuerelement/Control.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Steuerelements (gew?hnlich ein Button# oder TextBox#), sonst "False".}\par
\f0\pard\sb180\shading1000{\fs30\b IsFocus(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ob ein angegebenes Steuerelement/Control fokusiert ist.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Steuerelements (gew?hnlich ein Button oder TextBox).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b SetFocus(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Fokus f?r ein angegebenes Steuerelement/Control.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Steuerelements (gew?hnlich ein Button oder TextBox).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" bei Erfolg, sonst "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDftp}\par
\f0\pard{\fs20 FTP Methoden zur Datei?bertragung.}\par

\f0\pard\sb180\shading1000{\fs30\b Delete(remoteFile,ftpServerIP,ftpUserID,ftpPassword) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht eine Datei per FTP.}\par
\f0\pard\sb75{\fs24\b remoteFile}\par
\f0\pard{\fs20 Der volle Serverpfad der zu l?schenden Remotedatei.}\par
\f0\pard\sb75{\fs24\b ftpServerIP}\par
\f0\pard{\fs20 Die FTPServer Adresse (oder IP).}\par
\f0\pard\sb75{\fs24\b ftpUserID}\par
\f0\pard{\fs20 Die Benutzer ID.}\par
\f0\pard\sb75{\fs24\b ftpPassword}\par
\f0\pard{\fs20 Das Benutzerpasswort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" oder "PENDING" f?r asynchron.}\par
\f0\pard\sb180\shading1000{\fs30\b DoAssync \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt ob die FTP ?bertragung asynchron durchgef?hrt wird ("True" oder "False" Standard).{\line}Ein asynchroner FTP Transfer kehrt sofort und vollst?ndig im Hintergrund zur?ck.{\line}Das 'FTPComplete' Ereignis wird aufgerufen, sobald die ?bertragung beendet ist.}\par
\f0\pard\sb180\shading1000{\fs30\b Download(localFile,remoteFile,ftpServerIP,ftpUserID,ftpPassword) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Download einer Datei per FTP.}\par
\f0\pard\sb75{\fs24\b localFile}\par
\f0\pard{\fs20 Der volle lokale Pfad der herunterzuladenden Datei.}\par
\f0\pard\sb75{\fs24\b remoteFile}\par
\f0\pard{\fs20 Der volle Serverpfad der herunterzuladenden Remotedatei.}\par
\f0\pard\sb75{\fs24\b ftpServerIP}\par
\f0\pard{\fs20 Die FTPServer Adresse (oder IP).}\par
\f0\pard\sb75{\fs24\b ftpUserID}\par
\f0\pard{\fs20 Die Benutzer ID.}\par
\f0\pard\sb75{\fs24\b ftpPassword}\par
\f0\pard{\fs20 Das Benutzerpasswort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" oder "PENDING" f?r asynchron.}\par
\f0\pard\sb180\shading1000{\fs30\b FTPComplete \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein asynchroner FTP Transfer abgeschlossen ist.}\par
\f0\pard\sb180\shading1000{\fs30\b LastFTPFile \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Die letzte asynchron ?bertragene FTP Datei.}\par
\f0\pard\sb180\shading1000{\fs30\b LastFTPStatus \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der Status der letzten asynchron ?bertragenen FTP Datei ("SUCCESS" oder "FAILED").}\par
\f0\pard\sb180\shading1000{\fs30\b ListFiles(remoteFolder,ftpServerIP,ftpUserID,ftpPassword) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Inhaltsauflistung eines Remoteordners per FTP (nur asynchron).}\par
\f0\pard\sb75{\fs24\b remoteFolder}\par
\f0\pard{\fs20 Der volle Serverpfad des aufzulistenden Remoteordners.}\par
\f0\pard\sb75{\fs24\b ftpServerIP}\par
\f0\pard{\fs20 Die FTPServer Adresse (oder IP).}\par
\f0\pard\sb75{\fs24\b ftpUserID}\par
\f0\pard{\fs20 Die Benutzer ID.}\par
\f0\pard\sb75{\fs24\b ftpPassword}\par
\f0\pard{\fs20 Das Benutzerpasswort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit Datei- und Ordnernamen oder "FAILED". Der Arrayindex bezeichnet den Datei-/Ordnername und Arraywerte enthalten zus?tzliche Informationen.}\par
\f0\pard\sb180\shading1000{\fs30\b Upload(localFile,remoteFile,ftpServerIP,ftpUserID,ftpPassword) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Upload einer Datei per FTP.}\par
\f0\pard\sb75{\fs24\b localFile}\par
\f0\pard{\fs20 Der volle lokale Pfad der raufzuladenden Datei.}\par
\f0\pard\sb75{\fs24\b remoteFile}\par
\f0\pard{\fs20 Der volle Serverpfad der raufzuladenden Remotedatei.}\par
\f0\pard\sb75{\fs24\b ftpServerIP}\par
\f0\pard{\fs20 Die FTPServer Adresse (oder IP).}\par
\f0\pard\sb75{\fs24\b ftpUserID}\par
\f0\pard{\fs20 Die Benutzer ID.}\par
\f0\pard\sb75{\fs24\b ftpPassword}\par
\f0\pard{\fs20 Das Benutzerpasswort.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "FAILED" oder "PENDING" f?r asynchron.}\par
\f0\pard\sb180\shading1000{\fs30\b UseBinary \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt ob die FTP ?bertragung Bin?r- (Standard) oder Ascii-Modus verwendet ("True" oder "False").}\par
\f0\pard\sb300\shading2000{\fs36\b LDGraph}\par
\f0\pard{\fs20 Objekt zur Erstellung und Anzeige von Graphen.{\line}Hilfe unter LDGraph.Help.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 graph_samples\\*.sb}\par

\f0\pard\sb180\shading1000{\fs30\b AddGraph(xpos,ypos,width,height,title,labelX,labelY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Graph bzw. Diagramm (Intern: Graph#) im GraphicsWindow hinzu. Ev. Fehleranzeige im TW ist mit LDUtilities.ShowErrors deaktivierbar.}\par
\f0\pard\sb75{\fs24\b xpos}\par
\f0\pard{\fs20 Die linke Position des Graph im GW.}\par
\f0\pard\sb75{\fs24\b ypos}\par
\f0\pard{\fs20 Die obere Position des Graph im GW.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des Graph im GW.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Graph im GW.}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 Der "Titel" ?ber dem Graph.}\par
\f0\pard\sb75{\fs24\b labelX}\par
\f0\pard{\fs20 Die "Bezeichnung" f?r die x-Achse.}\par
\f0\pard\sb75{\fs24\b labelY}\par
\f0\pard{\fs20 Die "Bezeichnung" f?r die y-Achse.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Graph.}\par
\f0\pard\sb180\shading1000{\fs30\b AddSeriesHistogram(graphName,seriesLabel,data,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einem existierenden Graph einen Datensatz als Balkendiagramm (Histogramm) hinzu.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 Der Name des Graph.}\par
\f0\pard\sb75{\fs24\b seriesLabel}\par
\f0\pard{\fs20 Die Bezeichnung des Datensatzes.{\line}Ein bereits bestehender Datensatz mit gleicher Bezeichnung wird dabei ersetzt.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Ein Array mit den X/Y Koordinatenwerten in der Form daten[x] = y.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe f?r die Datenserie/Label.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Histogramm mit zwei Balken (0,1) und (2,3) f?r [Balkenmitte,H?he]:{\line}daten[0] = 1{\line}daten[2] = 3}\par
\f0\pard\sb180\shading1000{\fs30\b AddSeriesLine(graphName,seriesLabel,data,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einem existierenden Graph einen neuen Datensatz als Liniengraph hinzu.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 Der Name des Graph.}\par
\f0\pard\sb75{\fs24\b seriesLabel}\par
\f0\pard{\fs20 Die Bezeichnung des Datensatzes.{\line}Ein bereits bestehender Datensatz mit gleicher Bezeichnung wird dabei ersetzt.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Ein Array mit den X/Y Koordinatenwerten in der Form daten[x] = y.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe f?r die Datenserie/Label.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Linie zwischen zwei Punkten (0,1) und (2,3) f?r [x,y]:{\line}daten[0] = 1{\line}daten[2] = 3}\par
\f0\pard\sb180\shading1000{\fs30\b AddSeriesPoints(graphName,seriesLabel,data,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einem existierenden Graph einen Datensatz als Punkte hinzu.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 Der Name des Graph.}\par
\f0\pard\sb75{\fs24\b seriesLabel}\par
\f0\pard{\fs20 Die Bezeichnung des Datensatzes.{\line}Ein bereits bestehender Datensatz mit gleicher Bezeichnung wird dabei ersetzt.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Ein Array mit den X/Y Koordinatenwerten in der Form daten[x] = y.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Farbe f?r die Datenserie/Label.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Datenserie mit zwei Punkten (0,1) und (2,3) f?r [x,y]:{\line}daten[0] = 1{\line}daten[2] = 3}\par
\f0\pard\sb180\shading1000{\fs30\b AutoScale \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die automatische Skalierung der Achsen?  "True" (Standard) oder "False".{\line}Bei "False" wird die Skalierung aus der vorhergehenden Version verwendet.}\par
\f0\pard\sb180\shading1000{\fs30\b AxesColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Farbe der umgebenden Achsen und Skalierungsmarkierungen (Standard: #FF000000 bzw. Black).}\par
\f0\pard\sb180\shading1000{\fs30\b AxesResolution \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Dezimalstellen an den Min/Max Achsenendpunkten (Standard: 2 dh. signifikante Werte an den Achsenendpunkten auf zwei Dezimalstellen).}\par
\f0\pard\sb180\shading1000{\fs30\b BorderColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Farbe der Umrandung (Standard: #FFFAEBD7 bzw. AntiqueWhite).}\par
\f0\pard\sb180\shading1000{\fs30\b CreateTrend(data,order) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine Tendenzfunktion aus den angegebenen Daten.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Ein Array mit den X/Y Koordinatenwerten in der Form daten[x] = y.{\line}{\line}zB. Eine Gerade mit Punkten (0,1) und (2,3) f?r [x,y] h?tte:{\line} daten[0] = 1{\line} daten[2] = 3{\line}{\line}oder allgemein daten[x] = y, als Ausdruck f?r f(x)=y.}\par
\f0\pard\sb75{\fs24\b order}\par
\f0\pard{\fs20 Der Polynomgrad f?r die Trendfunktion:{\line}(0 ist eine Waagrechte){\line}1  linear{\line}2  quadratisch{\line}3  kubisch  usw.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Datenarray mit Tendenzwerten, die als Graph dargestellt werden.}\par
\f0\pard\sb180\shading1000{\fs30\b DeleteSeries(graphName,seriesLabel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht einen vorhandenen Datensatz von einem bestehenden Graph.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 Der Name des Graph.}\par
\f0\pard\sb75{\fs24\b seriesLabel}\par
\f0\pard{\fs20 Die Bezeichnung des zu l?schenden Datensatzes.}\par
\f0\pard\sb180\shading1000{\fs30\b ExportCSV(data,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Exportiert eine Datenserie direkt als CSV Datei (keine Graphzeichnung).}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Ein Array mit den X/Y Koordinatenwerten in der Form daten[x] = y.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Dateiname der zu speichernden CSV Datei.}\par
\f0\pard\sb180\shading1000{\fs30\b GridColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Farbe der inneren Gitterlinien (Standard: #FFD3D3D3 bzw. LightGray).}\par
\f0\pard\sb180\shading1000{\fs30\b GridLinesX \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Anzahl der x-Achsenmarkierungen und Gitterlinien (Standard: 10).}\par
\f0\pard\sb180\shading1000{\fs30\b GridLinesY \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Anzahl der y-Achsenmarkierungen und Gitterlinien (Standard: 10).}\par
\f0\pard\sb180\shading1000{\fs30\b Help() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Diese Methode dient nur zur Anzeige dieser Hilfe.{\line}{\line}Daten zu einem Graph k?nnen als Linie, Punkte oder S?ulen dargestellt werden.{\line}{\line}Jeder Datensatz ist ein SB-Array, wobei der Arrayindex den (einmaligen) Wert auf der x-Achse und der Arraywert den y-Wert darstellt (daten[x]=y) zB:{\line} daten[1] = 5{\line} daten[2] = 8{\line} daten[3] = 3{\line}{\line}Zuerst wird mit AddGraph ein neuer Graph erstellt. Diesem werden dann Daten mittels AddSeriesLine, AddSeriesHistogram oder AddSeriesPoints hinzugef?gt.{\line}{\line}Sobald ein Graph dargestellt ist, k?nnen die Achsen mit dem Hand-Cursor erfasst und bewegt werden. Die Legende kann ebenfalls verschoben werden.{\line}{\line}Mittels linker Maustaste kann der Graph umskaliert werden, ein zu vergr??ernder Bereich gew?hlt oder per Mausrad die Gesamtanzeige vergr??ert werden. Ein Doppelklick setzt alle Werte auf die Ausgangsdarstellung zur?ck.{\line}{\line}Rechtsklick zeigt ein Kontextmen? mit weiteren Funktionen, wie Export zu Bild- (bmp, gif, jpg, png, tiff) oder Textdatei (csv, Excel), Anzeige der Cursorkoordinaten, Ausblenden der Legende usw.{\line}{\line}Zus?tzlich bieten verschiedene Parameter dieser Methode weitere Optionen zu Farbdarstellung und Verhalten des Graphen.}\par
\f0\pard\sb180\shading1000{\fs30\b InteriorColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Farbe des Innenbereiches (Standard: #FFF0F8FF bzw. AliceBlue).}\par
\f0\pard\sb180\shading1000{\fs30\b RestartEvents() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet alle Linksklick Mausereignisse im Graph (nach 'StopEvents') erneut.}\par
\f0\pard\sb180\shading1000{\fs30\b ScaleAxisX(graphName,min,interval,max) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Skalierung f?r die x-Achse.{\line}Dies ?bergeht alle automatischen Methoden.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 Der Name des Graph.}\par
\f0\pard\sb75{\fs24\b min}\par
\f0\pard{\fs20 Der Minimalwert auf der x-Achse.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 Der regelm??ige Abstand der Gitterlinien.{\line}Bei 0 wird dieser Abstand automatisch aus den angegebenen Daten ermittelt.}\par
\f0\pard\sb75{\fs24\b max}\par
\f0\pard{\fs20 Der Maximalwert auf der x-Achse.{\line}Bei max=min, wird das Maximum aus den angegebenen Daten ermittelt.{\line}Bei max<min, werden Minimum und Maximum aus den angegebenen Daten ermittelt.}\par
\f0\pard\sb180\shading1000{\fs30\b ScaleAxisY(graphName,min,interval,max) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Skalierung f?r die y-Achse.{\line}Dies ?bergeht alle automatischen Methoden.}\par
\f0\pard\sb75{\fs24\b graphName}\par
\f0\pard{\fs20 Der Name des Graph.}\par
\f0\pard\sb75{\fs24\b min}\par
\f0\pard{\fs20 Der Minimalwert auf der y-Achse.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 Der regelm??ige Abstand der Gitterlinien.{\line}Bei 0 wird dieser Abstand automatisch aus den angegebenen Daten ermittelt.}\par
\f0\pard\sb75{\fs24\b max}\par
\f0\pard{\fs20 Der Maximalwert auf der y-Achse.{\line}Bei max=min, wird das Maximum aus den angegebenen Daten ermittelt.{\line}Bei max<min, werden Minimum und Maximum aus den angegebenen Daten ermittelt.}\par
\f0\pard\sb180\shading1000{\fs30\b StopEvents() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt alle Linksklick Mausereignisse im Graph (Zoomen, Markieren usw.).}\par
\f0\pard\sb180\shading1000{\fs30\b TextColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Farbe des Textes (Standard: #FF000000 bzw. Black).}\par
\f0\pard\sb180\shading1000{\fs30\b TrendCoef() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Polynomkoeffizienten der Tendenzfunktion f?r die zuletzt (mittels 'CreateTrend') berechneten Tendenzwerte.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array 'coef' mit den Polynomkoeffizienten f?r die Trendkurve.{\line}Die Anzahl der Koeffizienten im Array ist um 1 h?her als der Grad, welcher zur Erstellung der Tendenz (Grad+1) verwendet wurde, ab 0 (Konstantwert).{\line}y = coef[0] + coef[1]x + coef[2]x^2 ...}\par
\f0\pard\sb180\shading1000{\fs30\b TrendPointCount \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Anzahl der Punkte, die zur Erstellung der Trendkurve ('CreateTrend') verwendet werden. (Standard: 50).}\par
\f0\pard\sb300\shading2000{\fs36\b LDGraphicsWindow}\par
\f0\pard{\fs20 Erweiterte Funktionen f?r das GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\ClockWidget.sb, LDScrollBars.sb, LDUnits.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Animate(scaleX,scaleY,panX,panY,angle,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Skaliert und bewegt alle Shapes und Controls animiert innerhalb des GraphicsWindow.{\line}?hnlich der s. 'Reposition' Methode, jedoch in animierter Bewegung (asynchron).{\line}s.a. LDShapes.AnimateRotation /-..Zoom f?r Einzelshape.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 Der -/+ Skalierungsfaktor in x-Richtung (1 orig, 0 keine Shapes/Controls).}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 Der -/+ Skalierungsfaktor in y-Richtung (1 orig, 0 keine Shapes/Controls).}\par
\f0\pard\sb75{\fs24\b panX}\par
\f0\pard{\fs20 Versatz der Ansicht in x-Richtung [Pxl] bei Ansichtsskalierung (0 zentriert im GraphicsWindow).}\par
\f0\pard\sb75{\fs24\b panY}\par
\f0\pard{\fs20 Versatz der Ansicht in y-Richtung [Pxl] bei Ansichtsskalierung (0 zentriert im GraphicsWindow).}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der -/+ Winkel um den die Ansicht zus?tzlich gedreht wird [Grad].}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Dauer der Animation [ms].}\par
\f0\pard\sb180\shading1000{\fs30\b BackgroundBrush(brush) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen Farbgradient als Hintergrund f?r das GraphicsWindow (dynamische Anpassung an Fenstergr??e).}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 Ein zuvor erstellter Gradient- oder Bildpinsel (Intern: Brush#, s. LDShapes.BrushGradient bzw. LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDGraphicsWindow.BackgroundImage("string") au?er "" oder Wert (zB. 0) entfernt bestehenden Hintergrundgradient und setzt GW Hintergrundfarbe auf 'Transparent'}\par
\f0\pard\sb180\shading1000{\fs30\b BackgroundImage(imageName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein Bild als Hintergrund f?r das GraphicsWindow (dieses mu? bereits initialisiert sein, dynamische Anpassung an Fenstergr??e, s.a. TransparentGW).{\line}Der Hintergrund wird automatisch neudimensioniert um die jeweilige Gr??e des GraphicsWindow auszuf?llen (Gleiche Ebene wie GW Hintergrundfarbe, transparente Bereiche als #FF000000 bzw. Black).{\line}Bleibt nach GraphicsWindow.Clear erhalten.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Das als Hintergrund zu ladende Bild (Intern: ImageList#).{\line}R?ckgabewert von ImageList.LoadImage, lokale oder Netzwerk Bilddatei. Sonstiger "string" (au?er "") oder Wert (zB. 0) entfernt ein bestehendes Hintergrundbild und setzt GW Hintergrundfarbe auf 'Transparent'.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Zoom-Beispiel s. LDEvents.LastMouseWheelDelta}\par
\f0\pard\sb180\shading1000{\fs30\b CancelClose \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt einen Abbruch der n?chsten 'Schlie?en' Aktion f?r das GraphicsWindow. "True" oder "False" (Standard).{\line}Erfordert da? ExitOnClose auf "False" gesetzt ist. Dies sollte innerhalb eines s. LDGraphicsWindow.Closing Ereignisses gesetzt werden (zB. per LDDialogs.Confirm).{\line}Wird auf "False" zur?ckgesetzt, nachdem ein Schlie?en verhindert wurde.}\par
\f0\pard\sb180\shading1000{\fs30\b Capture(fileName,border) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert den Inhalt des GraphicsWindow als Bilddatei (bmp, gif, j(e)pg, png, tiff oder ico) oder in ImageList (Intern: ImageList#+1).{\line}Das Fenster mu? sichtbar sein. Kurzes Abwarten zB. Program.Delay kann vor Aufruf der Methode n?tig sein.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Dateiname f?r das zu speichernde Bild (bmp, gif, jp(e)g, png, tiff oder ico) oder{\line}"" zum Speichern des Bildes in ImageList (Intern: ImageList#+1).}\par
\f0\pard\sb75{\fs24\b border}\par
\f0\pard{\fs20 Fensterrahmen auch Bestandteil des Bildes?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ImageList Name (wenn fileName ""), sonst "" (bei Ausgabe in Bilddatei).}\par
\f0\pard\sb180\shading1000{\fs30\b Closing \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf beim Schlie?en eines GraphicsWindow.{\line}'ExitOnClose' mu? bei Aufruf dieses Ereignisses auf "False" gesetzt sein.{\line}Ist 'CancelClose' auf "True" gesetzt, wird das Schlie?en verhindert.}\par
\f0\pard\sb180\shading1000{\fs30\b ExitButtonMode(window,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Status des 'Schlie?en' Feldes ('X') f?r ein bereits initialisiertes Fenster. Dieses kann dabei ein- oder ausgeblendet sein (wird nicht ge?ffnet).{\line}Die Einstellung bleibt auch nach Aus- und Einblenden dieses Fensters erhalten, wird jedoch bei Aufruf des Systemmen?s auf "Enabled" zur?ckgesetzt.}\par
\f0\pard\sb75{\fs24\b window}\par
\f0\pard{\fs20 Der Fenstertitel, zB. R?ckgabe von TextWindow.Title oder GraphicsWindow.Title.}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 Der Status?  "Enabled" (Standard) oder "Disabled".}\par
\f0\pard\sb180\shading1000{\fs30\b ExitOnClose \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Beendigung des SB Programms, sobald ein GraphicsWindow geschlossen wird. "True" (Standard) oder "False".{\line}Bei "False" mu? das Programm noch anstehende Aufgaben haben um fortzufahren.}\par
\f0\pard\sb180\shading1000{\fs30\b FloodFill(x,y,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?llt den gesamten Bereich der ein angegebenes Pixel umgibt, wobei alle benachbarten, gleichfarbigen Pixel gef?rbt werden.{\line}Dies betrifft nur die Ebene f?r Zeichnungen (Draw../Fill..) im GraphicsWindow.{\line}F?r Farbtoleranz s. 'FloodFillTolerance'.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Referenzpixels zum Ausf?llen.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Referenzpixels zum Ausf?llen.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die F?llfarbe, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb180\shading1000{\fs30\b FloodFillTolerance \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Farbtoleranz f?r die FloodFill Methode (0 bis 100 [%]):{\line}0	?ndert nur Pixel der exakt gleichen Farbe (Standard){\line}100	?ndert alle von der neuen F?llfarbe abweichenden Pixel}\par
\f0\pard\sb180\shading1000{\fs30\b GetPixel(x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Farbe eines Pixels an den angegebenen x- und y-Koordinaten im GraphicsWindow.{\line}Diese Methode funktioniert f?r Hintergrund, Zeichnungen und Shape Ebenen.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Pixels.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Pixels.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Pixelfarbe als #RRGGBB (sonst #000000, zB. Koordinaten au?erhalb GW).}\par
\f0\pard\sb180\shading1000{\fs30\b Height \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die H?he des GraphicsWindow (bei Verwendung von LDScrollBars).}\par
\f0\pard\sb180\shading1000{\fs30\b Icon \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine angegebene Bilddatei (zB. ico, png, kein %ENVVAR% Pfad) als Symbol f?r das GraphicsWindow. Dieses mu? bereits initialisiert sein. Fehlermeldung, wenn Symboldatei nicht existiert.{\line}"SB" setzt das SmallBasic Symbol.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseX \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die x-Koordinate f?r den Mauszeiger im GraphicsWindow.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseXOffset \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den x-Versatz [Pxl] zwischen Desktop- und GraphicsWindow x-Koordinaten (incl. Skalierung):{\line}offX = dtX - MouseXScale * gwX 'bzw.{\line}MouseXOffset = Mouse.MouseX - MouseXScale * GW.MouseX{\line}GraphicsWindow mu? initialisiert sein (sonst: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b MouseXScale \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den x-Skalierungsfaktor (zB: 1) zwischen Desktop- und GraphicsWindow x-Koordinaten:{\line}MouseXScale = (dtX - offX)/gwX 'bzw.{\line}Mouse.MouseX = GW.MouseX * MouseXScale + MouseXOffset{\line}GraphicsWindow mu? initialisiert sein.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseY \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die y-Koordinate f?r den Mauszeiger im GraphicsWindow.}\par
\f0\pard\sb180\shading1000{\fs30\b MouseYOffset \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den y-Versatz [Pxl] zwischen Desktop- und GraphicsWindow y-Koordinaten (incl. Skalierung):{\line}offY = dtY - MouseYScale * gwY 'bzw.{\line}MouseYOffset = Mouse.MouseY - MouseYScale * GW.MouseY{\line}GraphicsWindow mu? initialisiert sein (sonst: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b MouseYScale \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den y-Skalierungsfaktor (zB: 1) zwischen Desktop- und GraphicsWindow y-Koordinaten:{\line}MouseYScale = (dtY - offY)/gwY 'bzw.{\line}Mouse.MouseY = GW.MouseY * MouseYScale + MouseYOffset{\line}GraphicsWindow mu? initialisiert sein.}\par
\f0\pard\sb180\shading1000{\fs30\b PauseUpdates() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pausiert automatische Aktualisierung (Neuzeichnen) im initialisierten GraphicsWindow (s. ResumeUpdates).}\par
\f0\pard\sb180\shading1000{\fs30\b Print(border) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Druckt den Inhalt des GraphicsWindow.{\line}Das Fenster mu? sichtbar sein. Kurzes Abwarten zB. Program.Delay kann kann vor Aufruf dieser Methode n?tig sein.}\par
\f0\pard\sb75{\fs24\b border}\par
\f0\pard{\fs20 Fensterrahmen auch Bestandteil des Bildes?  "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Reposition(scaleX,scaleY,panX,panY,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Skaliert und verschiebt alle Shapes und Controls innerhalb des GraphicsWindow.{\line}Diese Methode skaliert und verschiebt eigentlich die Ansicht anstatt der Shapes, soda? deren Positionen und sonstige Eigenschaften unver?ndert bleiben, scheinen jedoch skaliert im neu positionierten Bereich.{\line}zB. Shapes.GetLeft bleibt unver?ndert trotz umpositionierter Ansicht und GraphicsWindow.MouseX zeigt die Koordinaten relativ zur umpositionierten Ansicht.{\line}Vorstellbar als neu positionierte Gesamtansicht, so als ob diese eine Shape im GrapicsWindow w?re.{\line}Koordinatentransformation zwischen Ansicht (vX,vY) und GraphicsWindow (gwX,gwY):{\line} gwX = (vX+panX)*scaleX + gw*(1-scaleX)/2{\line} gwY = (vY+panY)*scaleY + gh*(1-scaleY)/2{\line}Alle Zeichnungen bleiben unver?ndert im originalen GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 Der -/+ Skalierungsfaktor in x-Richtung (1 Originalansicht, 0 keine Shapes/Controls).}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 Der -/+ Skalierungsfaktor in y-Richtung (1 Originalansicht, 0 keine Shapes/Controls).}\par
\f0\pard\sb75{\fs24\b panX}\par
\f0\pard{\fs20 Versatz der Ansicht in x-Richtung [Pxl] bei Ansichtsskalierung (0 zentriert im GraphicsWindow).}\par
\f0\pard\sb75{\fs24\b panY}\par
\f0\pard{\fs20 Versatz der Ansicht in y-Richtung [Pxl] bei Ansichtsskalierung (0 zentriert im GraphicsWindow).}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der -/+ Winkel um den die Ansicht zus?tzlich gedreht wird [Grad].}\par
\f0\pard\sb180\shading1000{\fs30\b RepositionedMouseX \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die x-Koordinate des Mauszeigers im GraphicsWindow bei repositionierter Ansicht (s. Reposition).}\par
\f0\pard\sb180\shading1000{\fs30\b RepositionedMouseY \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die y-Koordinate des Mauszeigers im GraphicsWindow bei repositionierter Ansicht (s. Reposition).}\par
\f0\pard\sb180\shading1000{\fs30\b RepositionPoint(x,y,toGW) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt transformierte Koordinaten zwischen GraphicsWindow und umpositionierer Ansicht (s. Reposition).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die zu transformierende x-Koordinate.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die zu transformierende y-Koordinate.}\par
\f0\pard\sb75{\fs24\b toGW}\par
\f0\pard{\fs20 Transformrichtung von Ansicht zum GraphicsWindow ("True"), bzw. vom GraphicsWindow zur Ansicht ("False", Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2-elementiger Array der transformierten Koordinaten mit Indizes 1 und 2 (f?r neue x, y).}\par
\f0\pard\sb180\shading1000{\fs30\b Resize \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Resize Status f?r das GraphicsWindow:{\line}0  CanMinimize, "" (Min, wie GW.CanResize=""){\line}1  CanResize (Standard, Min+Max, wie GW.CanResize="True"){\line}2  CanResizeWithGrip (Min+Max+Mausgriff, wie GW.CanResize=""){\line}3  NoResize (wie 2, nur 'X' Feld, wie GW.CanResize="")}\par
\f0\pard\sb180\shading1000{\fs30\b ResumeUpdates() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt pausiertes Neuzeichnen (s. PauseUpdates) des GraphicsWindow wieder fort.}\par
\f0\pard\sb180\shading1000{\fs30\b ScreenCapture \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Erstellung eines Bildes vom GraphicsWindow f?r LDGraphicsWindow.Print und -.Capture Methoden. Erstellung nur, wenn deren Rahmen-Option auf "False" (dh. ohne Rahmen) gesetzt ist.{\line}"True"  Das aktuell sichtbare GraphicsWindow wird zur Bilderstellung verwendet.{\line}"False" Die Grafiken im GraphicsWindow werden neu zum Bild gerendert (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b SetActive() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt das GraphicsWindow als aktives Fenster in den Vordergrund (mit Fokus, zB. Umschalten vom TextWindow).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst Fehlermeldung.}\par
\f0\pard\sb180\shading1000{\fs30\b SetFontFromFile(fontFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Schriftart im GraphicsWindow mittels einer lokalen .ttf Schriftartdatei.}\par
\f0\pard\sb75{\fs24\b fontFile}\par
\f0\pard{\fs20 Der volle Pfad f?r die zu setzende .ttf Schriftartdatei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Bezeichnung der Schriftart (als file:///Ordnerpfad/#Schriftname) bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShowInTaskbar \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Anzeige einer Schaltfl?che (Symbol) f?r das GraphicsWindow in der Taskleiste?  "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b State \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Status des GraphicsWindow:{\line}0  Normal (Standard, Normalgr??e){\line}1  Minimiert (in Taskleiste){\line}2  Maximiert (nach Style = 0, sonst Taskleiste ausgenommen){\line}{\line}Falls unge?ffnet, wird das GW auch angezeigt.}\par
\f0\pard\sb180\shading1000{\fs30\b Style \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Stil des (zus?tzlichen LDWindows) GraphicsWindow:{\line}0  Ohne (nur Klientbereich ohne Titelleiste, s. TransparentGW){\line}1  Einzelrand (Standard){\line}2  3DRand (breiterer Rand){\line}3  ToolWindow (nur 'X' Feld, ohne Systemmen?/Icon){\line}{\line}Falls unge?ffnet, wird das GW auch angezeigt.}\par
\f0\pard\sb180\shading1000{\fs30\b TopMost \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den 'Zuoberst Status' f?r das GraphicsWindow (Z-Order, GW mu? bereits initialisiert sein).{\line}Das Fenster bleibt stets ?ber anderen Fenstern auch wenn diese fokusiert sind.{\line}"True" oder "False" (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b TransparentGW() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein transparentes GraphicsWindow (Style=0 dh. ohne Titelleiste und Rand, State=0).{\line}Ist vor allen anderen GraphicsWindow-, Controls- oder Shapes- Methoden, die ein Fenster erstellen, aufzurufen.{\line}F?r eine Ansicht, erst Inhalt im transparenten GraphicsWindow hinzuf?gen.{\line}zB. Erstellen eines nicht-Rechteck Fensters mittels transparentem png (f?r den Rand) per LDShapes.BackgroundImage.{\line}Die Transparenz kann mit BackgroundColor (als #AARRGGBB) angepasst werden, oder Opazit?t einer f?llenden (Bild-)Shape.{\line}Fallweise kann geringere Transparenz als 100% (BackgroundColor #AA >00) erforderlich sein (zB. Erkennen von Mausereignissen im leeren GW).{\line}Trotz CanResize = "True", Fenstergr??e nicht per Maus anpassbar.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\ClockWidget.sb}\par
\f0\pard\sb180\shading1000{\fs30\b Width \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Breite des GraphicsWindow (bei Verwendung von LDScrollBars).}\par
\f0\pard\sb300\shading2000{\fs36\b LDHID}\par
\f0\pard{\fs20 USB Steuerung f?r HID Ger?te (Human Interface Device).{\line}VID und PID (4-Zeichen HexCodes) f?r das Ger?t sind erforderlich.{\line}Nur HIDs funktionieren unter diesen Methoden.{\line}Sollte die meisten GameController, einfache Roboterger?te und Sensoren unterst?tzen.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDHID.sb, USB_HID.sb{\line}{\line}'DeviceID's unter{\line}HKLM\\SYSTEM\\CurrentControlSet\\Enum\\USB\\VID_vid&PID_pid\\}\par

\f0\pard\sb180\shading1000{\fs30\b AddDevice(VID,PID,name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Hinzuf?gen eines HID angeschlossenen Ger?tes mit dessen VID und PID.{\line}Die VID und PID sind 4-stellige (Hex)Werte, und zu finden in:{\line}Ger?temanager->Eigenschaften->Details->Hardware-IDs{\line}zB: HID\\VID_046D PID_C215 REV_0204 hat VID "046D" und PID "C215".{\line}Jedes Ger?t nur einmalig hinzuf?gen.}\par
\f0\pard\sb75{\fs24\b VID}\par
\f0\pard{\fs20 Die Ger?te VID (16bit VendorID).}\par
\f0\pard\sb75{\fs24\b PID}\par
\f0\pard{\fs20 Die Ger?te PID (16bit ProductID).}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der Name f?r das Ger?t.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" bei Erfolg, sonst "False".}\par
\f0\pard\sb180\shading1000{\fs30\b FindDevices() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Listet alle gefundenen HID Ger?te (Human Interface Device).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D Array aller gefundenen Ger?te.{\line}Die erste Dimension ist die Ger?tenummer (ab 1).{\line}Die zweite Dimension sind "VID", "PID" und "Description" und enth?lt die HexWerte von VID, PID und eine Ger?tebeschreibung.}\par
\f0\pard\sb180\shading1000{\fs30\b GetBits(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen 8-elementigen Array aus 1 und 0, die angeben ob ein Bit im Byte gesetzt ist.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die Bytenummer (0 bis 255).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 8-elementiger Bitarray (kleines Bit zuerst) bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Input \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn sich die HID Eingabe ?ndert.}\par
\f0\pard\sb180\shading1000{\fs30\b InputLength(name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die L?nge des Eingabeberichts f?r ein HID Ger?t.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der HID Ger?tename.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Bytes im Eingabedatensatz.}\par
\f0\pard\sb180\shading1000{\fs30\b LastDevice \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name f?r das letzte HID Ger?t welches eine Eingabe hatte.}\par
\f0\pard\sb180\shading1000{\fs30\b LastInput \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die letzten HID Eingabedaten als Array oder "".{\line}Dies ist ein Satz von Werten von 0 bis 255 (Bytes).}\par
\f0\pard\sb180\shading1000{\fs30\b Output(name,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet Daten an das HID Ger?t.{\line}Dies mu? ein Array von Bytes sein (0 bis 255).{\line}Der Array mu? ab 1 indexiert sein und die L?nge s. 'OutputLength' haben.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der HID Ger?tename.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die zu sendenden Daten.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False" f?r Datenbest?ndigkeit.}\par
\f0\pard\sb180\shading1000{\fs30\b OutputLength(name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die L?nge des Ausgabeberichts f?r ein HID Ger?t.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der HID Ger?tename.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Bytes im Ausgabedatensatz.}\par
\f0\pard\sb180\shading1000{\fs30\b Removed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn das HID Ger?t entfernt wird.}\par
\f0\pard\sb180\shading1000{\fs30\b SetBits(data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein Byte mittels 8-elementigem Array aus 1 und 0, die angeben ob ein Bit im Byte gesetzt ist.}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Ein 8-elementiger Bitarray aus 1 und 0 (kleines Bit zuerst).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Bytenummer (0 bis 255) bei Erfolg, sonst -1.}\par
\f0\pard\sb300\shading2000{\fs36\b LDImage}\par
\f0\pard{\fs20 Verschiedene zus?tzliche Methoden f?r Bearbeitung und Darstellungen von Bildern in ImageList (Intern: ImageList#).{\line}Standardwert f?r jeden Effektparameter ist "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 webcam\\motion-detection.sb, webcam.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Add(image,red,green,blue) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Addiert Farbwerte in einem ImageList Bild mit einem -/+ Wert (<0 dunkler, >0 heller).{\line}Ein Bild hat Pixel mit Werten f?r Rot, Gr?n und Blau im Bereich von 0 bis 255.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden Bildes.}\par
\f0\pard\sb75{\fs24\b red}\par
\f0\pard{\fs20 +/- Additionswert f?r Rotanteil.}\par
\f0\pard\sb75{\fs24\b green}\par
\f0\pard{\fs20 +/- Additionswert f?r Gr?nanteil.}\par
\f0\pard\sb75{\fs24\b blue}\par
\f0\pard{\fs20 +/- Additionswert f?r Blauanteil.}\par
\f0\pard\sb180\shading1000{\fs30\b AddImages(image1,image2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kombiniert 2 ImageList Bilder durch Addition der einzelnen Pixelfarbwerte (Intern: ImageList#+1).{\line}Ein Bild hat Pixel mit Werten f?r Rot, Gr?n und Blau im Bereich von 0 bis 255.{\line}Beide Bilder m?ssen die gleichen Abmessungen haben, sonst keine Verarbeitung.}\par
\f0\pard\sb75{\fs24\b image1}\par
\f0\pard{\fs20 Der Name des ersten ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b image2}\par
\f0\pard{\fs20 Der Name des zweiten ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen ImageList Bildes bei Erfolg, sonst "".{\line}Sind beide ImageList Bilder invers zueinander, ist das Ergebnisbild v?llig wei?.}\par
\f0\pard\sb180\shading1000{\fs30\b AddText(imageName,text,x,y,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt Text in ein existierendes ImageList Bild ein (aktuelle GraphicsWindow.Font.. Eigenschaften).}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Der Name des bestehenden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der einzuf?gende Text.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die -/0/+ linke Textposition im Bild [Pxl] (Standard: 0).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die -/0/+ obere Textposition im Bild [Pxl] (Standard: 0).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Textfarbe (Standard: Transparent).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'TextBild{\line}GraphicsWindow.FontSize = 30{\line}img = LDImage.NewImage(100,100, "Transparent"){\line}LDImage.AddText(img, "Rot", 0,23, "Red"){\line}LDImage.SaveAs(img, Program.Directory +"\\TextBild.png")}\par
\f0\pard\sb180\shading1000{\fs30\b CloseWorkingImage(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schlie?t und setzt das tempor?re Arbeitsbild zum Ausgangsbild zur?ck.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Das zuvor mit 'OpenWorkingImage' ge?ffnete Arbeitsbild.}\par
\f0\pard\sb180\shading1000{\fs30\b ColorMatrix(image,matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ColorMatrix Transformation f?r ein ImageList Bild. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.{\line}Format f?r ColorMatrix ist unterschiedlich und inkompatibel zum LDMatrix Format.{\line}Kann f?r alle Arten von Farbtransformationen verwendet werden, zB:{\line}http://msdn.microsoft.com/library/a7xw19wh.aspx{\line}http://docs.rainmeter.net/tips/colormatrix-guide{\line}http://softwarebydefault.com/2013/03/03/colomatrix-image-filters}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes (F?r Transparenz?nderung im 32b ARGB Format).}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Eine 5x5 Matrix im R,G,B,A,W Farbraum als 2D Array.{\line}zB. 'Sepia':{\line}cm[1]="1=0.393;2=0.349;3=0.272;4=0;5=0"{\line}cm[2]="1=0.769;2=0.686;3=0.534;4=0;5=0"{\line}cm[3]="1=0.189;2=0.168;3=0.131;4=0;5=0"{\line}cm[4]="1=0;2=0;3=0;4=1;5=0"{\line}cm[5]="1=0;2=0;3=0;4=0;5=1"}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Polaroid{\line}cm[1]="1=1.438;2=-0.062;3=-0.062;4=0;5=0"{\line}cm[2]="1=-0.122;2=1.378;3=-0.122;4=0;5=0"{\line}cm[3]="1=-0.016;2=-0.016;3=1.483;4=0;5=0"{\line}cm[4]=LDText.Split("0 0 0 1 0", " "){\line}cm[5]=LDText.Split("-0.03,0.05,-0.02,0,1",","){\line}'Schwarz/Wei?{\line}cm[1]="1=1.5;2=1.5;3=1.5;4=0;5=0"{\line}cm[2]="1=1.5;2=1.5;3=1.5;4=0;5=0"{\line}cm[3]="1=1.5;2=1.5;3=1.5;4=0;5=0"{\line}cm[4]="1=0;2=0;3=0;4=1;5=0"{\line}cm[5]="1=-1;2=-1;3=-1;4=0;5=1"}\par
\f0\pard\sb180\shading1000{\fs30\b Copy(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert ein ImageList Bild unter neue ImageList# (Intern: ImageList#+1).}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu kopierenden ImageList Bildes (Ein Dateipfad erstellt einen neuen LEEREN ImageList#+1 Eintrag).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen ImageList Bildes bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Crop(image,x,y,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Beschneidet ein ImageList Bild. Der Ausschnittsbereich mu? v?llig innerhalb des Bildes und GW liegen. ImageList# bleibt unver?ndert, bei ge?ndertem Bildausschnitt.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Das zu beschneidende ImageList Bild.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die linke Position (ab 0) f?r den Ankerpunkt des Bildausschnittes [Pxl].}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die obere Position (ab 0) f?r den Ankerpunkt des Bildausschnittes [Pxl].}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des Bildausschnittes [Pxl].}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Bildausschnittes [Pxl].}\par
\f0\pard\sb180\shading1000{\fs30\b DifferenceImages(image1,image2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Differenziert 2 ImageList Bilder durch Subtraktion der einzelnen Pixelfarbwerte (Intern: ImageList#+1).{\line}Ein Bild hat Pixel mit Werten f?r Rot, Gr?n und Blau im Bereich von 0 bis 255.{\line}Beide Bilder m?ssen gleiche Abmessungen haben, sonst keine Verarbeitung.}\par
\f0\pard\sb75{\fs24\b image1}\par
\f0\pard{\fs20 Der Name des ersten ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b image2}\par
\f0\pard{\fs20 Der Name des zweiten ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen ImageList Bildes bei Erfolg, sonst "".{\line}Sind beide ImageList Bilder gleich, ist das Ergebnisbild v?llig schwarz. Helle Bereiche bei gr??eren Farbunterschieden.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectAccent(image,hue,range) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Farbtonakzent Effekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b hue}\par
\f0\pard{\fs20 Der Farbton f?r den Farbakzent (0 bis 360, Standard: 0  dh. Rot).}\par
\f0\pard\sb75{\fs24\b range}\par
\f0\pard{\fs20 Der hervorzuhebende Farbtonbereich (>0, Standard: 40).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBlocks(image,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Unsch?rfeeffekt (Verpixelung) ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Gr??enverh?ltnis (>0, Standard: 5).{\line}Das Bild wird um diesen Faktor verkleinert und wieder auf Originalgr??e gesetzt (geringere Aufl?sung, Verwischung).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBlue(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Blau ([R,G,B]x[0,0,1]). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBulge(image,factor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen W?lbungseffekt ein (?hnlich FishEye/Fischauge). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b factor}\par
\f0\pard{\fs20 Der Ausbuchtungsfaktor, kann <1 sein f?r Einengungseffekt (Standard: 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectCartoon(image,radius,levels,inverse) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Cartooneffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Der Pixelradius f?r den Cartooneffekt (ungerade Ganzzahl, Standard: 7).}\par
\f0\pard\sb75{\fs24\b levels}\par
\f0\pard{\fs20 Die Anzahl der Intensit?tsgrade (1 bis 255, Standard: 10).}\par
\f0\pard\sb75{\fs24\b inverse}\par
\f0\pard{\fs20 Der Schwellenwert f?r SW-Invertierung (1 bis 254, Standard: 40).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectCharcoal(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Kohleskizze Effekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectContrast(image,contrast) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt h?heren Kontrast ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b contrast}\par
\f0\pard{\fs20 Kontrastfaktor (>0, Standard: 2), <1 reduziert Kontrast.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectCyan(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Cyan (EffectGray * [0,G,B]). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectDefaults \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt einen Array mit Standardwerten f?r Effektparameter (s. 'GetEffects' f?r Effektnamen und -nummern).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectEdge(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Prewitt Kanteneffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectFishEye(image,factor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Fischauge Effekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b factor}\par
\f0\pard{\fs20 Der Weitwinkel Faktor, sollte >1 sein (Standard: 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectFuzzy(image,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Unsch?rfe-Effekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Der Pixelbereich f?r Unsch?rfe (>0, Standard: 4).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGamma(image,gamma) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Gamma Effekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b gamma}\par
\f0\pard{\fs20 Der Gammafaktor, Werte <1 erhellen und >1 verdunkeln (Standard: 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGray(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Schwarz/Wei? (Grayscale, gewichtet). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGreen(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Gr?n ([R,G,B]x[0,1,0]). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectHue(image,hue) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ndern des HSL Farbtons H. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b hue}\par
\f0\pard{\fs20 Der Farbtonwert (0 bis 360, Standard: 180).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectInverse(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Invers (Negativ, 255-[R,G,B]). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectJagged(image,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Zackeneffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Der Pixelbereich f?r den Zackeneffekt (>0, Standard: 4).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectLightness(image,lightness) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ndern der HSL Farbhelligkeit L. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b lightness}\par
\f0\pard{\fs20 Der Helligkeitsfaktor (>0, Standard: 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectMagenta(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Magenta (EffectGray * [R,0,B]). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectNoiseRemoval(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Bildger?usch Reduktionseffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectOilPaint(image,radius,levels) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen ?lfarbe Effekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Der Pixelradius f?r den ?lfarbe Effekt (ungerade Ganzzahl, Standard: 7).}\par
\f0\pard\sb75{\fs24\b levels}\par
\f0\pard{\fs20 Anzahl der Intensit?tsgrade (1 bis 255, Standard: 20).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectPixelate(image,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Verpixelungseffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Vergr?berungsfaktor [Pxl] oder "" (Standard: 16).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectPosterise(image,level) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Postereffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b level}\par
\f0\pard{\fs20 Der Effektgrad (2 bis 255, Standard: 50), 1-Originalbild, 256-v?llig schwarz.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectRed(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Rot ([R,G,B]x[1,0,0]). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectReflect(image,flip) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Kippeffekt ein (Spiegelung an y- oder x-Bildachse). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b flip}\par
\f0\pard{\fs20 0  Li<->Re, horizontal um y-Achse (Standard){\line}1  Ob<->Unt, vertikal um x-Achse.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectRotate(image,rotation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotationseffekt in 90? Schritten. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.{\line}M?glichst statt s. 'LDImage.Rotate' verwenden, da verlustfrei.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b rotation}\par
\f0\pard{\fs20 Die Drehung in 90? Schritten:{\line}0  +90 (rechts, Standard){\line}1  180{\line}2  270 (-90, links)}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSaturation(image,saturation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ndern der HSL Farbs?ttigung S. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b saturation}\par
\f0\pard{\fs20 Der S?ttigungsfaktor (>0, Standard: 2).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSepia(image,threshold) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Sepiaeffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b threshold}\par
\f0\pard{\fs20 Der Sepia Schwellenwert (1-grau bis 255-gelb, Standard: 30).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSketch(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Stiftskizze Effekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSnow(image,level) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Schneeeffekt ein (4% wei?e Pixel). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b level}\par
\f0\pard{\fs20 Verh?ltniswert '1/level' zuf?llig gesetzte 'Schnee' Pixel (>0, Standard: 25 - also jedes 25. Pixel).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSolarise(image,power) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Solarisierungseffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b power}\par
\f0\pard{\fs20 Die St?rke/Potenz der Solarisierung (>0, Standard: 2 dh. quadratisch).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSwirl(image,factor) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Wirbeleffekt ein. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b factor}\par
\f0\pard{\fs20 Der Verwirbelungsfaktor (Standard: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b EffectYellow(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Gelb (EffectGray * [R,G,0]). ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b GetEffects() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle verf?gbaren LDImage- und LDWebCam Effekte als Array (s. EffectDefaults f?r Standardwerte).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Effektnamen, indexiert durch die Effektnummer.}\par
\f0\pard\sb180\shading1000{\fs30\b GetImagePixels(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen 2D Array mit allen Pixelfarbwerten in einem ImageList Bild (s. SetImagePixels).}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D Array aller Pixelfarben (#AARRGGBB) des Bildes, indexiert durch [x][y] mit x,y von 1 bis Bildbreite/-h?he.}\par
\f0\pard\sb180\shading1000{\fs30\b GetPixel(image,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Farbe eines Pixels in einem ImageList Bild. Transparenz in ImageList ist #D3D3D3 - 'LightGray' (#D4D0C8 ??).}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des ImageList Bildes (vorzugsweise von bmp, png).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Pixels (1 bis Bildbreite).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Pixels (1 bis Bildh?he).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Pixelfarbe als #AARRGGBB bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetWorkingImagePixel(image,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Hex Farbe eines Pixels in einem tempor?ren Arbeitsbild.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Das zuvor mit 'OpenWorkingImage' ge?ffnete Arbeitsbild.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Pixels (1 bis Bildbreite).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Pixels (1 bis Bildh?he).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Pixelfarbe als #AARRGGBB bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetWorkingImagePixelARGB(image,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Farbkomponenten eines Pixels in einem tempor?ren Arbeitsbild.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Das zuvor mit 'OpenWorkingImage' ge?ffnete Arbeitsbild.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Pixels (1 bis Bildbreite).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Pixels (1 bis Bildh?he).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Pixelfarbe als Array der A,R,G,B Komponenten, indexiert durch "A", "R", "G", "B". "" bei Mi?erfolg.}\par
\f0\pard\sb180\shading1000{\fs30\b HeightMap2NormalMap(image,scale) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein neues ImageList Bild einer Normalenkarte aus einer H?henkarte (Intern: ImageList#+1).{\line}Die H?he wird bestimmt durch die Helligkeit eines Pixels (h?her = heller).}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Die H?henkarte als ImageList Bild.}\par
\f0\pard\sb75{\fs24\b scale}\par
\f0\pard{\fs20 Der Skalierungsfaktor f?r die Erh?hung (Standard: 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name f?r das neue ImageList Bild der resultierenden Normalenkarte.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 https://en.wikipedia.org/wiki/Heightmap}\par
\f0\pard\sb180\shading1000{\fs30\b Histogram(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Statistik der Pixelfarbwerte in einem ImageList Bild.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D Array mit Farbstatistik (indexiert durch 1,2,3 f?r R,G,B) mit Unterindizes 0 bis 255 und Werten f?r die Pixelanzahl.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 hist = LDImage.Histogram(img){\line}rotHist = hist[1] ' 256-elementiger Array "cR(0-255)=nPxl;"}\par
\f0\pard\sb180\shading1000{\fs30\b LoadSVG(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Laden einer lokalen SVG Bilddatei (Skalierbare Vektorgrafik) als neues ImageList Bild (Intern: ImageList#+1).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad der zu ladenden SVG Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen ImageList Bildes bei Erfolg, sonst "" bzw. Fehlermeldung.}\par
\f0\pard\sb180\shading1000{\fs30\b MakeTransparent(image,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt alle Pixel einer angegebenen Farbe in einem ImageList Bild zu 'Transparent' (32b ARGB).{\line}s.a. 'ReplaceColour'}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die als 'Transparent' zu setzende Farbe.}\par
\f0\pard\sb180\shading1000{\fs30\b MetaData(imageFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt verf?gbare Metadaten (Exif, Thumbnail usw.) zu einer Bilddatei als Array.}\par
\f0\pard\sb75{\fs24\b imageFile}\par
\f0\pard{\fs20 Der volle Pfad der Bilddatei (kein ImageList Bild).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Werten der Metadaten, indexiert durch deren Hex ID (0 bis "A302", Werte mit a-f in "") gem??:{\line}http://msdn.microsoft.com/library/system.drawing.imaging.propertyitem.id.aspx (ID Liste).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 meta = LDImage.MetaData(picPfad){\line}imageWidth = meta[100] 'Breite{\line}imageHeight = meta[101] 'H?he{\line}bpSample = meta[102] 'Bits/Farbkanal{\line}dateTaken = meta[132] 'Aufnahmedatum}\par
\f0\pard\sb180\shading1000{\fs30\b Multiply(image,red,green,blue) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Multipiziert die Farbwerte in einem ImageList Bild mit einem Faktor (<1 dunkler, >1 heller).{\line}Ein Bild hat Pixel mit Werten f?r Rot, Gr?n und Blau im Bereich von 0 bis 255.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden Bildes.}\par
\f0\pard\sb75{\fs24\b red}\par
\f0\pard{\fs20 Der Faktor f?r den Rotanteil.}\par
\f0\pard\sb75{\fs24\b green}\par
\f0\pard{\fs20 Der Faktor f?r den Gr?nanteil.}\par
\f0\pard\sb75{\fs24\b blue}\par
\f0\pard{\fs20 Der Faktor f?r den Blauanteil.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 A. Sepia Effekt:{\line} LDImage.EffectGray(img){\line} LDImage.Multiply(img, 1,0.95,0.82){\line}B. Farbfilter:{\line} 'LDImage.EffectGray(img){\line} c = LDColours.FARBE{\line} cR = LDColours.GetRed(c)/255{\line} cG = LDColours.GetGreen(c)/255{\line} cB = LDColours.GetBlue(c)/255{\line} LDImage.Multiply(img, cR,cG,cB)}\par
\f0\pard\sb180\shading1000{\fs30\b NewImage(width,height,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein neues einf?rbiges 32bitARGB Bild in ImageList (Intern: ImageList#+1). Das GraphicsWindow mu? dabei angezeigt sein.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des neuen Bildes [Pxl] (>=1).}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des neuen Bildes [Pxl] (>=1).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die Einheitsfarbe des neuen Bildes als #(AA)RRGGBB (Standard: "#00000000") oder (LDColours.)Farbname.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neu erstellten ImageList Bildes bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b NormalMap(shapeName,sourceX,sourceY,sourceZ,texture,ambient,intensity) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bearbeitet ein Bild (oder bearbeitetes Bild bei gesetzter Textur) zur Anzeige eines Graustufen Schatteneffektes, basierend auf dem Abbild einer Normalenkarte.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Eine Bildshape (Shapes.AddImage) mit dem Bild der Normalenkarte.{\line}Die R,G,B Farbkomponenten definieren die Normalvektoren auf ein 3D Abbild.}\par
\f0\pard\sb75{\fs24\b sourceX}\par
\f0\pard{\fs20 Die x-Position der Lichtquelle relativ zum Abbild.}\par
\f0\pard\sb75{\fs24\b sourceY}\par
\f0\pard{\fs20 Die y-Position der Lichtquelle relativ zum Abbild.}\par
\f0\pard\sb75{\fs24\b sourceZ}\par
\f0\pard{\fs20 Die z-Position der Lichtquelle relativ zum Abbild. Dies ist die H?he ?ber dem Bild.}\par
\f0\pard\sb75{\fs24\b texture}\par
\f0\pard{\fs20 Ein optionales ImageList Bild mit Textur (Farbe) zur Bearbeitung (oder ""). Selbe Abmessungen wie die Normalenkarte.{\line}Diese Textur kann in weiteren Aufrufen ge?ndert werden.}\par
\f0\pard\sb75{\fs24\b ambient}\par
\f0\pard{\fs20 Optionale Intensit?t f?r Umgebungslicht bei gesetzter Textur (Standard: 0.3).}\par
\f0\pard\sb75{\fs24\b intensity}\par
\f0\pard{\fs20 Optionale Lichtst?rke bei gesetzter Textur (Standard: 2).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://en.wikipedia.org/wiki/Normal_mapping}\par
\f0\pard\sb180\shading1000{\fs30\b OpenWorkingImage(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ffnet ein tempor?res Arbeitsbild zur schnellen Pixelmanipulation.{\line}Nach Bearbeitung sollte dieses tempor?re Arbeitsbild mit 'CloseWorkingImage' zum Ausgangsbild zur?ckgesetzt werden.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Das zu ?ffnende ImageList Bild zum Verwenden als tempor?res Arbeitsbild.}\par
\f0\pard\sb180\shading1000{\fs30\b Remove(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt ein ImageList Bild. Indexnummern (ImageList#) bleiben unver?ndert. Nur Bild wird aus ImageList# entfernt, soda? dieser Eintrag dann leer ist.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des aus ImageList zu entfernenden Bildes (Intern: ImageList#).}\par
\f0\pard\sb180\shading1000{\fs30\b ReplaceColour(image,colourFrom,colourTo,tolerance) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ersetzt alle Pixel einer angegebenen Farbe (bzw. -bereich) in einem ImageList Bild durch eine andere Farbe (24b RGB).{\line}s.a. 'MakeTransparent'. Bild ev. erst zu 32bit konvertieren s. 'To32bitARGB'.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b colourFrom}\par
\f0\pard{\fs20 Die zu ersetzende Farbe.}\par
\f0\pard\sb75{\fs24\b colourTo}\par
\f0\pard{\fs20 Die anzuwendende Ersatzfarbe ('Transparent' gibt 'White').}\par
\f0\pard\sb75{\fs24\b tolerance}\par
\f0\pard{\fs20 Die Toleranz f?r die zu ersetzende Farbe (Standard: 0 -exakt, bis 255 -alles).{\line}Alle ARGB Pixelwerte innerhalb dieser Toleranz werden ersetzt.}\par
\f0\pard\sb180\shading1000{\fs30\b Resize(image,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine neue Gr??e f?r ein gesamtes ImageList Bild (Thumbnail Bild). ImageList# bleibt unver?ndert, bei ge?nderter Bildgr??e.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die neue Breite [Pxl].}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die neue H?he [Pxl].}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 F?r gleichbleibendes Verh?ltnis width/height = Const beibehalten.}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(image,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Drehen eines ImageList Bildes. ImageList# bleibt unver?ndert, bei ge?nderter Bildansicht.{\line}M?glichst vermeiden, da merklicher Qualit?tsverlust. F?r n*90? Drehung(en) besser s. EffectRotate verwenden.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu drehenden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Rotationswinkel [Grad] des Bildes im Uhrzeigersinn.}\par
\f0\pard\sb180\shading1000{\fs30\b Save(image,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert ein ImageList Bild als jpg Bilddatei.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu speichernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad zum Speichern des Bildes (im jpeg-Format, unabh?ngig von Erweiterung).}\par
\f0\pard\sb180\shading1000{\fs30\b SaveAs(image,fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert ein ImageList Bild als verschiedene Dateiformate (bestimmt durch Dateierweiterung).}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu speichernden ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Dateipfad zum Speichern des Bildes. Eine bestehende Datei wird ?berschrieben.{\line}Erlaubte Dateityp Erweiterungen sind bmp, gif, jp(e)g, png, tiff oder ico (speichert als png Typ).}\par
\f0\pard\sb180\shading1000{\fs30\b SetImagePixels(pixels) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein neues ImageList Bild aus einem 2D Array mit #(AA)RRGGBB Pixelfarbwerten (Intern: ImageList#+1), s. GetImagePixels f?r Pixelarray.}\par
\f0\pard\sb75{\fs24\b pixels}\par
\f0\pard{\fs20 Ein 2D Array mit Pixelfarben f?r das Bild, indexiert durch [x][y] mit x,y von 1 bis Bildbreite/-h?he.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neu erstellten ImageList Bildes vom Pixelarray.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'runder Bildrahmen (Passepartout), Radius r:{\line}For x = 1 To 2*r{\line} For y = 1 To 2*r{\line}  If (x-r)*(x-r)+(y-r)*(y-r)<r*r Then{\line}   pxl[x][y] = "Transparent" 'innen{\line}  Else{\line}   pxl[x][y] = "Peru" 'Rahmen{\line}  EndIf{\line} EndFor{\line}EndFor{\line}img = LDImage.SetImagePixels(pxl)}\par
\f0\pard\sb180\shading1000{\fs30\b SetPixel(image,x,y,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Farbe eines Pixels in einem ImageList Bild.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des ImageList Bildes (vorzugsweise von bmp, png).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Pixels (1 bis Bildbreite).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Pixels (1 bis Bildh?he).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die zu setzende Farbe, zB. (LDColours.)Farbname oder #(AA)RRGGBB.}\par
\f0\pard\sb180\shading1000{\fs30\b SetWorkingImagePixel(image,x,y,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Farbe eines Pixels in einem tempor?ren Arbeitsbild.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Das zuvor mit 'OpenWorkingImage' ge?ffnete Arbeitsbild.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Pixels (1 bis Bildbreite).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Pixels (1 bis Bildh?he).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die zu setzende Pixelfarbe als #(AA)RRGGBB.}\par
\f0\pard\sb180\shading1000{\fs30\b SplitImage(imageName,countX,countY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt zerteilte Einzelbilder von einem angegebenen (ImageList) Gesamtbild als Array (Intern: ImageList#+1, .., #+x*y).}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Der Name des zu ladenden ImageList Bildes oder voller Pfad der Bilddatei (lokal oder Netzwerk).}\par
\f0\pard\sb75{\fs24\b countX}\par
\f0\pard{\fs20 Die Anzahl der Teilbilder in x-Richtung (Spalten).}\par
\f0\pard\sb75{\fs24\b countY}\par
\f0\pard{\fs20 Die Anzahl der Teilbilder in y-Richtung (Zeilen).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D Array[x][y] mit resultierenden ImageList# Bildern, wobei die Indizes (1-countX) die Spalten und deren Innerarrays (1-countY) die Zeilen darstellen.}\par
\f0\pard\sb180\shading1000{\fs30\b Statistics(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Minimum, Maximum, Mittelwert und Standardabweichung f?r Pixelfarben in einem ImageList Bild.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des ImageList Bildes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2D Array mit Statistikwerten (indexiert durch "Min", "Max", "Mean", "STD") mit Unterindizes 1,2,3 f?r R,G,B und Werten 0 bis 255.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 stat = LDImage.Statistics(img){\line}min = stat["Min"] ' "1=cR;2=cG;3=cB;"}\par
\f0\pard\sb180\shading1000{\fs30\b To32bitARGB(image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert ein ImageList Bild zum Format ARGB (Alphakanal mit 32bit/Pxl) wenn erforderlich (?berpr?fung).}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Der Name des zu ?ndernden ImageList Bildes (zB. geladenes Jpg Bild).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 img = ImageList.LoadImage(jpgBild){\line}LDImage.To32bitARGB(img) 'mit Alphakanal}\par
\f0\pard\sb180\shading1000{\fs30\b UseFastPixelMethods \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Verwendung einer schnellen Methode zur Pixelmanipulation?  "True" (Standard) oder "False".{\line}Diese (LockBits) Methode kann hiermit auch deaktiviert werden.}\par
\f0\pard\sb300\shading2000{\fs36\b LDInline}\par
\f0\pard{\fs20 Einbinden von C#, VB oder JScript Code zum Ausf?hren w?hrend der Programmlaufzeit.{\line}Werden mehrere Namespaces oder Klassen verwendet, sollten alle Methoden-, Eigenschaften- oder Ereignisnamen eindeutig verwendet werden.{\line}Alternativ kann ein vollqualifizierter 'Namespace.Typ.Name' verwendet werden.{\line}Kann zum Kompilieren von Extensions und zusammen mit weiteren externen, kompilierten (.NET) Dlls verwendet werden.{\line}Methode, Eigenschaft, Ereignis, Klasse und Referenzen k?nnen ?bernommen werden (nur 'public static').{\line}{\line}Die Assemblies der aktuellen Anwendung werden automatisch referenziert.{\line}Abh?ngig von verwendeten .NET Methoden k?nnen zus?tzliche Assemblies erforderlich sein, die nach vollem Dll Pfad zu referenzieren sind.{\line}Assembly Dlls sind meist an folgenden oder ?hnlichen Orten zu finden:{\line}C:\\Windows\\Microsoft.NET\\Framework\\v?.?*\\ (zB. v3.5 oder v4.0..){\line}C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\v3.5\\{\line}C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework\\v4.0\\{\line}Bei Ausgabe im TextWindow sollte dieses bereits vor Aufruf der Methoden ge?ffnet werden (sonst ev. keine Ausgabe).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDInline.sb, LDInline-Reflection.sb (incl. code1.cs/code1.vb)}\par

\f0\pard\sb180\shading1000{\fs30\b Call(method,args) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufruf einer zuvor inkludierten Methode. Binary zuvor geladen per LoadDLL od. virtuell kompilierte Source per IncludeCS/-VB/-JScript.{\line}Bei Verwendung externer Dlls m?ssen diese im 'SB\\Lib' oder Programmordner liegen.}\par
\f0\pard\sb75{\fs24\b method}\par
\f0\pard{\fs20 Der Name der Methode in "".}\par
\f0\pard\sb75{\fs24\b args}\par
\f0\pard{\fs20 Die Argumente f?r die Methode. "" f?r ohne, ein Einzelwert oder ein Array (f?r mehrere Werte, KEINE "" Argumente).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das R?ckgabeergebnis(se) des Aufrufs oder "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Event(Event,callBack) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die aufzurufende Subroutine f?r ein zuvor inkludiertes Ereignis. Binary zuvor geladen per LoadDLL od. virtuell kompilierte Source per IncludeCS/-VB.{\line}Bei Verwendung externer Dlls m?ssen diese im 'SB\\Lib' oder Programmordner liegen.}\par
\f0\pard\sb75{\fs24\b Event}\par
\f0\pard{\fs20 Der Ereignisname in "".}\par
\f0\pard\sb75{\fs24\b callBack}\par
\f0\pard{\fs20 Die aufzurufende SB Event-Sub.}\par
\f0\pard\sb180\shading1000{\fs30\b Get(property) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Wert einer zuvor inkludierten Eigenschaft. Binary zuvor geladen per LoadDLL od. virtuell kompilierte Source per IncludeCS/-VB/-JScript.{\line}Bei Verwendung externer Dlls m?ssen diese im 'SB\\Lib' oder Programmordner liegen.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 Der Name der Eigenschaft in "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert der Eigenschaft oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAssemblies(fullName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle verwendeten Inline Assemblies als Array (Reflektion).{\line}Dies sind die referenzierten Assemblies welche aktuell auch verwendet werden.}\par
\f0\pard\sb75{\fs24\b fullName}\par
\f0\pard{\fs20 Den voll angegebenen Name (mit Version, Culture und PublicKeyToken) ermitteln?  "True" oder "False" (nur Basisname).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Assemblynamen und Dll Pfaden als "name(, .., ..)=dllPfad;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetEvents() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle geladenen Inline Ereignisse als Array (Reflektion).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Ereignisnamen und Handler-Typ als "event=typ;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetMethodParameters(method) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle Parameter (Argumente) einer geladenen Inline Methode als Array (Reflektion).}\par
\f0\pard\sb75{\fs24\b method}\par
\f0\pard{\fs20 Der Name der Methode in "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Parameternamen und Typ als "param=typ;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetMethods(fullName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle geladenen Inline Methoden (auch innerhalb Eigenschaften) als Array (Reflektion).}\par
\f0\pard\sb75{\fs24\b fullName}\par
\f0\pard{\fs20 Vollen Methodenname (mit 'Klasse.') ermitteln?  "True" oder "False" (nur Basisname).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Methodenamen und R?ckgabetyp (bzw. System.Void) als "method=typ;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetProperties() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle geladenen Inline Eigenschaften als Array (Reflektion).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Namen der Eigenschaften und Typ als "prop=typ;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetReferences(fullName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle hinzugef?gten Inline Referenzen als Array (Reflektion, nur nach IncludeCS/-VB via Quellcode).{\line}Dies sind die hinzugef?gten Referenzen, diese k?nnen verwendet werden oder auch nicht.}\par
\f0\pard\sb75{\fs24\b fullName}\par
\f0\pard{\fs20 Den voll angegebenen Name (mit Version, Culture und PublicKeyToken) ermitteln?  "True" oder "False" ( nur Basisname).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den angegebenen Referenznamen und Dll Pfaden als "name(, .., ..)=dllPfad;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetTypes() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle geladenen Inline Klassentypen als Array (Reflektion).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Klassentypen und Namespace als "klassenName=namespace;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b IncludeCS(source,assemblies,dllName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Inkludiert und kompiliert eine C# Klasse(n). Kann der Inhalt einer per 'File.ReadContents' gelesenen Datei sein.{\line}Zum Erstellen der Dll Datei mu? Schreibberechtigung im Ordner bestehen. Zum Direktladen einer bestehenden Dll s. LoadDLL.}\par
\f0\pard\sb75{\fs24\b source}\par
\f0\pard{\fs20 Der C# Quellcode.}\par
\f0\pard\sb75{\fs24\b assemblies}\par
\f0\pard{\fs20 Ein Array ev. zus?tzlich erforderlicher Assemblies. "" f?r automatisches Referenzieren/Laden (Angabe f?r SBLibrary.dll, Microsoft.VisualBasic.dll ist nicht erforderlich).}\par
\f0\pard\sb75{\fs24\b dllName}\par
\f0\pard{\fs20 Optionaler Dateiname zum Erstellen einer Dll (+ .xml) im akt. Ordner. "" f?r virtuelle Ausf?hrung (Erstellen+Laden) im Arbeitsspeicher.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b IncludeJScript(source,assemblies,dllName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Inkludiert und kompiliert ein JScript Modul(e) (public class NAME). Kann der Inhalt einer per 'File.ReadContents' gelesenen Datei sein.{\line}Zum Erstellen der Dll Datei mu? Schreibberechtigung im Ordner bestehen. Zum Direktladen einer bestehenden Dll s. LoadDLL.}\par
\f0\pard\sb75{\fs24\b source}\par
\f0\pard{\fs20 Der JScript Quellcode.}\par
\f0\pard\sb75{\fs24\b assemblies}\par
\f0\pard{\fs20 Ein Array ev. zus?tzlich erforderlicher Assemblies. "" f?r automatisches Referenzieren/Laden (Angabe f?r SBLibrary.dll ist nicht erforderlich).}\par
\f0\pard\sb75{\fs24\b dllName}\par
\f0\pard{\fs20 Optionaler Dateiname zum Erstellen einer Dll im akt. Ordner. "" f?r virtuelle Ausf?hrung (Erstellen+Laden) im Arbeitsspeicher.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b IncludeVB(source,assemblies,dllName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Inkludiert und kompiliert ein VB Modul(e). Kann der Inhalt einer per 'File.ReadContents' gelesenen Datei sein.{\line}Zum Erstellen der Dll Datei mu? Schreibberechtigung im Ordner bestehen. Zum Direktladen einer bestehenden Dll s. LoadDLL.}\par
\f0\pard\sb75{\fs24\b source}\par
\f0\pard{\fs20 Der VB Quellcode.}\par
\f0\pard\sb75{\fs24\b assemblies}\par
\f0\pard{\fs20 Ein Array ev. zus?tzlich erforderlicher Assemblies. "" f?r automatisches Referenzieren/Laden (Angabe f?r SBLibrary.dll ist nicht erforderlich).}\par
\f0\pard\sb75{\fs24\b dllName}\par
\f0\pard{\fs20 Optionaler Dateiname zum Erstellen einer Dll (+ .xml) im akt. Ordner. "" f?r virtuelle Ausf?hrung (Erstellen+Laden) im Arbeitsspeicher.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b LoadDLL(dllName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verwenden einer zuvor kompilierten und gespeicherten .NET Dll (Aufruf direkt vom Quell- oder 'SB\\Lib' Ordner). Obsolet f?r virtuell im Arbeitsspeicher erstellte Dll (s. Include.. Methoden).}\par
\f0\pard\sb75{\fs24\b dllName}\par
\f0\pard{\fs20 Der Pfad zur Dll Datei.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Zum Laden einer Assembly.exe, diese erst zu Assembly.dll umbenennen.}\par
\f0\pard\sb180\shading1000{\fs30\b Set(property,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Wert einer zuvor inkludierten Eigenschaft. Binary zuvor geladen per LoadDLL od. virtuell kompilierte Source per IncludeCS/-VB/-JScript.{\line}Bei Verwendung externer Dlls m?ssen diese im 'SB\\Lib' oder Programmordner liegen.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 Der Name der Eigenschaft in "".}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der Wert der Eigenschaft.}\par
\f0\pard\sb300\shading2000{\fs36\b LDIOWarrior}\par
\f0\pard{\fs20 Zugriff auf IO-Warrior Ger?te (http://www.codemercs.com/io-warrior/?L=0).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDIOWarrior.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Detatch() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Auswerfen/Abtrennen aller IO-Warrior Ger?te.}\par
\f0\pard\sb180\shading1000{\fs30\b GetName(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Ger?tename.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Ger?tename oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetPID(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die PID des Ger?tes.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Ger?te-PID (Hex) oder 0.}\par
\f0\pard\sb180\shading1000{\fs30\b GetReportSize(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Berichtgr??e.{\line}Anzahl von Bytes beim Lesen/Schreiben.{\line}Dies ist die Berichtgr??e f?r Kanal 0.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Berichtgr??e oder 0.}\par
\f0\pard\sb180\shading1000{\fs30\b GetSerialNumber(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Seriennummer des Ger?tes.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Ger?te-Seriennummer oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetSpecialReportSize(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die spezielle Berichtgr??e.{\line}Anzahl von Bytes beim speziellen Lesen/Schreiben.{\line}Dies ist die Berichtgr??e f?r Kanal 1.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die spezielle Berichtgr??e oder 0.}\par
\f0\pard\sb180\shading1000{\fs30\b GetVersion(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Firmware Version des Ger?tes.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Ger?tefirmware Version oder 0.}\par
\f0\pard\sb180\shading1000{\fs30\b GetVID() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die VID (ist allen IOWarrior Typen gemeinsam) des Ger?tes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Ger?te-VID (Hex) oder 0.}\par
\f0\pard\sb180\shading1000{\fs30\b Initialise() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Initialisierung f?r IO-Warrior Ger?te.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der gefundenen Ger?te.}\par
\f0\pard\sb180\shading1000{\fs30\b LastError() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den letzten System Fehlercode.{\line}"" f?r keinen Fehler (ev. nur zweckm??ig zur detailierten Fehleranalyse untergeordneter Systemaufrufe).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die letzte Fehlernummer.}\par
\f0\pard\sb180\shading1000{\fs30\b LCDWrite(id,text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schreibt Text an die LCD (nicht getestet).}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der zu schreibende Text.}\par
\f0\pard\sb180\shading1000{\fs30\b Read(id,channel,blocking,count) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Lesen vom IO-Warrior Ger?t.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b channel}\par
\f0\pard{\fs20 Der Lesekanal (ab 0).}\par
\f0\pard\sb75{\fs24\b blocking}\par
\f0\pard{\fs20 "True" (R?ckgabe nach einer Status?nderung) oder "False" (R?ckgabe mit aktuellem Status).}\par
\f0\pard\sb75{\fs24\b count}\par
\f0\pard{\fs20 Die Anzahl zu lesender Bytes. Wenn null, wird Berichtgr??e 'ReportSize' verwendet f?r Kanal 0 bzw. 'SpecialReportSize' f?r Kanal 1.{\line}s. GetReportSize und GetSpecialReportSize}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ausgelesenen Bytes (0 bis 255) als Array.}\par
\f0\pard\sb180\shading1000{\fs30\b Timeout \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Die Timeout-Dauer f?r Lesen und Schreiben in ms (Standard: 1000).}\par
\f0\pard\sb180\shading1000{\fs30\b Write(id,channel,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schreiben von Bytes in das IO-Warrior Ger?t.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die Ger?tenummmer (ab 1).}\par
\f0\pard\sb75{\fs24\b channel}\par
\f0\pard{\fs20 Der Schreibkanal (ab 0).}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Ein Array der zu sendenden Bytes (0 bis 255).{\line}Die Arraygr??e sollte betragen 'ReportSize' f?r Kanal 0 bzw. 'SpecialReportSize' f?r Kanal 1.{\line}s. GetReportSize und GetSpecialReportSize}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl erfolgreich geschriebener Bytes.}\par
\f0\pard\sb300\shading2000{\fs36\b LDList}\par
\f0\pard{\fs20 Bietet M?glichkeiten zum Speichern von Werten (Zahl, String, Var) wie in einem 1D Array, der sich selbst neuordnet, sobald Elemente hinzugef?gt oder entfernt werden.{\line}Eine Liste ist ein effizienter Arrayspeicher (weit schneller als SB Arrays), kann durch Ganzzahlen indexiert werden und bietet diverse weitere Methoden.{\line}Die Indexierung (ab 1) wird automatisch aktualisiert sobald sich die Liste ?ndert. Listenname vordefiniert zB. list = "" oder in "" (Intern: List#).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 3D-samples\\3DRubicCube.sb{\line}other-samples\\LDFastShapes.sb{\line}http://social.technet.microsoft.com/wiki/contents/articles/24946.small-basic-list-extension.aspx}\par

\f0\pard\sb180\shading1000{\fs30\b Add(listName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Wert am Ende einer angegebenen Liste hinzu.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der anzuf?gende Wert (zB. String, SB Array, Zahl).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b Append(listName1,listName2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt am Ende der ersten Liste eine zweite Liste hinzu.}\par
\f0\pard\sb75{\fs24\b listName1}\par
\f0\pard{\fs20 Der Name der ersten Liste.}\par
\f0\pard\sb75{\fs24\b listName2}\par
\f0\pard{\fs20 Der Name der zweiten Liste zum Anf?gen an listName1.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b Clear(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt alle Werte von einer angegebenen Liste.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b Contains(listName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ob ein angegebener Wert in einer Liste enthalten ist.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der gesuchte Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Copy(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert eine Liste (Intern: List#+1).}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Listenkopie bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Count(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der Elemente in der angegebenen Liste.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromIndices(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert alle Indizes eines SB Array in eine neue Liste (Intern: List#+1).}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 Der Name des SB Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der erstellten Liste bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b CreateFromValues(sbArray) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert alle Werte eines SB Array in eine neue Liste (Intern: List#+1).{\line}Die Arrayindizes werden in der Liste ignoriert.}\par
\f0\pard\sb75{\fs24\b sbArray}\par
\f0\pard{\fs20 Der Name des SB Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der erstellten Liste bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Distinct(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Teilliste von einmaligen Werten in einer angegebenen Liste (Intern: List#+1).{\line}Beim Textvergleich wird Gro?-/Kleinschreibung ignoriert.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Teil-/Unterliste bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Except(listName1,listName2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Unterliste nicht-gemeinsamer (unterschiedlicher) Werte zweier angegebener Listen (Intern: List#+1).{\line}Beim Textvergleich wird Gro?-/Kleinschreibung ignoriert.}\par
\f0\pard\sb75{\fs24\b listName1}\par
\f0\pard{\fs20 Der Name der ersten Liste.}\par
\f0\pard\sb75{\fs24\b listName2}\par
\f0\pard{\fs20 Der Name der zweiten Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Unterschiedsliste bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Find(listName,match,exact) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Teilliste gefundener Texttreffer in einer angegebenen Liste (Intern: List#+1).{\line}Beim Textvergleich wird Gro?-/Kleinschreibung ignoriert.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b match}\par
\f0\pard{\fs20 Der gesuchte Text.}\par
\f0\pard\sb75{\fs24\b exact}\par
\f0\pard{\fs20 Exakte ?bereinstimmung (Gro?-/Kleinschreibung ignoriert)?  "True" (Standard) oder "False" (Suchtext ist ?berhaupt in der Liste enthalten).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Teilliste mit Treffern bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b FindIndices(listName,match,exact) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Teilliste mit den Indizes gefundener Texttreffer in einer angegebenen Liste (Intern: List#+1).{\line}Beim Textvergleich wird Gro?-/Kleinschreibung ignoriert.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b match}\par
\f0\pard{\fs20 Der gesuchte Text.}\par
\f0\pard\sb75{\fs24\b exact}\par
\f0\pard{\fs20 Exakte ?bereinstimmung (Gro?-/Kleinschreibung ignoriert)?  "True" (Standard) oder "False" (Suchtext ist ?berhaupt in der Liste enthalten).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Teilliste mit Trefferindizes bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAt(listName,index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Wert am angegebenen Index (ab 1) in einer Liste.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der zu ermittelnde Wertindex.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Listenwert.}\par
\f0\pard\sb180\shading1000{\fs30\b IndexOf(listName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Index (ab 1) des ersten Auftretens eines Wertes in der angegebenen Liste.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der Wert dessen Index gesucht ist (0 falls kein Fund).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Index des Wertes oder 0.}\par
\f0\pard\sb180\shading1000{\fs30\b InsertAt(listName,index,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Wert am angegebenen Index (ab 1) in eine Liste ein.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Index an dem eingef?gt wird.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der einzuf?gende Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b Intersect(listName1,listName2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Unterliste von gemeinsamen ?bereinstimmenden Werten zweier angegebener Listen (Intern: List#+1).{\line}Beim Textvergleich wird Gro?-/Kleinschreibung ignoriert.}\par
\f0\pard\sb75{\fs24\b listName1}\par
\f0\pard{\fs20 Der Name der ersten Liste.}\par
\f0\pard\sb75{\fs24\b listName2}\par
\f0\pard{\fs20 Der Name der zweiten Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Schnittliste bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Print(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeilenweise Ausgabe einer Liste im TextWindow (listName| 1 : val1| 2 : val2| ...).{\line}Vorangestelltes 'TextWindow.WriteLine' gibt am Ende auch die Anzahl der Listenelemente aus.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Listenelemente bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b Read(filePath) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest eine Liste aus einer Datei ein (Intern: List#+1).}\par
\f0\pard\sb75{\fs24\b filePath}\par
\f0\pard{\fs20 Der volle Dateipfad zum Einlesen der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Liste bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Remove(listName,match,exact) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt alle Vorkommen eines gefundenen Texttreffers in einer angegebenen Liste.{\line}Beim Textvergleich wird Gro?-/Kleinschreibung ignoriert.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b match}\par
\f0\pard{\fs20 Der gesuchte Text.}\par
\f0\pard\sb75{\fs24\b exact}\par
\f0\pard{\fs20 Exakte ?bereinstimmung (Gro?-/Kleinschreibung ignoriert)?  "True" (Standard) oder "False" (Suchtext ist ?berhaupt in der Liste enthalten).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveAt(listName,index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt einen Wert am angegebenen Index (ab 1) von einer Liste.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der zu entfernende Wertindex.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b Reverse(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kehrt die Reihenfolge der Werte (Indizes) in einer angegebenen Liste um.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b SetAt(listName,index,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt (ersetzt) den Wert am angegebenen Index (ab 1) in einer Liste.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der zu setzende Index f?r den Wert.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b SortByNumber(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sortiert eine angegebene Liste wobei deren Elemente als Zahlen behandelt werden (numerische Sortierung).{\line}Alle Werte m?ssen Zahlen sein.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b SortByText(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sortiert eine angegebene Liste wobei deren Elemente als Textstrings behandelt werden (lexikalische Sortierung).{\line}Bei der Sortierung wird Gro?-/Kleinschreibung ignoriert.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b SubList(listName,start,length) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Teilliste einer angegebenen Liste (Intern: List#+1).}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b start}\par
\f0\pard{\fs20 Der erste Index in der Teilliste.}\par
\f0\pard\sb75{\fs24\b length}\par
\f0\pard{\fs20 Die L?nge der Teilliste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Teil-/Unterliste bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b ToArray(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert eine Liste zu einem SB Array.{\line}F?r gro?e Listen nicht empfehlenswert.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des SB Array bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Union(listName1,listName2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Unterliste kombinierter Werte (doppelte einzeln gez?hlt) zweier angegebener Listen (Intern: List#+1).{\line}Beim Textvergleich wird Gro?-/Kleinschreibung ignoriert.}\par
\f0\pard\sb75{\fs24\b listName1}\par
\f0\pard{\fs20 Der Name der ersten Liste.}\par
\f0\pard\sb75{\fs24\b listName2}\par
\f0\pard{\fs20 Der Name der zweiten Liste.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Vereinigungsliste bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Write(listName,filePath,append) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert eine Liste in eine Datei mit einem Listenwert pro Zeile.}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der Name der Liste.}\par
\f0\pard\sb75{\fs24\b filePath}\par
\f0\pard{\fs20 Der volle Dateipfad zum Speichern der Liste.}\par
\f0\pard\sb75{\fs24\b append}\par
\f0\pard{\fs20 Am Ende einer existierenden Datei anh?ngen?  "True" oder "False" (neue Datei erstellen).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl der Elemente in der Liste bei Erfolg, sonst -1.}\par
\f0\pard\sb300\shading2000{\fs36\b LDLogic}\par
\f0\pard{\fs20 Logikoperationen und lexikalischer Stringvergleich.{\line}Zur Berechnung eines Ausdrucks unter Verwendung dieser Operationen, benutze 'LDMath.Evaluate3'.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 eingabe = 3.1{\line}res = LDLogic.Switch(LDMath.Evaluate3(eingabe+"<5"),"OK","Neueingabe n?tig") ' "OK"}\par

\f0\pard\sb180\shading1000{\fs30\b And_(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Logische 'And' (Und, &) Verkn?pfung zweier Boolwerte (endender _ f?r Unterscheidung zum 'And' Schl?sselwort):{\line}And_("True","True")   = "True"{\line}And_("True","False")  = "False"{\line}And_("False","True")  = "False"{\line}And_("False","False") = "False"}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Die erste Bedingung ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Die zweite Bedingung ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Not A And Not B = A NOr B}\par
\f0\pard\sb180\shading1000{\fs30\b CaseSensitive \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Beachtung von Gro?-/Kleinschreibung bei Stringvergleich.  "True" (Standard) oder "False".{\line}F?r Methoden EQ, GE, GT, LE, LT, NE.}\par
\f0\pard\sb180\shading1000{\fs30\b EQ(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der 'EQual' (gleich, =) Operator.{\line}Pr?ft ob Wert1 gleich Wert2 ist (NXor).{\line}Auch zum lexikalischen Stringvergleich (s. CaseSensitive).}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Der erste Wert.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Der zweite Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDLogic.EQ("Text", "Texte") ' "False"{\line}'Zufallswert "True" oder "False"{\line}LDLogic.EQ(Math.GetRandomNumber(2), 2)}\par
\f0\pard\sb180\shading1000{\fs30\b GE(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der 'Greater than/Equal' (gr??er/gleich, >=) Operator.{\line}Pr?ft ob Wert1 gr??er oder gleich Wert2 ist.{\line}Auch zum lexikalischen Stringvergleich (s. CaseSensitive).}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Der erste Wert.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Der zweite Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b GT(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der 'Greater Than' (gr??er als, >) Operator.{\line}Pr?ft ob Wert1 gr??er als Wert2 ist.{\line}Auch zum lexikalischen Stringvergleich (s. CaseSensitive).}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Der erste Wert.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Der zweite Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b LE(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der 'Less than/Equal' (kleiner/gleich, <=) Operator.{\line}Pr?ft ob Wert1 kleiner oder gleich Wert2 ist.{\line}Auch zum lexikalischen Stringvergleich (s. CaseSensitive).}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Der erste Wert.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Der zweite Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b LT(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der 'Less Than' (kleiner als, <) Operator.{\line}Pr?ft ob Wert1 kleiner als Wert2 ist.{\line}Auch zum lexikalischen Stringvergleich (s. CaseSensitive).}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Der erste Wert.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Der zweite Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b NE(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der 'Not Equal' (ungleich, <>) Operator.{\line}Pr?ft ob Wert1 ungleich Wert2 ist (s. XOr).{\line}Auch zum lexikalischen Stringvergleich (s. CaseSensitive).}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Der erste Wert.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Der zweite Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDLogic.NE("text", "TexT") ' "True"}\par
\f0\pard\sb180\shading1000{\fs30\b Not(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Logische Umkehrung eines Boolwertes, 'Not' (Nicht, ~) Operator:{\line}Not("True")  = "False"{\line}Not("False") = "True"}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Die umzukehrende Bedingung ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Or_(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Logische 'Or' (Oder, |) Verkn?pfung zweier Boolwerte (endender _ f?r Unterscheidung zum 'Or' Schl?sselwort):{\line}Or_("True","True")   = "True"{\line}Or_("True","False")  = "True"{\line}Or_("False","True")  = "True"{\line}Or_("False","False") = "False"}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Die erste Bedingung ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Die zweite Bedingung ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Not A Or Not B = A NAnd B}\par
\f0\pard\sb180\shading1000{\fs30\b Switch(condition,value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?hrt eine Kurzanweisung mit logischer Bedingung aus. (s. Ternary-, ?: Operator, http://msdn.microsoft.com/library/ty67wk28.aspx)}\par
\f0\pard\sb75{\fs24\b condition}\par
\f0\pard{\fs20 Eine Bedingung oder Variable welche "True" oder "False" ergibt, bzw. LDMath.Evaluate3(condition) f?r Stringausdruck oder Vergleich.}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Der R?ckgabewert wenn die Bedingung "True" ergibt.}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Der R?ckgabewert wenn die Bedingung "False" ergibt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 value1 bei wahrem Ergebnis, sonst value2.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 eingabe = 3.1{\line}res = LDLogic.Switch(LDMath.Evaluate3(eingabe+"<5"),"OK","Ung?ltige Eingabe") ' "OK"{\line}{\line}LDLogic.Switch(Text.IsSubText("abc","b"), "Ja","Nein") ' "Ja"{\line}LDLogic.Switch(Array.IsArray("1=a"), 1,0) '1{\line}{\line}LDLogic.Switch(LDMath.Evaluate3(toBool), 1,0)) 'BoolToInt{\line}LDLogic.Switch(LDLogic.EQ(n,0), 0, n/Math.Abs(n)) 'Sgn(n)}\par
\f0\pard\sb180\shading1000{\fs30\b XOr(value1,value2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Logische 'XOr' (eXclusiv Oder, ^, wie s. NE) Verkn?pfung zweier Boolwerte:{\line}XOr("True","True")   = "False"{\line}XOr("True","False")  = "True"{\line}XOr("False","True")  = "True"{\line}XOr("False","False") = "False"}\par
\f0\pard\sb75{\fs24\b value1}\par
\f0\pard{\fs20 Die erste Bedingung ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b value2}\par
\f0\pard{\fs20 Die zweite Bedingung ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False"  (value1 != value2).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 A XOr B = (A Or B) And Not(A And B) bzw.{\line}  = (A Or B) And (Not A Or Not B) bzw.{\line}  = (A And Not B) Or (Not A And B){\line}{\line}'2x Anwendung -> Identit?t{\line}LDLogic.XOr(LDLogic.XOr(val1,val2),val2) 'val1}\par
\f0\pard\sb300\shading2000{\fs36\b LDMath}\par
\f0\pard{\fs20 Trigonometrische Funktionen im Gradma?, weitere verschiedene mathematische Funktionen und Berechnungen.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDUnits.sb}\par

\f0\pard\sb180\shading1000{\fs30\b ArcCos(cos) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den ArcusCosinus Winkel im Gradma? [180, 0].}\par
\f0\pard\sb75{\fs24\b cos}\par
\f0\pard{\fs20 Der Cosinuswert des Winkels (-1 bis 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Winkel [Grad].}\par
\f0\pard\sb180\shading1000{\fs30\b ArcSin(sin) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den ArcusSinus Winkel im Gradma? [-90, 90].}\par
\f0\pard\sb75{\fs24\b sin}\par
\f0\pard{\fs20 Der Sinuswert des Winkels (-1 bis 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Winkel [Grad].}\par
\f0\pard\sb180\shading1000{\fs30\b ArcTan(tan) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den ArcusTangens Winkel im Gradma? ]-90, 90[.}\par
\f0\pard\sb75{\fs24\b tan}\par
\f0\pard{\fs20 Der Tangenswert des Winkels.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Winkel [Grad].}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 ArcCot(x) = ArcTan(1/x)}\par
\f0\pard\sb180\shading1000{\fs30\b Base2Decimal(number,base) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert den Zahlenwert einer angegebenen Basis (zB. 2, 8, 16 usw.) zu einer dekadischen Ganzzahl (Basis 10).{\line}Max. Wert: Int32 (2^31-1 = 2147483647 = #7FFFFFFF).}\par
\f0\pard\sb75{\fs24\b number}\par
\f0\pard{\fs20 Der zu konvertierende Zahlenwert der anderen Basis (>= 0).}\par
\f0\pard\sb75{\fs24\b base}\par
\f0\pard{\fs20 Die Basis von der konvertiert wird (zB. 2 bin?r, 8 oktal, 16 hex oder andere bis 36, >= 2).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Zahlenwert als dekadische Ganzzahl bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDMath.Base2Decimal(11110,2)  '30{\line}LDMath.Base2Decimal(36,8)  '30{\line}LDMath.Base2Decimal("1E",16)  '30{\line}LDMath.Base2Decimal("u",36)  '30}\par
\f0\pard\sb180\shading1000{\fs30\b Convert2Cartesian(x1,y1,dist,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Koordinaten f?r Punkt 2. Ausgehend von Punkt 1, mit Abstand und Winkel zu Punkt 2 (Polar -> Kartesisch), gem??:{\line}x2 = x1 + r*cos(?){\line}y2 = y1 + r*sin(?)}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 Die x-Koordinate von Punkt 1 (Pol).}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 Die y-Koordinate von Punkt 1 (Pol).}\par
\f0\pard\sb75{\fs24\b dist}\par
\f0\pard{\fs20 Der Abstand r zwischen Punkt 1 und Punkt 2.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der +/- Winkel ? [Grad] zu Punkt 2 (im Uhrzeigersinn, 0? = 3h).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2-elementiger Array mit den x/y-Koordinaten f?r Punkt 2 "1=x2;2=y2;".}\par
\f0\pard\sb180\shading1000{\fs30\b Convert2Radial(x1,y1,x2,y2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Abstand und Winkel zwischen zwei Punkten (Kartesisch -> Polar) als Array.}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 Die x-Koordinate von Punkt 1.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 Die y-Koordinate von Punkt 1.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 Die x-Koordinate von Punkt 2.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 Die y-Koordinate von Punkt 2.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2-elementiger Array mit Abstand r und Winkel ? [Grad] (im Uhrzeigersinn, 0? = 3h) von Punkt 1 zu Punkt 2.{\line}Der Winkel wird im Bereich >0 bis 360 ausgegeben.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Atan2(x,y) [0?,360?[{\line}pol = LDMath.Convert2Radial(0,0, x,y){\line}w = Math.Remainder(pol[2], 360){\line}w = w - LDLogic.Switch(LDLogic.LT(y,0), 360,0) '[0?,+/-180?]}\par
\f0\pard\sb180\shading1000{\fs30\b Cos(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Cosinus f?r einen Winkel im Gradma?.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der +/- Winkel [Grad].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Cosinuswert des Winkels [-1,1] (x im Einheitskreis).}\par
\f0\pard\sb180\shading1000{\fs30\b Cosh(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den hyperbolischen Cosinus f?r einen Winkel im Bogenma?.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Winkel im Bogenma? [rad].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der hyperbolische Cosinuswert (>=1, (e^x + e^-x)/2).}\par
\f0\pard\sb180\shading1000{\fs30\b Decimal2Base(number,base) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert eine dekadische Ganzzahl (Basis 10) zum Zahlenwert einer anderen Basis (zB. 2, 8, 16 usw.).{\line}Max. Wert: Int32 (2^31-1 = 2147483647 = #7FFFFFFF).}\par
\f0\pard\sb75{\fs24\b number}\par
\f0\pard{\fs20 Die zu konvertierende dekadische Ganzzahl (>= 0).}\par
\f0\pard\sb75{\fs24\b base}\par
\f0\pard{\fs20 Die Basis zu der konvertiert wird (zB. 2 bin?r, 8 oktal, 16 hex oder andere bis 36, >= 2).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Zahlenwert zur gew?nschen Basis bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDMath.Decimal2Base(30,2)  '11110 bin{\line}LDMath.Decimal2Base(30,8)  '36 okt{\line}LDMath.Decimal2Base(30,16)  '1e hex{\line}LDMath.Decimal2Base(30,36)  'u}\par
\f0\pard\sb180\shading1000{\fs30\b E \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Basis e des nat?rlichen Logarithmus (~2.718282 = lim(1+1/n)^n f?r n->?, ln(e) = 1, Eulersche Zahl, 14 DezStellen).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 e = n^(1/ln(n)) 'n>1}\par
\f0\pard\sb180\shading1000{\fs30\b Evaluate(expression) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Evaluiert einen math. (boolschen) Stringausdruck zu einem Boolwert oder Zahlenergebnis (falls m?glich). F?r Ausgabe im TextWindow mu? dieses vor Aufruf bereits angezeigt sein (sonst ev. keine Ausgabe).{\line}Verwendet den JScript 'eval' Befehl, was komplexere JScript Manipulationen erm?glicht. s LDInline(.IncludeJScript). Keine Variablenverarbeitung.}\par
\f0\pard\sb75{\fs24\b expression}\par
\f0\pard{\fs20 Der zu berechnende Stringausdruck zB. "(9/6) + 3", "(9/6) == 3", "2.1 > 1.5", "1E6 + 6/4" oder "Date()".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das evaluierte Ergebnis bei Erfolg (zB. 4.5, false, true, 1000001.5), sonst Fehlermeldung (zB. Infinity).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 s. 'JScript Language Reference' jscript5.chm bzw. script56.chm (Windows Script 5.6 Documentation)}\par
\f0\pard\sb180\shading1000{\fs30\b Evaluate2(expression) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Evaluiert einen math. Stringausdruck zu einem Zahlenergebnis (falls m?glich).{\line}Alternative zu 'Evaluate' und kompatibel f?r direkte TextWindow Ausgabe. Keine Variablenverarbeitung.{\line}Vermeide gleichzeitige Verwendung von LDInline im selben Programm (Problem).}\par
\f0\pard\sb75{\fs24\b expression}\par
\f0\pard{\fs20 Der zu berechnende Stringausdruck zB. "1E6 + 6/4".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das evaluierte Zahlenergebnis bei Erfolg (zB. 1000001.5), sonst Fehlermeldung (zB. 'Expression of type 'Double' expected').}\par
\f0\pard\sb180\shading1000{\fs30\b Evaluate3(expression) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Evaluiert einen logischen Stringausdruck zu einem Boolwert "True" oder "False" (falls m?glich).{\line}Alternative zu 'Evaluate' und kompatibel f?r direkte TextWindow Ausgabe.{\line}Vermeide gleichzeitige Verwendung von LDInline im selben Programm (Problem).}\par
\f0\pard\sb75{\fs24\b expression}\par
\f0\pard{\fs20 Der zu ermittelnde Logikausdruck zB. "21.3 > 16" (gibt "True").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ermittelte Boolwert ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 s.a. LDLogic.Switch}\par
\f0\pard\sb180\shading1000{\fs30\b Exp(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das Exponential einer Zahl 'value' (e^value), s. LDMath.E.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der Exponent durch den die Basis e potenziert wird.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 e^value}\par
\f0\pard\sb180\shading1000{\fs30\b FixDecimal(number,digits) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rundet eine Zahl auf eine feste Anzahl von Dezimalstellen. Weitere erforderliche Dezimalnullen werden falls n?tig angef?gt.}\par
\f0\pard\sb75{\fs24\b number}\par
\f0\pard{\fs20 Die zu rundende Zahl.}\par
\f0\pard\sb75{\fs24\b digits}\par
\f0\pard{\fs20 Die Anzahl an Dezimalstellen.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die gerundete Zahl.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 FixDecimal(-12.3456, 3) '-12.346{\line}FixDecimal(-12.3456, 5) '-12.34560}\par
\f0\pard\sb180\shading1000{\fs30\b FixSigFig(number,digits) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rundet eine Zahl auf eine feste Anzahl von Gesamtziffern (1 bis 9).}\par
\f0\pard\sb75{\fs24\b number}\par
\f0\pard{\fs20 Die zu rundende Zahl.}\par
\f0\pard\sb75{\fs24\b digits}\par
\f0\pard{\fs20 Die Anzahl der Ziffern (<> 0).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die gerundete Zahl.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 FixSigFig(-1234567, 5) '-1234600{\line}FixSigFig(12.3456, 4) '12.35}\par
\f0\pard\sb180\shading1000{\fs30\b MaxNumber \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die gr??te Zahl, die SmallBasic verarbeiten kann (79228162514264337593543950335 ~ 7.9..E28, Decimal.MaxValue).}\par
\f0\pard\sb180\shading1000{\fs30\b MinNumber \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die kleinste Zahl, die SmallBasic verarbeiten kann (-79228162514264337593543950335 ~ -7.9..E28, Decimal.MinValue).}\par
\f0\pard\sb180\shading1000{\fs30\b RandomNumberSeed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Startpunkt f?r Zufallszahlen. Dies sollte eine Ganzzahl sein und vor Aufruf von 'Math.GetRandomNumber' gesetzt werden.{\line}Eine Zufallszahlensequenz wird durch diesen Startpunkt initialisiert und kann f?r Testzwecke verwendet werden, wenn eine wiederholbare Abfolge von Zufallszahlen erforderlich ist.}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(x1,y1,x2,y2,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Drehung von Punkt 2 im Uhrzeigersinn um Punkt 1.}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 Die x-Koordinate von Punkt 1.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 Die y-Koordinate von Punkt 1.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 Die x-Koordinate von Punkt 2.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 Die y-Koordinate von Punkt 2.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Drehwinkel [Grad] um den Punkt 2 im Uhrzeigersinn um Punkt 1 gedreht wird.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2-elementiger Array mit den neuen x/y-Koordinaten des gedrehten Punktes 2.}\par
\f0\pard\sb180\shading1000{\fs30\b Sin(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Sinus f?r einen Winkel im Gradma?.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der +/- Winkel [Grad].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Sinuswert des Winkels [-1,1] (y im Einheitskreis).}\par
\f0\pard\sb180\shading1000{\fs30\b Sinh(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den hyperbolischen Sinus f?r einen Winkel im Bogenma?.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Winkel im Bogenma? [rad].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der hyperbolische Sinuswert (e^x - e^-x)/2.}\par
\f0\pard\sb180\shading1000{\fs30\b Tan(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Tangens f?r einen Winkel im Gradma?.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der +/- Winkel [Grad].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Tangenswert des Winkels (Steigung y/x im Einheitskreis).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Cot(w) = 1/Tan(w)}\par
\f0\pard\sb180\shading1000{\fs30\b Tanh(angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den hyperbolischen Tangens f?r einen Winkel im Bogenma?.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Winkel im Bogenma? [rad].}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der hyperbolische Tangenswert, ]-1,1[,  sinh(x)/cosh(x).}\par
\f0\pard\sb180\shading1000{\fs30\b Truncate(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den ganzzahligen Teil einer Zahl (Stellen vor dem Dezimalzeichen). Abrundung auf Ganzzahl in Richtung Null.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Die Zahl (zB. -5.4 oder .123).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ganzzahlige Teil der Zahl (mit Vorzeichen, ohne Dezimalteil).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDMath.Truncate(32.23)  '32{\line}LDMath.Truncate(-32.23)  '-32{\line}LDMath.Truncate(-0.5)  '0}\par
\f0\pard\sb300\shading2000{\fs36\b LDMathX}\par
\f0\pard{\fs20 Erweiterte mathematische Methoden (Schnelle Fourier-Transformation, Komplexdaten).}\par

\f0\pard\sb180\shading1000{\fs30\b FFTComplex(real,imaginary) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen Array mit Komplexdaten aus zwei Arrays mit Real- und Imagin?rteilen.}\par
\f0\pard\sb75{\fs24\b real}\par
\f0\pard{\fs20 Ein Array mit Realteilen.}\par
\f0\pard\sb75{\fs24\b imaginary}\par
\f0\pard{\fs20 Ein Array mit Imagin?rteilen.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array komplexer Daten (reale Amplitude und imagin?re Phase), "MISMATCH" oder "FAILED".{\line}F?r jedes Komplexpaar (Re+Im*i) bestimmt der Index den Realteil und der Wert den Imagin?rteil (arrZ = "Re=Im;..;").}\par
\f0\pard\sb180\shading1000{\fs30\b FFTForward(real) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Komplexdaten f?r eine FFT (Fast Fourier Transformation) als Array.{\line}Signalumwandlung vom Zeit- in den Frequenzbereich.}\par
\f0\pard\sb75{\fs24\b real}\par
\f0\pard{\fs20 Ein Array mit Realwerten deren FFT zu berechnen ist.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array komplexer Daten (reale Amplitude und imagin?re Phase) bei Erfolg, sonst "FAILED".{\line}F?r jedes Komplexpaar (Re+Im*i) bestimmt der Index den Realteil und der Wert den Imagin?rteil (arrZ = "Re=Im;..;").}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Schnelle_Fourier-Transformation}\par
\f0\pard\sb180\shading1000{\fs30\b FFTImaginary(complex) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Imagin?rteil(e) f?r einen Array mit Komplexdaten.}\par
\f0\pard\sb75{\fs24\b complex}\par
\f0\pard{\fs20 Ein Array komplexer Daten (reale Amplitude und imagin?re Phase).{\line}F?r jedes Komplexpaar (Re+Im*i) bestimmt der Index den Realteil und der Wert den Imagin?rteil (arrZ = "Re=Im;..;").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit Imagin?rteil(en) der Komplexdaten bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b FFTInverse(complex) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Umkehrung einer FFT (Fast Fourier Transformation) als Array.{\line}Signalumwandlung vom Frequenz- in den Zeitbereich.}\par
\f0\pard\sb75{\fs24\b complex}\par
\f0\pard{\fs20 Ein Array komplexer Daten (reale Amplitude und imagin?re Phase).{\line}F?r jedes Komplexpaar (Re+Im*i) bestimmt der Index den Realteil und der Wert den Imagin?rteil (arrZ = "Re=Im;..;").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array inverser FFT Werte bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/IFFT}\par
\f0\pard\sb180\shading1000{\fs30\b FFTReal(complex) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Realteil(e) f?r einen Array mit Komplexdaten.}\par
\f0\pard\sb75{\fs24\b complex}\par
\f0\pard{\fs20 Ein Array komplexer Daten (reale Amplitude und imagin?re Phase).{\line}F?r jedes Komplexpaar (Re+Im*i) bestimmt der Index den Realteil und der Wert den Imagin?rteil (arrZ = "Re=Im;..;").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit Realteil(en) der Komplexdaten bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDMatrix}\par
\f0\pard{\fs20 2D Matrix-Struktur zB. zum L?sen linearer Gleichungssysteme (Intern: Matrix#).{\line}Die Zeilen und Spalten sind ab 1 indexiert. Bei einem Fehler wird "FAILED" zur?ckgegeben.{\line}Format f?r LDMatrix ist unterschiedlich und inkompatibel zum LDImage.ColorMatrix Format (2D Array).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDMatrix.sb{\line}http://de.wikipedia.org/wiki/Matrix_(Mathematik)}\par

\f0\pard\sb180\shading1000{\fs30\b Add(matrix1,matrix2,result) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Addiert zwei Matrizen. Die Anzahl der Zeilen und Spalten m?ssen f?r beide Matrizen gleich sein.{\line}Alternativ: Ist die zweite Matrix eine skalare Zahl (Skalar), wird dieser zu JEDEM Element der ersten Matrix hinzuaddiert.}\par
\f0\pard\sb75{\fs24\b matrix1}\par
\f0\pard{\fs20 Der Name der ersten Matrix.}\par
\f0\pard\sb75{\fs24\b matrix2}\par
\f0\pard{\fs20 Der Name der zweiten Matrix (oder skalare Zahl).}\par
\f0\pard\sb75{\fs24\b result}\par
\f0\pard{\fs20 Der Name der bestehenden Summenmatrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Copy(matrix1,matrix2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert eine Matrix in eine bestehende Matrix.{\line}Die Dimensionen beider Matrizen m?ssen identisch sein.}\par
\f0\pard\sb75{\fs24\b matrix1}\par
\f0\pard{\fs20 Der Name der zu kopierenden Quellmatrix.}\par
\f0\pard\sb75{\fs24\b matrix2}\par
\f0\pard{\fs20 Der Name der Zielmatrix in welche kopiert wird.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CopyNew(matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert eine bestehende Matrix in eine neue Matrix (Intern: Matrix#+1).}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Der Name der zu kopierenden Quellmatrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Matrixkopie bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CopyToSBArray(matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Kopiert eine bestehende LDMatrix in einen neuen 2D SB-Array.{\line}Die Umkehrung (SB-Array zu LDMatrix) ist nicht m?glich, da SB-Arrays nicht zwangsl?ufig mit fortlaufenden Ganzzahlen indexiert werden.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Der Name der Matrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des 2D SB-Array bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Create(rows,cols) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine neue m*n Matrix, gef?llt mit 0-Werten (Intern: Matrix#+1).{\line}Zeilen- und Spaltenanzahl der Matrix k?nnen mit rows (m) und cols (n) entsprechend dimensioniert werden.}\par
\f0\pard\sb75{\fs24\b rows}\par
\f0\pard{\fs20 Die Anzahl der Zeilen (m >= 1).}\par
\f0\pard\sb75{\fs24\b cols}\par
\f0\pard{\fs20 Die Anzahl der Spalten (n >= 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der neuen Matrix bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Delete(matrix) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht eine existierende Matrix (nicht generell erforderlich, kann aber bei Verwendung vieler Matrizen Speicherplatz freigeben).}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Der Name der zu l?schenden Matrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetValue(matrix,row,col) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Wert eines Elementes in einer bestehenden Matrix.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Der Name der Matrix.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeile (ab 1) f?r den zu ermittelnden Wert.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spalte (ab 1) f?r den zu ermittelnden Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ermittelte Wert bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Inverse(matrix,inverse) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die 'Inverse Matrix' (Gau? Elimination, M * M^-1 = E).{\line}Die Anzahl der Zeilen und Spalten beider Matrizen m?ssen identisch und jeweils quadratisch sein.{\line}Eine singul?re Matrix (det = 0) gibt den Wert "SINGULAR" zur?ck und die inverse Matrix wird fehlerhaft sein.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Der Name der Matrix deren Inverse zu berechnen ist (bleibt unver?ndert, det <> 0).}\par
\f0\pard\sb75{\fs24\b inverse}\par
\f0\pard{\fs20 Der Name der bestehenden inversen Matrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED" oder "SINGULAR".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDMatrix.Inverse(m, i) 'i = Einheitsmatrix E, f?r m=e}\par
\f0\pard\sb180\shading1000{\fs30\b Multiply(matrix1,matrix2,result) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Multipliziert zwei Matrizen. Die Anzahl der Zeilen und Spalten m?ssen f?r beide Matrizen gleich sein.{\line}Die Anzahl der Zeilen und Spalten der Produktmatrix m?ssen der Zeilenanzahl der ersten und der Spaltenanzahl der zweiten Matrix entsprechen.{\line}Alternativ: Ist die zweite Matrix eine skalare Zahl (Skalar), wird dieser mit JEDEM Element der ersten Matrix multipliziert. Dazu m?ssen die Dimensionen der ersten und der Produktmatrix gleich sein.}\par
\f0\pard\sb75{\fs24\b matrix1}\par
\f0\pard{\fs20 Der Name der ersten Matrix.}\par
\f0\pard\sb75{\fs24\b matrix2}\par
\f0\pard{\fs20 Der Name der zweiten Matrix (oder skalare Zahl).}\par
\f0\pard\sb75{\fs24\b result}\par
\f0\pard{\fs20 Der Name der bestehenden Produktmatrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b SetValue(matrix,row,col,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Wert f?r ein Element in einer bestehenden Matrix.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Der Name der Matrix.}\par
\f0\pard\sb75{\fs24\b row}\par
\f0\pard{\fs20 Die Zeile (ab 1) f?r den zu setzenden Wert.}\par
\f0\pard\sb75{\fs24\b col}\par
\f0\pard{\fs20 Die Spalte (ab 1) f?r den zu setzenden Wert.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Wert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Transpose(matrix,transpose) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die 'Transponierte Matrix' (an Hauptdiagonale gespiegelt).{\line}Die Anzahl der Zeilen und Spalten beider Matrizen m?ssen kreuzweise gleich sein, dh. die erste Matrix mu? soviele Spalten haben wie die zweite Matrix Zeilen, und umgekehrt.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Der Name der zu transponierenden Matrix.}\par
\f0\pard\sb75{\fs24\b transpose}\par
\f0\pard{\fs20 Der Name der bestehenden transponierten Matrix.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b View(matrix,modal) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt eine LDMatrix in einem eigenen Viewer-Fenster an (zB. Debugging, w?hlbare Ziffernanzeige).{\line}Fenstertitel zeigt 'Matrix# - Dimension Ze x Sp'.}\par
\f0\pard\sb75{\fs24\b matrix}\par
\f0\pard{\fs20 Der Name der anzuzeigenden Matrix.}\par
\f0\pard\sb75{\fs24\b modal}\par
\f0\pard{\fs20 Anzeige der Matrix h?lt Programmablauf an bis der Viewer geschlossen wird?  "True" oder "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDMusic}\par
\f0\pard{\fs20 Erweitert die SB Sound.PlayMusic Methode und bietet verschiedene weitere Instrumente.{\line}Zus?tzlich kann Musik ?ber mehrere Kan?le zugleich abgespielt werden.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDMusic.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Channel \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den MIDI Kanal (1 bis 16, Standard: 1) bei Verwendung in PlayMusic, Instrument und Velocity.}\par
\f0\pard\sb180\shading1000{\fs30\b EndNote(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt das Abspielen einer Note.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Die zu stoppende Note (von PlayNote zur?ckgegebener Wert).}\par
\f0\pard\sb180\shading1000{\fs30\b Instrument \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das aktuelle Musikinstrument (1 bis 128):{\line} 1	Acoustic_Grand_Piano	(Standard){\line} 2	Bright_Acoustic_Piano{\line} 3	Electric_Grand_Piano{\line} 4	Honky_Tonk_Piano{\line} 5	Electric_Piano_1{\line} 6	Electric_Piano_2{\line} 7	Harpsichord{\line} 8	Clavi{\line} 9	Celesta{\line}10	Glockenspiel{\line}11	Music_Box{\line}12	Vibraphone{\line}13	Marimba{\line}14	Xylophone{\line}15	Tubular_Bells{\line}16	Dulcimer{\line}17	Drawbar_Organ{\line}18	Percussive_Organ{\line}19	Rock_Organ{\line}20	Church_Organ{\line}21	Reed_Organ{\line}22	Accordion{\line}23	Harmonica{\line}24	Tango_Accordion{\line}25	Acoustic_Guitar_nylon{\line}26	Acoustic_Guitar_steel{\line}27	Electric_Guitar_jazz{\line}28	Electric_Guitar_clean{\line}29	Electric_Guitar_muted{\line}30	Overdriven_Guitar{\line}31	Distortion_Guitar{\line}32	Guitar_harmonics{\line}33	Acoustic_Bass{\line}34	Electric_Bass_finger{\line}35	Electric_Bass_pick{\line}36	Fretless_Bass{\line}37	Slap_Bass_1{\line}38	Slap_Bass_2{\line}39	Synth_Bass_1{\line}40	Synth_Bass_2{\line}41	Violin{\line}42	Viola{\line}43	Cello{\line}44	Contrabass{\line}45	Tremolo_Strings{\line}46	Pizzicato_Strings{\line}47	Orchestral_Harp{\line}48	Timpani{\line}49	String_Ensemble_1{\line}50	String_Ensemble_2{\line}51	SynthStrings_1{\line}52	SynthStrings_2{\line}53	Choir_Aahs{\line}54	Voice_Oohs{\line}55	Synth_Voice{\line}56	Orchestra_Hit{\line}57	Trumpet{\line}58	Trombone{\line}59	Tuba{\line}60	Muted_Trumpet{\line}61	French_Horn{\line}62	Brass_Section{\line}63	SynthBrass_1{\line}64	SynthBrass_2{\line}65	Soprano_Sax{\line}66	Alto_Sax{\line}67	Tenor_Sax{\line}68	Baritone_Sax{\line}69	Oboe{\line}70	English_Horn{\line}71	Bassoon{\line}72	Clarinet{\line}73	Piccolo{\line}74	Flute{\line}75	Recorder{\line}76	Pan_Flute{\line}77	Blown_Bottle{\line}78	Shakuhachi{\line}79	Whistle{\line}80	Ocarina{\line}81	Lead_1_square{\line}82	Lead_2_sawtooth{\line}83	Lead_3_calliope{\line}84	Lead_4_chiff{\line}85	Lead_5_charang{\line}86	Lead_6_voice{\line}87	Lead_7_fifths{\line}88	Lead_8_bass_lead{\line}89	Pad_1_new_age{\line}90	Pad_2_warm{\line}91	Pad_3_polysynth{\line}92	Pad_4_choir{\line}93	Pad_5_bowed{\line}94	Pad_6_metallic{\line}95	Pad_7_halo{\line}96	Pad_8_sweep{\line}97	FX_1_rain{\line}98	FX_2_soundtrack{\line}99	FX_3_crystal{\line}100	FX_4_atmosphere{\line}101	FX_5_brightness{\line}102	FX_6_goblins{\line}103	FX_7_echoes{\line}104	FX_8_sci_fi{\line}105	Sitar{\line}106	Banjo{\line}107	Shamisen{\line}108	Koto{\line}109	Kalimba{\line}110	Bag_Pipe{\line}111	Fiddle{\line}112	Shanai{\line}113	Tinkle_Bell{\line}114	Agogo{\line}115	Steel_Drums{\line}116	Woodblock{\line}117	Taiko_Drum{\line}118	Melodic_Tom{\line}119	Synth_Drum{\line}120	Reverse_Cymbal{\line}121	Guitar_Fret_Noise{\line}122	Breath_Noise{\line}123	Seashore{\line}124	Bird_Tweet{\line}125	Telephone_Ring{\line}126	Helicopter{\line}127	Applause{\line}128	Gunshot}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDMusic.sb}\par
\f0\pard\sb180\shading1000{\fs30\b InstrumentName(instrument) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name eines Instruments aus seiner Nummer (Standard: 1 = Acoustic_Grand_Piano).}\par
\f0\pard\sb75{\fs24\b instrument}\par
\f0\pard{\fs20 Die Nummer des Instruments (s. LDMusic.Instrument).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Instruments.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDMusic.InstrumentName(8) ' "Clavi"{\line}LDMusic.Clavi '8}\par
\f0\pard\sb180\shading1000{\fs30\b PlayMusic(notes) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abspielen von Musiknoten. Standardl?nge: L4 bzw. 400 ms.}\par
\f0\pard\sb75{\fs24\b notes}\par
\f0\pard{\fs20 Ein String abzuspielender Noten im Format der von QBasic unterst?tzten Music Markup Language (MML).{\line}Oktave: O0-O8, Noten: A-G, Halbton: +(#) auf / - ab, Notenl?nge (L)1,2,4 od. 8tel, Pause: R(P)1-8 wie Notenl?nge.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDMusic.Instrument = LDMusic.Xylophone{\line}LDMusic.PlayMusic("O5 C8 C8 G8 G8 A8 A8 G4 F8 F8 E8 E8 D8 D8 C2")}\par
\f0\pard\sb180\shading1000{\fs30\b PlayMusic2(notes,instrument,velocity,volume,pan,channel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abspielen von Musiknoten mit angegebenem Instrument und MDI Kanal, sowie Setzen von Lautst?rke, Balance und Anschlaggeschwindigkeit.}\par
\f0\pard\sb75{\fs24\b notes}\par
\f0\pard{\fs20 Ein String abzuspielender Noten im Format der von QBasic unterst?tzten Music Markup Language (MML).{\line}Oktave: O0-O8, Noten: A-G, Halbton: +(#) auf / - ab, Notenl?nge (L)1,2,4 od. 8tel, Pause: R(P)1-8 wie Notenl?nge.}\par
\f0\pard\sb75{\fs24\b instrument}\par
\f0\pard{\fs20 Die Nummer des Instruments (s. LDMusic.Instrument).}\par
\f0\pard\sb75{\fs24\b velocity}\par
\f0\pard{\fs20 Die Geschwindigkeit der Tastenanschl?ge (1 bis 128, Standard: 100).}\par
\f0\pard\sb75{\fs24\b volume}\par
\f0\pard{\fs20 Die Lautst?rke (0 bis 100, Standard: 50).}\par
\f0\pard\sb75{\fs24\b pan}\par
\f0\pard{\fs20 Die linke (-100) bis rechte (100) Stereo Balance (Standard: 0).}\par
\f0\pard\sb75{\fs24\b channel}\par
\f0\pard{\fs20 Der MIDI Kanal (1 bis 16, Standard: 1).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 notes = "O5 C8 C8 G8 G8 A8 A8 G4 F8 F8 E8 E8 D8 D8 C2"{\line}LDMusic.PlayMusic2(notes, 1, 100,"","",1)}\par
\f0\pard\sb180\shading1000{\fs30\b PlayNote(octave,note,channel) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Spielt eine einzelne Note (erlaubt Mehrkanal Instrumente, s. PlayMusic).}\par
\f0\pard\sb75{\fs24\b octave}\par
\f0\pard{\fs20 Die Oktave (0 bis 8, Standard: 4).}\par
\f0\pard\sb75{\fs24\b note}\par
\f0\pard{\fs20 Die Note ("A","F#","B-" usw.).}\par
\f0\pard\sb75{\fs24\b channel}\par
\f0\pard{\fs20 Der MIDI-Kanal (1 bis 16, Standard: 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert der abgespielten Note.}\par
\f0\pard\sb180\shading1000{\fs30\b Reset() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt s?mtliche Musik auf allen Kan?len.}\par
\f0\pard\sb180\shading1000{\fs30\b Velocity \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Geschwindigkeit der Tastenanschl?ge (1 bis 128, Standard: 100).{\line}Dies ist die Anschlagst?rke f?r eine Taste.}\par
\f0\pard\sb300\shading2000{\fs36\b LDNetwork}\par
\f0\pard{\fs20 Netzwerk- oder Web-Methoden (s. LDUtilities.NetworkURL und php Dateien unter http://litdev.co.uk).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 3D-samples\\LD3DMazeGame.sb}\par

\f0\pard\sb180\shading1000{\fs30\b DownloadFile(localFile,remoteFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Download einer Webdatei ?hnlich 'Network.DownloadFile', jedoch mit Angabe des Speicherpfades und bessere Verarbeitung gro?er Dateien.}\par
\f0\pard\sb75{\fs24\b localFile}\par
\f0\pard{\fs20 Der lokale Dateipfad zum Speichern der heruntergeladenen Datei (?nderungsdatum wird auf aktuelle Zeit gesetzt).}\par
\f0\pard\sb75{\fs24\b remoteFile}\par
\f0\pard{\fs20 Die Adresse der Netzwerkdatei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Dateigr??e [Byte] bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b GetGameData(game) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermitteln/Download von (zuvor gespeicherten) Daten f?r ein Spiel.}\par
\f0\pard\sb75{\fs24\b game}\par
\f0\pard{\fs20 Der Name des Spiels (F?r jedes Spiel bzw. Version ist ein eindeutiger Name erforderlich).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ermittelten gespeicherten Daten bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Test ob unter "myGame" bereits Daten vorliegen:{\line}dat = LDNetwork.GetGameData("myGame"){\line}TextWindow.WriteLine(dat)}\par
\f0\pard\sb180\shading1000{\fs30\b HighScore(game,user,score) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Upload eines potentiellen HighScores in das Netz.{\line}Zwischen Gro?-/Kleinschrift wird unterschieden und der Punktestand sollte eine Ganzzahl sein.}\par
\f0\pard\sb75{\fs24\b game}\par
\f0\pard{\fs20 Der Name des Spiels (F?r jedes Spiel bzw. Version ist ein eindeutiger Name erforderlich).}\par
\f0\pard\sb75{\fs24\b user}\par
\f0\pard{\fs20 Der Benutzername.}\par
\f0\pard\sb75{\fs24\b score}\par
\f0\pard{\fs20 Der Punktestand.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit dem aktuellen HighScore-Benutzername und dessen Punktestand.}\par
\f0\pard\sb180\shading1000{\fs30\b LAN(timeout) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste von Ger?ten und deren Adressen mit Verbindung zum lokalen Netzwerkbereich (LAN, Heimnetzwerk, 192.168.1.xx).}\par
\f0\pard\sb75{\fs24\b timeout}\par
\f0\pard{\fs20 Die Auszeit [ms] (zB. 1000).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit IP Adressen und Ger?tenamen mit Pingzeit, indexiert durch die IP Adresse.}\par
\f0\pard\sb180\shading1000{\fs30\b Ping(IP,timeout) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet einen Ping an eine IP Adresse und gibt die Umlaufzeit zur?ck.}\par
\f0\pard\sb75{\fs24\b IP}\par
\f0\pard{\fs20 Die anzupingende IP Adresse (oder Url).}\par
\f0\pard\sb75{\fs24\b timeout}\par
\f0\pard{\fs20 Die Auszeit [ms] (zB. 1000).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Umlaufzeit bei Erfolg [ms] bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b SetGameData(game,data) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzten/Upload von Daten f?r ein Spiel.}\par
\f0\pard\sb75{\fs24\b game}\par
\f0\pard{\fs20 Der Name des Spiels (F?r jedes Spiel bzw. Version ist ein eindeutiger Name erforderlich).}\par
\f0\pard\sb75{\fs24\b data}\par
\f0\pard{\fs20 Die zu speichernden Daten, kann auch ein Array sein.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die gespeicherten Daten bei Erfolg, sonst "".}\par
\f0\pard\sb300\shading2000{\fs36\b LDPhysics}\par
\f0\pard{\fs20 Physik Erweiterung (verwendet Box2D-Engine).{\line}Hilfe unter LDPhysics.Help.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 physics-samples\\*.sb{\line}http://blogs.msdn.microsoft.com/smallbasic/2014/06/07/small-basic-box2d-physics-extension/}\par

\f0\pard\sb180\shading1000{\fs30\b AddChain(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Kette zwischen zwei existierenden Shapes hinzu (Intern: Chain#).}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Kette.}\par
\f0\pard\sb180\shading1000{\fs30\b AddExplosion(posX,posY,power,damping,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt eine Explosion von 50 Partikeln a 20kg, die verteilt ?ber 500 ms auseinander streben.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 Die x-Koordinate der Explosion.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 Die y-Koordinate der Explosion.}\par
\f0\pard\sb75{\fs24\b power}\par
\f0\pard{\fs20 Die Explosionskraft (Anfangsgeschwindigkeit der Partikel).}\par
\f0\pard\sb75{\fs24\b damping}\par
\f0\pard{\fs20 Die D?mpfung f?r den Impuls. Je kleiner der Wert, umso gr??er der Streubereich (Standard: 10).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Optionale Farbe der Explosionsteilchen ("" f?r ohne).}\par
\f0\pard\sb180\shading1000{\fs30\b AddFixedAnchor(posX,posY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein kleines, unsichtbares Shape hinzu, welches als Ankerpunkt (zB. f?r eine Kette) benutzt werden kann (Intern: Ellipse#).}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 Die x-Koordinate des Ankerpunktes.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 Die y-Koordinate des Ankerpunktes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Ankerpunktes.}\par
\f0\pard\sb180\shading1000{\fs30\b AddFixedShape(shapeName,friction,restitution) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt der Physics Engine ein existierendes SB-Shape als feste Shape (undynamisch) mit Reaktionen auf andere Shapes hinzu (zB. Reibung, Kollision, R?ckstoss).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b friction}\par
\f0\pard{\fs20 Reibungswert (gew?hnlich 0.0 bis 1.0).}\par
\f0\pard\sb75{\fs24\b restitution}\par
\f0\pard{\fs20 R?ckfederung/Abprallwert (gew?hnlich 0.0 bis 1.0).}\par
\f0\pard\sb180\shading1000{\fs30\b AddInactiveShape(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt der Physics Engine ein existierendes SB-Shape als inaktive Shape (undynamisch und ohne Interaktion mit anderen) hinzu, welche sich nur mit der PanView-Methode bewegt.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddMovingAnchor(posX,posY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein kleines, unsichtbares und hoch verdichtetes Shape hinzu, welche als beweglicher Ankerpunkt benutzt werden kann (Intern: Ellipse#).}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 Die x-Koordinate des Ankerpunktes.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 Die y-Koordinate des Ankerpunktes.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Ankerpunktes.}\par
\f0\pard\sb180\shading1000{\fs30\b AddMovingShape(shapeName,friction,restitution,density) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt der Physics Engine ein existierendes SB-Shape als bewegliche Shape (dynamisch) hinzu.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b friction}\par
\f0\pard{\fs20 Reibungswert (gew?hnlich 0.0 bis 1.0).}\par
\f0\pard\sb75{\fs24\b restitution}\par
\f0\pard{\fs20 R?ckfederung/Abprallwert (gew?hnlich 0.0 bis 1.0).{\line}Ein negativer Wert f?gt die Shape mit sehr kleinen Abmessungen hinzu, die es erlauben, ein inaktives Bild anzuf?gen und es innerhalb einer unregelm??igen Verbundshape (die das Gesamtbild umfasst) zu gruppieren.}\par
\f0\pard\sb75{\fs24\b density}\par
\f0\pard{\fs20 Die Dichte der Shape (Standard: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b AddRope(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ein Seil zwischen zwei existierenden Shapes hinzu (Intern: Rope#).}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Seils.}\par
\f0\pard\sb180\shading1000{\fs30\b AttachShapes(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbindet zwei Shapes, soda? diese sich zusammen als Einheit bewegen.{\line}Die Shapes werden durch ein Abstandsgelenk (Joint) verbunden und k?nnen beim Angriff etwas wackeln.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AttachShapesWithJoint(shape1,shape2,type,collide,parameters) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbindet zwei Shapes zur gemeinsamen Bewegung in einem von mehreren Verkettungstypen (Intern: Joint#).{\line}Kann erweitert werden und erfordert Nachschlagen in der Box2D Anleitung.{\line}Oft ist es besser, Shaperotation f?r die Verkettung zu unterbinden, um sich wie beabsichtigt zu verhalten.{\line}Mehrfachverkettungen k?nnen ebenfalls auf Shapes angewandt werden.{\line}Diese Methoden verwenden die anf?nglichen Shapepositionen, diese also zuerst setzen.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb75{\fs24\b type}\par
\f0\pard{\fs20 Einer der folgenden Verkettungstypen:{\line}"Distance" - Beh?lt einen fixen Abstand zwischen den Shapes.{\line}"Gear" - Verkn?pft Prismatic oder Revolute Verkettungen (zuvor erstellt) zweier Shapes.{\line}"Line" - Bewegt die Shapes entlang einer anf?nglichen Verbindungslinie zwischen den Shapes.{\line}"Mouse" - Bewegt die Shape mit dem Mauszeiger (beide Shapenamen sollten gleich lauten).{\line}"Prismatic_H" - Bewegt die Shapes senkrecht entlang einer Linie zwischen den zwei Shapes.{\line}"Prismatic_V" - Bewegt die Shapes waagrecht entlang einer Linie zwischen den zwei Shapes.{\line}"Pulley" - Ein Zugsystem, eine Shape bewegt sich rauf so wie die andere runter - positioniere die Shapes anf?nglich an den Extrempunkten der Zugbewegung.{\line}"Revolute" - Die Shapes k?nnen umeinander rotieren.}\par
\f0\pard\sb75{\fs24\b collide}\par
\f0\pard{\fs20 Interaktion verbundener Shapes miteinander?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b parameters}\par
\f0\pard{\fs20 Optionale Parameter (Standard: ""), bzw. mehrere Parameter als Array.{\line}"Distance" - D?mpfungsverh?ltnis (Standard: 0){\line}"Gear" - ?bersetzungsverh?ltnis, erste Verkettung, zweite Verkettung (Standard: 1, Autoerkennen von Verkettungen){\line}"Line" - x-Richtung, y-Richtung, Untere ?bersetzung, Obere ?bersetzung (Standard: Linie verbindet Shapes, unbegrenzt){\line}"Mouse" - Max. Beschleunigung, D?mpfungsverh?ltnis (Standard: 10000, 0.7){\line}"Prismatic_H" - x-Richtung, y-Richtung, Untere ?bersetzung, Obere ?bersetzung (Standard: 1,0, unbegrenzt){\line}"Prismatic_V" - x-Richtung, y-Richtung, Untere ?bersetzung, Obere ?bersetzung (Standard: 0,1, unbegrenzt){\line}"Pulley" - Zugverh?ltnis (Flaschenzug, Standard: 1){\line}"Revolute" - Unterer Winkel, Oberer Winkel (Standard: unbegrenzt)}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Verkettung.}\par
\f0\pard\sb180\shading1000{\fs30\b AttachShapesWithRotation(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbindet zwei Shapes, soda? diese sich zusammen als Einheit bewegen, erlaubt aber den Shapes einander zu umkreisen oder zu rotieren.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b BoxShape(shapeName,x1,y1,x2,y2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Shape auf Verharren innerhalb einer Box/Rahmen in der Ansicht.{\line}Ist ?hnlich wie 'PanView', au?er da? die Ansicht automatisch nachschwenkt, um die angegebene Shape visuell innerhalb eines Bereichs im GraphicsWindow zu halten.{\line}Es kann nur eine Shape im Rahmen gehalten werden. Zum Zur?cksetzen der gehaltenen Shape, shapeName auf "" setzen.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der zu haltenden Shape oder "".}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 Die linke x-Koordinate der Box.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 Die obere y-Koordinate der Box.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 Die rechte x-Koordinate der Box.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 Die untere y-Koordinate der Box.}\par
\f0\pard\sb180\shading1000{\fs30\b BrakeTire(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Anwenden einer Bremse f?r eine Reifenshape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Die zu bremsende Reifenshape.}\par
\f0\pard\sb180\shading1000{\fs30\b ChainColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Farbe f?r Ketten.}\par
\f0\pard\sb180\shading1000{\fs30\b DetachJoint(jointName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Trennt zwei Shapes welche zuvor mittels Verkettung verbunden waren.}\par
\f0\pard\sb75{\fs24\b jointName}\par
\f0\pard{\fs20 Der Name der Verkettung (Intern: Joint#).}\par
\f0\pard\sb180\shading1000{\fs30\b DetachShapes(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Trennt zwei zuvor verbundene Shapes.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b DisconnectShape(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt eine Shape aus der Physics Engine ohne die Shape aus der Shapes-Liste zu l?schen.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b DoTimestep() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?bergibt kurz an die Physics Engine um Bewegungen und Positionen aller Shapes neu zu berechnen.}\par
\f0\pard\sb180\shading1000{\fs30\b FollowShapeX(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Shape auf station?res Verharren an der x-Position in der Ansicht.{\line}Ist ?hnlich wie 'PanView', au?er da? die Ansicht automatisch nachschwenkt, um die angegebene Shape visuell an einer konstanten x-Position zu halten.{\line}Es kann nur eine Shape in x-Richtung verfolgt werden. Zum Zur?cksetzen der verfolgenden Shape, shapeName auf "" setzen.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der zu verfolgenden Shape oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b FollowShapeY(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Shape auf station?res Verharren an der y-Position in der Ansicht.{\line}Ist ?hnlich wie 'PanView', au?er da? die Ansicht automatisch nachschwenkt, um die angegebene Shape visuell an einer konstanten y-Position zu halten.{\line}Es kann nur eine Shape in y-Richtung verfolgt werden. Zum Zur?cksetzen der verfolgenden Shape, shapeName auf "" setzen.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der zu verfolgenden Shape oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllShapesAt(posX,posY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle PhysicsEngine Shapes (falls vorhanden) an der angegebenen Position als Array.{\line}Wenn 'Pan/Nachschwenken' aktiviert ist, gelten die PhysicsEngine Koordinaten f?r diese Methode.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 Die x-Koordinate der Position.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 Die y-Koordinate der Position.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Namen aller Shapes an dieser Position oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAngle(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Rotationswinkel f?r eine Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Rotationswinkel [Grad].}\par
\f0\pard\sb180\shading1000{\fs30\b GetCollisions(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle Shapes die w?hrend des letzten DoTimestep mit der angegebenen Shape kollidiert sind.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Die auf Kollisionen zu pr?fende Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Namen aller Shapes die mit der angegebenen kollidiert sind (kann leer "" sein oder "Wall" f?r statisches Hindernis, Physics Engine Rahmen).}\par
\f0\pard\sb180\shading1000{\fs30\b GetContacts(posX,posY,distance) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste von Shapes, die innerhalb einer Entfernung von einem angegebenen Kontaktpunkt kollidieren.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 Die x-Koordinate des zu ?berpr?fenden Kontaktpunktes.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 Die y-Koordinate des zu ?berpr?fenden Kontaktpunktes.}\par
\f0\pard\sb75{\fs24\b distance}\par
\f0\pard{\fs20 Die Maximalentfernung der Kollision vom Kontaktpunkt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von Kontakten, wobei jeder Kontakt als Array zweier Shapenamen darstellt ist.}\par
\f0\pard\sb180\shading1000{\fs30\b GetInertia(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das Tr?gheitsmoment einer Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das Tr?gheitsmoment der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b GetMass(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Masse einer Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Masse der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b GetPan() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den aktuellen 'Pan' Versatz (s. PanView, FollowShapeX(Y) und BoxShape).{\line}Weltkoordinaten = Bildschirmkoordinaten + Pan Versatz.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 2-elementiger Array mit den aktuellen Pan Versatzwerten.}\par
\f0\pard\sb180\shading1000{\fs30\b GetPosition(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Mittelpunkt einer Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit 2 Elementen f?r die x- und y-Koordinaten des Mittelpunktes.}\par
\f0\pard\sb180\shading1000{\fs30\b GetRotation(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Rotationsgeschwindigkeit einer Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Rotationsgeschwindigkeit [Grad/sec].}\par
\f0\pard\sb180\shading1000{\fs30\b GetShapeAt(posX,posY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Shape (falls vorhanden) an der angegebenen Position.{\line}Die Koordinaten f?r diese Methode sind die Bildschirm Koordinaten wenn 'Pan/Nachschwenken' aktiviert ist.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 Die x-Koordinate.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 Die y-Koordinate.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Shape oder "" wenn sich dort keine befindet.}\par
\f0\pard\sb180\shading1000{\fs30\b GetTireInformation(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Reifeninformationen wie:{\line}"Skid"  (?bersteigt dieser Wert die Gr??e der "AntiSkid" Eigenschaft, rutscht der Reifen weg){\line}"Crash"  (der Wert ist die Aufprallgeschwindigkeit)}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Reifenshape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Informationen, indexiert durch den Name der Information zB. "Skid".}\par
\f0\pard\sb180\shading1000{\fs30\b GetTireProperties(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Reifeneigenschaften wie:{\line}"AntiSkid"  (h?herer Wert reduziert Schleudern/Abdriften){\line}"Drag"  (h?herer Wert erh?ht Vor-/R?ckw?rtszug){\line}"Brake"  (h?herer Wert erh?ht die Bremskraft){\line}"Straighten"  (h?herer Wert korrigiert Geradeauslenkung/Spurtreue schneller){\line}"BrakeStraighten"  (h?herer Wert korrigiert Geradeauslenkung beim Bremsen schneller)}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Reifenshape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Eigenschaften, indexiert durch den Name der Eigenschaft zB. "AntiSkid".}\par
\f0\pard\sb180\shading1000{\fs30\b GetVelocity(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die lineare Geschwindigkeit einer Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit 2 Elementen welche die Geschwindigkeit der Shape (in x- und y-Richtung) angeben.}\par
\f0\pard\sb180\shading1000{\fs30\b GroupShapes(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verbindet zwei Shapes fest miteinander, soda? diese sich gemeinsam bewegen. Shape1 wird derart zu shape2 hinzugef?gt, soda? sich beide wie eine einzige Shape verhalten.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b Help() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Diese Methode zeigt lediglich diese Hilfe an.{\line}{\line}LDPhysics verwendet Box2D (http://box2d.org) als Engine und stellt eine Verbindung zwischen Box2D und SB her.{\line}{\line}Nur Shapes die mit der LDPhysics Engine verbunden wurden, werden dabei ber?cksichtigt. So k?nnen gleichzeitig auch normale Shapes verwendet werden (zB. f?r Hintergrund). Wurde eine Shape an die Engine gekoppelt, ist es am Besten mit dieser nur noch ?ber 'LDShapes...' -Methoden zu interagieren. Alle Positionen sind in SB-GraphicsWindow Koordinaten [Pxl] angegeben und beziehen sich auf den Mittelpunkt der Shape.{\line}{\line}Bild- und Textshapes werden wie Rechtecke behandelt und Ellipsen wie Kreise; es werden auch Dreiecke und konvexe Polygone unterst?tzt, aber keine Linien. Bilder k?nnen ebenfalls als Kreise behandelt werden, indem LoadImagesAsCircles auf "True" setzt wird.{\line}{\line}Problematisch kann die Verwendung kleiner, sehr schnell bewegter Objekte werden. Diese k?nnen manchmal scheinbar durch andere, kleine Objekte hindurchfliegen ohne anzusto?en (s. auch SetBullet).{\line}{\line}Auch wenn Shapes sehr unterschiedliche Gr??en oder Masse haben, besonders wenn sehr gro?e Shapes miteinander verbunden wurden, kann es Probleme geben. Es kann dann n?tig sein, die Dichte (Density) dieser Objekte anzupassen (Verankern -Anchors- sind eine M?glichkeit dieses etwas zu automatisieren), ansonsten ist 1 (Standard) ein guter Wert f?r Dichte. Vermeide zu viele Shapes miteinander zu verbinden.{\line}{\line}Es w?re m?glich, die Stabilit?t einiger 'schwieriger' Modelle mittels 'Timestep'-Einstellungen zu erh?hen, die voreingestellten Werte sind meistens jedoch ausreichend.{\line}{\line}Die Methoden der LDPhysics Engine d?rfen nicht direkt aus einer SB Sub aufgerufen werden. Daher sollten dort nur Variablen verwendet werden, die in der Hauptschleife des Programmes die notwendigen Aufrufe an die LDPhysics Engine ausl?sen.{\line}{\line}Dieser Erweiterung liegen Beispielprogramme und ein 'GettingStartedGuide' bei. Diese bieten einen guten Einstieg um die neuen M?glichkeiten kennenzulernen.{\line}{\line}Fehlermeldungen und Probleme bitte im SB Forum (http://social.msdn.microsoft.com/Forums/en-US/smallbasic/threads). Zuvor den Programmcode m?glichst vereinfachen und k?rzen um das Problem zu isolieren.}\par
\f0\pard\sb180\shading1000{\fs30\b LoadImagesAsCircles \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das Laden einer Bildshape als Kreisform?  "True" oder "False" (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b MaxPolygonVertices \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die maximale Anzahl der Eckpunkte f?r konvexe Polygone in der Physics Engine (Standard: 8).}\par
\f0\pard\sb180\shading1000{\fs30\b MaxProxies \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die maximale Anzahl f?r Objekt-'Proxies' in der Physics Engine (Standard: 1024).}\par
\f0\pard\sb180\shading1000{\fs30\b MoveTire(shapeName,force) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bewegt eine Reifenshape durch Anwenden einer vor- oder r?ckw?rts gerichteten Kraft.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Die zu bewegende Reifenshape.}\par
\f0\pard\sb75{\fs24\b force}\par
\f0\pard{\fs20 Die anzuwendende Kraft (r?ckw?rts < 0 < vorw?rts).}\par
\f0\pard\sb180\shading1000{\fs30\b PanView(panHorizontal,panVertical) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schwenkt die Kameraansicht, incl. Fensterbegrenzungen.}\par
\f0\pard\sb75{\fs24\b panHorizontal}\par
\f0\pard{\fs20 Schwenkt die Kamera horizontal (neg. Werte f?r 'nach links').}\par
\f0\pard\sb75{\fs24\b panVertical}\par
\f0\pard{\fs20 Schwenkt die Kamera vertikal (neg. Werte f?r 'hoch').}\par
\f0\pard\sb180\shading1000{\fs30\b PositionIterations \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Positionsiterationen der Physics Engine (Standard: 2).}\par
\f0\pard\sb180\shading1000{\fs30\b RayCast(shapeName,angle,distance) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen unsichtbaren 'Leitstrahl' zum Erkennen der Ann?herung weiterer Shapes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape, als Ausgangspunkt f?r den Leitstrahl.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der zu ?berpr?fende Winkel oder ein Array von Winkeln [Grad].}\par
\f0\pard\sb75{\fs24\b distance}\par
\f0\pard{\fs20 Die maximale Entfernung zur ?berpr?fung.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array der Ergebnisse, indexiert durch Shapenamen ("Wall" f?r ein statisches Hindernis) und einem Wert entsprechend deren Entfernung (Reihenfolge der Shapes nach Distanz sortiert, n?heste zuerst).{\line}Bei Angabe eines Arrays mit Winkeln, nur die n?heste Shape/Winkel, wobei der Wert den Winkel anstatt der Entfernung angibt.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadJson(fileName,scale,reverseY,stationary,offsetX,offsetY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest ein json Script (R.U.B.E kompatibel) ein und erstellt daraus ein LDPhysics Modell.{\line}S. http://www.iforce2d.net/rube f?r weitere Details.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der einzulesenden json Datei.}\par
\f0\pard\sb75{\fs24\b scale}\par
\f0\pard{\fs20 Die Skalierung f?r alle Shapes (Standard: 1, keine Skalierung).}\par
\f0\pard\sb75{\fs24\b reverseY}\par
\f0\pard{\fs20 y-Richtung umkehren, von oben nach unten?  ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b stationary}\par
\f0\pard{\fs20 Setzt anfangs alle Shapes ruhend, (s. Set)JointMotor'en sind weiterhin aktiv ("True" oder "False").}\par
\f0\pard\sb75{\fs24\b offsetX}\par
\f0\pard{\fs20 Versatz entlang der x-Koordinate f?r alle Shapes.}\par
\f0\pard\sb75{\fs24\b offsetY}\par
\f0\pard{\fs20 Versatz entlang der y-Koordinate f?r alle Shapes, zB. hilfreich wenn 'reverseY' gesetzt wurde.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Stringarray mit den verwendeten LDPhysics Befehlen zum Erstellen des Modells.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveChain(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt eine Kette.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Kette.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveFrozen() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt alle angehaltenen Shapes (au?erhalb AABB befindlich = 'aus dem Rahmen gefallen').}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveRope(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt ein Seil.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Seils.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveShape(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt eine Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b Reset() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zur?cksetzen (l?scht alle Verbindungen zwischen Shapes und der Physics Engine).}\par
\f0\pard\sb180\shading1000{\fs30\b RopeColour \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die f?r Seile verwendete Farbe.}\par
\f0\pard\sb180\shading1000{\fs30\b Scaling \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Skalierung [Pixel/m] der Physics Engine (Standard: 10). Es ist nicht ratsam diese zu ?ndern.}\par
\f0\pard\sb180\shading1000{\fs30\b SetAABB(minX,maxX,minY,maxY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Die AABB (axis-aligned bounding box) - der Rahmen des Physics Universums. Ein Reset Aufruf mu? unbedingt erfolgen nachdem diese Grenzen ge?ndert wurden.}\par
\f0\pard\sb75{\fs24\b minX}\par
\f0\pard{\fs20 Linke Koordinate des Universums (Standard: -100).}\par
\f0\pard\sb75{\fs24\b maxX}\par
\f0\pard{\fs20 Rechte Koordinate des Universums (Standard: 200).}\par
\f0\pard\sb75{\fs24\b minY}\par
\f0\pard{\fs20 Obere Koordinate des Universums (Standard: -100).}\par
\f0\pard\sb75{\fs24\b maxY}\par
\f0\pard{\fs20 Untere Koordinate des Universums (Standard: 200).}\par
\f0\pard\sb180\shading1000{\fs30\b SetAngle(shapeName,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Rotationswinkel f?r eine Shape zur?ck.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Rotationswinkel [Grad].}\par
\f0\pard\sb180\shading1000{\fs30\b SetBoundaries(left,right,top,bottom) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt feste Begrenzungen f?r die Fl?che (Werte au?erhalb des GraphicsWindow entfernen die Begrenzung).}\par
\f0\pard\sb75{\fs24\b left}\par
\f0\pard{\fs20 Der x-Wert der linken Begrenzung.}\par
\f0\pard\sb75{\fs24\b right}\par
\f0\pard{\fs20 Der x-Wert der rechten Begrenzung.}\par
\f0\pard\sb75{\fs24\b top}\par
\f0\pard{\fs20 Der y-Wert der oberen Begrenzung.}\par
\f0\pard\sb75{\fs24\b bottom}\par
\f0\pard{\fs20 Der y-Wert der unteren Begrenzung.}\par
\f0\pard\sb180\shading1000{\fs30\b SetBullet(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Shape als 'Projektil' (Bullet). Dies verhindert das Hindurchfliegen bei kleinen, schnell bewegten Shapes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b SetDamping(shapeName,linear,angular) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den D?mpfungsfaktor f?r eine Shape (Standard: 0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b linear}\par
\f0\pard{\fs20 Linearer D?mpfungsfaktor.}\par
\f0\pard\sb75{\fs24\b angular}\par
\f0\pard{\fs20 Schr?ger/winkliger D?mpfungsfaktor.}\par
\f0\pard\sb180\shading1000{\fs30\b SetForce(shapeName,forceX,forceY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Kraft, die einer Shape zugeordnet wird (F = m*a).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b forceX}\par
\f0\pard{\fs20 Die x-Komponente der Kraft.}\par
\f0\pard\sb75{\fs24\b forceY}\par
\f0\pard{\fs20 Die y-Komponente der Kraft.}\par
\f0\pard\sb180\shading1000{\fs30\b SetGravity(gravX,gravY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die allgemeine Richtung und Gr??e der Gravitation (Standard: 0,100).}\par
\f0\pard\sb75{\fs24\b gravX}\par
\f0\pard{\fs20 Die x-Komponente der Gravitation.}\par
\f0\pard\sb75{\fs24\b gravY}\par
\f0\pard{\fs20 Die y-Komponente der Gravitation.}\par
\f0\pard\sb180\shading1000{\fs30\b SetGroup(shapeName,group,mask) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Auswahl von Shapes welche mit anderen Shapes interagieren (kollidieren).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der zu verwaltenden Shape.}\par
\f0\pard\sb75{\fs24\b group}\par
\f0\pard{\fs20 Die Gruppe, der die aktuelle Shape angeh?rt. Ganzzahl zwischen 0 und 15 (Standard: 0).}\par
\f0\pard\sb75{\fs24\b mask}\par
\f0\pard{\fs20 Ein Array von Gruppen welche mit dieser Shape kollidieren (Standard: alle Gruppen 0,1,2,..,14,15).{\line}Standardm??ig werden alle Shapes als Gruppe 0 erstellt und interagieren mit allen Gruppen 0 bis 15.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Interaktion einer Shape mit Gruppen 0,1 und 4:{\line}mask="1=0;2=1;3=4;".}\par
\f0\pard\sb180\shading1000{\fs30\b SetImpulse(shapeName,impulseX,impulseY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Impuls f?r eine Shape (zB. Anschieben eines Wagens, geradeaus).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der anzustossenden Shape.}\par
\f0\pard\sb75{\fs24\b impulseX}\par
\f0\pard{\fs20 Die x-Komponente des Impulses.}\par
\f0\pard\sb75{\fs24\b impulseY}\par
\f0\pard{\fs20 Die y-Komponente des Impulses.}\par
\f0\pard\sb180\shading1000{\fs30\b SetJointMotor(jointName,speed,maxForce) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen Motor f?r gew?hlte Verkettungen (Line, Prismatic_H, Prismatic_V und Revolute).}\par
\f0\pard\sb75{\fs24\b jointName}\par
\f0\pard{\fs20 Der Name der Verkettung.}\par
\f0\pard\sb75{\fs24\b speed}\par
\f0\pard{\fs20 Die gew?nschte Motorgeschwindigkeit.}\par
\f0\pard\sb75{\fs24\b maxForce}\par
\f0\pard{\fs20 Die maximale Motorkraft (Achsendrehmoment). 0 stellt den Motor ab.}\par
\f0\pard\sb180\shading1000{\fs30\b SetPosition(shapeName,posX,posY,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Position einer Shape zur?ck.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b posX}\par
\f0\pard{\fs20 Die x-Koordinate des Shape Mittelpunktes.}\par
\f0\pard\sb75{\fs24\b posY}\par
\f0\pard{\fs20 Die y-Koordinate des Shape Mittelpunktes.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Rotationswinkel [Grad].}\par
\f0\pard\sb180\shading1000{\fs30\b SetRotation(shapeName,rotation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Rotationsgeschwindigkeit f?r eine Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b rotation}\par
\f0\pard{\fs20 Die Rotationsgeschwindigkeit [Grad/sec].}\par
\f0\pard\sb180\shading1000{\fs30\b SetShapeGravity(shapeName,gravX,gravY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Richtung und Gr??e der Gravitation f?r eine angegebene Einzelshape (Standard: 0,100).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der zu modifizierenden Shape.}\par
\f0\pard\sb75{\fs24\b gravX}\par
\f0\pard{\fs20 Die x-Komponente der Gravitation.}\par
\f0\pard\sb75{\fs24\b gravY}\par
\f0\pard{\fs20 Die y-Komponente der Gravitation.}\par
\f0\pard\sb180\shading1000{\fs30\b SetTire(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt und behandelt ein Objekt als 'fahrbaren' Reifen f?r ein Top-Down Spiel.{\line}Gew?hnlich wird die Gravitation vernachl?ssigt (auf 0 gesetzt) und die Shape sollte bereits zur Engine hinzugef?gt sein.{\line}Das Objekt sollte zu Beginn in der Anzeige auf- und vorw?rts gerichtet positioniert sein.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Die als Reifen zu setzende Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b SetTireProperties(shapeName,properties) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Reifeneigenschaften wie:{\line}"AntiSkid"  (h?herer Wert reduziert Schleudern/Abdriften){\line}"Drag"  (h?herer Wert erh?ht Vor-/R?ckw?rtszug){\line}"Brake"  (h?herer Wert erh?ht die Bremskraft){\line}"Straighten"  (h?herer Wert korrigiert Geradeauslenkung/Spurtreue schneller){\line}"BrakeStraighten"  (h?herer Wert korrigiert Geradeauslenkung beim Bremsen schneller)}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Reifenshape.}\par
\f0\pard\sb75{\fs24\b properties}\par
\f0\pard{\fs20 Ein Array mit einer oder mehreren zu setzenden Eigenschaften.{\line}Der Index ist eine der Eigenschaften (exakte Schreibweise) und der Wert ist der Wert der Eigenschaft.}\par
\f0\pard\sb180\shading1000{\fs30\b SetTorque(shapeName,torque) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein Drehmoment f?r eine Shape (zB. Antrieb eines Rades, Rotation).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b torque}\par
\f0\pard{\fs20 Der Wert des anzubringenden Drehmomentes.}\par
\f0\pard\sb180\shading1000{\fs30\b SetVelocity(shapeName,velX,velY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die lineare Bewegungsgeschwindigkeit f?r eine Shape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b velX}\par
\f0\pard{\fs20 Die x-Komponente der Geschwindigkeit.}\par
\f0\pard\sb75{\fs24\b velY}\par
\f0\pard{\fs20 Die y-Komponente der Geschwindigkeit.}\par
\f0\pard\sb180\shading1000{\fs30\b TimeStep \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das Intervall f?r die zeitliche Schrittweite in der Physics Engine (Standard: 0.025).}\par
\f0\pard\sb180\shading1000{\fs30\b TimestepControl(timestep,velocityIterations,positionIterations) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Anpassen der voreingestellten Timestep-Steuerparameter.}\par
\f0\pard\sb75{\fs24\b timestep}\par
\f0\pard{\fs20 Die zeitliche Schrittweite (Standard: 0.025).}\par
\f0\pard\sb75{\fs24\b velocityIterations}\par
\f0\pard{\fs20 Geschwindigkeitsiteration (Standard: 6).}\par
\f0\pard\sb75{\fs24\b positionIterations}\par
\f0\pard{\fs20 Positionsiteration (Standard: 2).}\par
\f0\pard\sb180\shading1000{\fs30\b ToggleMoving(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Umschalten einer bewegten Shape zum Stillstand und umgekehrt.{\line}Diese Methode setzt eine Rotation ebenfalls an/aus in ?bereinstimmung ob bewegt oder statisch.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b ToggleRotation(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Umschalten einer rotierenden Shape zum Stillstand und umgekehrt.{\line}Diese Methode ?ndert die Rotationseigenschaft f?r fixe und bewegte Shapes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b ToggleSensor(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Umschalten einer Shape zum Verhalten als Sensor und umgekehrt.{\line}Eine Sensor Shape interagiert nicht mit anderen Shapes, liefert jedoch weiter Kollisionsdaten.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b TurnTire(shapeName,torque) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Drehen einer Reifenshape, Links- bzw. Rechtslenkung.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Die zu drehende Reifenshape.}\par
\f0\pard\sb75{\fs24\b torque}\par
\f0\pard{\fs20 Das Drehmoment/anzuwendende Drehkraft (Drehung nach links < 0 < rechts).}\par
\f0\pard\sb180\shading1000{\fs30\b UngroupShapes(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufheben einer Gruppierung zweier Shapes.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b UnsetBullet(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Aufheben des 'Bullet-Status' einer Shape. Diese wird dann wieder als normale Shape behandelt.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b VelocityIterations \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Geschwindigkeitsiteration der Physics Engine (Standard: 6).}\par
\f0\pard\sb180\shading1000{\fs30\b VelocityThreshold \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Schwellenwert der Physics Engine f?r unelastische Kollisionen 'klebende W?nde' (Standard: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b WakeAll() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erweckt alle ruhenden Shapes. Shapes ruhen aufgrund nicht einwirkender Kr?fte oder Kontakte und erwachen automatisch bei einem Kontakt oder einwirkender Kraft, soda? diese Aktion nur selten n?tig ist.}\par
\f0\pard\sb180\shading1000{\fs30\b WriteJson(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein json Script vom aktuellen LDPhysics Modell (R.U.B.E kompatibel).{\line}S. http://www.iforce2d.net/rube f?r weitere Details.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu erstellenden json Datei.}\par
\f0\pard\sb300\shading2000{\fs36\b LDProcess}\par
\f0\pard{\fs20 Steuern externer Anwendungen und Prozesse.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 debug\\Instrument.sb}\par

\f0\pard\sb180\shading1000{\fs30\b GetProcesses() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle aktuell laufenden Prozesse am System als Array ("procID=procName;..;").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Namen aller Systemprozesse (ohne .exe Erweiterung), indexiert durch die ID des Prozesses und alphabetisch geordnet nach Prozessname.}\par
\f0\pard\sb180\shading1000{\fs30\b Start(application,arguments) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet eine externe Anwendung, Datei oder Url.}\par
\f0\pard\sb75{\fs24\b application}\par
\f0\pard{\fs20 Der volle Pfad der (shell) zu startenden Anwendung, Datei, Ordner, Verkn?pfung.lnk/.url oder Url-Adresse. zB. "C:\\Program Files\\Microsoft\\Small Basic\\SB.exe" (kein %VAR% Pfad).}\par
\f0\pard\sb75{\fs24\b arguments}\par
\f0\pard{\fs20 Argumente (in "") zur ?bergabe an die Anwendung oder "" falls ohne.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ID des gestarteten Prozesses:{\line}-1  bei Mi?erfolg{\line}-2  wenn an einen bestehenden Prozess angef?gt}\par
\f0\pard\sb180\shading1000{\fs30\b Stop(id) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt einen externen Prozess.}\par
\f0\pard\sb75{\fs24\b id}\par
\f0\pard{\fs20 Die ID des zu stoppenden Prozesses.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" bei Erfolg, sonst "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDQueue}\par
\f0\pard{\fs20 Dieses Objekt bietet eine M?glichkeit zum Zwischenspeichern von Werten (Zahl, String, Var).{\line}?hnlich einem Stack ('zuletzt rein-zuerst raus'), gilt hier 'zuerst rein-zuerst raus', wie in einer Warteschlange (Gleichbleibende Reihenfolge).{\line}Am Ende der Schlange kann ein Wert angef?gt ('Enqueue') werden und am Beginn kann der erste Wert wieder entfernt ('Dequeue') werden.{\line}Enqueue und Dequeue der Werte nur hintereinander, einer nach dem anderen. Queuename vordefiniert zB. QName = "" oder in "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 client-server\\LDClient.sb, LDServer.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Dequeue(queueName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt (und entfernt) den Wert am Beginn des angegebenen Queue.}\par
\f0\pard\sb75{\fs24\b queueName}\par
\f0\pard{\fs20 Der Name des Queue.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert des vorne vom Queue entnommenen Elementes.}\par
\f0\pard\sb180\shading1000{\fs30\b Enqueue(queueName,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Wert am Ende des angegebenen Queue hinzu.}\par
\f0\pard\sb75{\fs24\b queueName}\par
\f0\pard{\fs20 Der Name des Queue.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der hinten anzuf?gende Wert.}\par
\f0\pard\sb180\shading1000{\fs30\b GetCount(queueName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der Elemente im angegebenen Queue.}\par
\f0\pard\sb75{\fs24\b queueName}\par
\f0\pard{\fs20 Der Name des Queue.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl Elemente im angegebenen Queue oder 0.}\par
\f0\pard\sb300\shading2000{\fs36\b LDRegex}\par
\f0\pard{\fs20 RegEx (Regular expression, regul?re Ausdr?cke) zur Textmanipulation.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/hs600312.aspx (Regular expressions quick reference.pdf){\line}http://www.regular-expressions.info/refquick.html (../quickstart.html, /tutorial.html){\line}http://regexlib.com/CheatSheet.aspx}\par

\f0\pard\sb180\shading1000{\fs30\b Match(input,pattern,caseSensitive) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Durchf?hren einer RegEx-Suche.{\line}http://msdn.microsoft.com/library/system.text.regularexpressions.regex.aspx{\line}http://msdn.microsoft.com/library/vstudio/b49yw9s8.aspx}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 Der Eingabestring der nach ?bereinstimmungen durchsucht wird (bleibt unver?ndert).}\par
\f0\pard\sb75{\fs24\b pattern}\par
\f0\pard{\fs20 Das RegEx Suchmuster als String:{\line}(. alle, ? 0-1, * 0+, + 1+, \\ Escape, [a-c] a bis c, \\d Ziffer, \\w Buchst, \\s Whitespace, \\t Tab, ^ Beginn, $ Ende, (Gruppe) usw.)}\par
\f0\pard\sb75{\fs24\b caseSensitive}\par
\f0\pard{\fs20 Bei RegEx-?bereinstimmung Gro?-/Kleinschr. unterscheiden?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array von Suchtreffern, indexiert durch deren Anfangsposition (ab 1) im String ("startPos1=fund1;..;") oder "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 A. Zeilenanzahl im String:{\line} lf = Text.GetCharacter(10) ' "\\n"{\line} arr = LDRegex.Match(str, lf,""){\line} nLine = Array.GetItemCount(arr){\line}B. arr = Match(str, "^[^\\.]*$",""){\line} 'arr = "" (str mit "."){\line} 'arr[1] = str (ohne "."){\line}C. IsMatch?:{\line} If LDRegex.Match(str, muster,"") <> "" Then{\line}   isMatch = "True"{\line} EndIf}\par
\f0\pard\sb180\shading1000{\fs30\b Replace(input,pattern,replacement,caseSensitive) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Durchf?hren einer RegEx-Suche mit Ersetzen.{\line}http://msdn.microsoft.com/library/system.text.regularexpressions.regex.aspx{\line}http://msdn.microsoft.com/library/az24scfc.aspx}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 Der Eingabestring in dem bei ?bereinstimmung ersetzt wird (bleibt unver?ndert).}\par
\f0\pard\sb75{\fs24\b pattern}\par
\f0\pard{\fs20 Ein String mit dem RegEx Suchmuster:{\line}(. alle, ? 0-1, * 0+, + 1+, \\ Escape, [a-c] a bis c, \\d Ziffer, \\w Buchst, \\s Whitespace, \\t Tab, ^ Beginn, $ Ende, (Gruppe) usw.)}\par
\f0\pard\sb75{\fs24\b replacement}\par
\f0\pard{\fs20 Ein String mit dem RegEx Ersatzmuster.}\par
\f0\pard\sb75{\fs24\b caseSensitive}\par
\f0\pard{\fs20 Bei RegEx-Ersetzten Gro?-/Kleinschr. unterscheiden?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ge?nderte Version des Eingabestrings nach RegEx-Ersatz.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 A. " aus String entfernen:{\line} qu = Text.GetCharacter(34){\line} ohneQu = LDRegex.Replace(str, qu,"",""){\line}B. Doppelleerzeilen entfernen:{\line} LDRegex.Replace(str, DoCrLf,crlf,""){\line}C. Strip html/xml Tags:{\line} LDRegex.Replace(html,"</?.+?>","","") 'od.{\line} LDRegex.Replace(html,"<.*?>"," ","") 'und{\line} LDRegex.Replace(html,"&nbsp;","",""){\line}D. Nur num. Arraywerte:{\line} LDRegex.Replace(arr,"(;|)\\d\\=|;"," ",""){\line}E. Mehrere Leerzeilen durch einzelne ersetzen:{\line} str = File.ReadContents(fIn){\line} out = LDRegex.Replace(str, "(\\r\\n){2,}",crlf+crlf,""){\line} File.WriteContents(fNeu ,out){\line}F. Endende spc/tab entfernen:{\line} LDRegex.Replace(line,"[ \\t]+$","",""){\line}G. Nicht-Ascii Zeichen (<32, >126) entfernen:{\line} LDRegex.Replace(str,"[^ -~]*","","")}\par
\f0\pard\sb300\shading2000{\fs36\b LDResources}\par
\f0\pard{\fs20 Speichern und Laden von Programmressourcen in/aus einer gleichnamigen Bin?rdatei.{\line}Diese Ressourcen werden in einer einzelnen Datei gespeichert, als aktueller Programmname mit Erweiterung .sbres und befindet sich im selben Verzeichnis wie das Programm.{\line}Ressourcen beinhalten alle ImageList Bilder, mit 'Sound.Play' abzuspielende Sounds, sowie optional weitere Dateien, Strings oder Variablen.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDResources.sb}\par

\f0\pard\sb180\shading1000{\fs30\b AddFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine beliebige Datei zum Speichern in die Ressource hinzu.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der hinzuzuf?genden Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b AddText(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt Text (auch als Variable bzw. Array) zum Speichern in der Ressource hinzu.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der Text oder eine SB Variable zum Hinzuf?gen in die Ressource.}\par
\f0\pard\sb180\shading1000{\fs30\b CleanTemp() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht verwendete, tempor?re Sound Dateien (LDResources.Sounds) aus dem %TEMP% Ordner.}\par
\f0\pard\sb180\shading1000{\fs30\b ExtractFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entpackt eine gespeicherte Ressourcedatei in den aktuellen Programmordner (Program.Directory).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der Dateiname wie von 'LDResources.Files' zur?ckgegeben.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Files \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste aller geladenen Dateinamen (mittels 'ExtractFile' extrahierbar) als Array.}\par
\f0\pard\sb180\shading1000{\fs30\b Images \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste aller geladenen 'ImageList#' Bilder (vorgeladen zur Weiterverwendung in ImageList) als Array.}\par
\f0\pard\sb180\shading1000{\fs30\b Load() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?dt alle zuvor gespeicherten Ressourcen aus einer gleichnamigen .sbres Datei.{\line}ImageList# Bilder und Sounds werden automatisch geladen und sind bereit zur Verwendung.{\line}Sound Dateien werden im %TEMP% Ordner erstellt, sobald sie von 'Sound.Play' ben?tigt werden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Save() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert alle verwendeten Ressourcen in eine gleichnamige .sbres Datei.{\line}Dies betrifft alle ben?tigten ImageList Bilder, abzuspielende Sounds (Sound.Play), sowie hinzugef?gte Dateien oder Text/Variablen.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Sounds \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste aller geladenen Sound Dateien (vorgeladen zur Weiterverwendung mit 'Sound.Play') als Array. Diese werden im %TEMP% Ordner erstellt, sofern 'LDResources.CleanTemp' nicht aufgerufen wird.}\par
\f0\pard\sb180\shading1000{\fs30\b Texts \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste aller geladenen Texte/Variablen als Array.}\par
\f0\pard\sb300\shading2000{\fs36\b LDScrollBars}\par
\f0\pard{\fs20 Scrollleisten f?r das GraphicsWindow. Kann zum Bildlauf im Spiel verwendet werden.{\line}{\line}Warnung: Die Gr??e des GraphicsWindow nicht per GraphicsWindow.Width oder -Height ?ndern, NACHDEM ScrollBars hinzugef?gt wurden.{\line}In diesem Fall LDGraphicsWindow.Width und -Height verwenden.{\line}F?r ausgedehnte Scrollbereiche s. Rasterize (Eigenschaft).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDScrollBars.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Add(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt ScrollBar(s) im GraphicsWindow hinzu (GraphicsWindow mu? initialisiert sein, bzw. wird aktiviert).{\line}Eingabebreite und -h?he sind jene, auf die gescrollt werden kann.{\line}0 verhindert das Einblenden einer ScrollBar.{\line}GraphicsWindow.Width/Height ?bernehmen die angegebenen Werte, daher k?nfig LDGraphicsWindow.Width/Height verwenden.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des scrollbaren Bereichs (sinnvoll ab GW.Width).}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des scrollbaren Bereichs (sinnvoll ab GW.Height).}\par
\f0\pard\sb180\shading1000{\fs30\b HorizontalScroll \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die horizontale Position der ScrollBar. Bei Positions?nderung wird 'ScrollBarChanged' Event ausgel?st.}\par
\f0\pard\sb180\shading1000{\fs30\b KeyScroll \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Verschiebbarkeit der ScrollBar mittels Pfeiltasten. "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Modify(action) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine ScrollBar auf eine definierte Position. Bei Positions?nderung wird 'ScrollBarChanged' Event ausgel?st.}\par
\f0\pard\sb75{\fs24\b action}\par
\f0\pard{\fs20 M?gliche Aktionen:{\line}"PageDown", "PageUp"{\line}"PageLeft", "PageRight"{\line}"ScrollToTop", "ScrollToBottom"{\line}"ScrollToLeftEnd", "ScrollToRightEnd"{\line}"ScrollToHome", "ScrollToEnd"}\par
\f0\pard\sb180\shading1000{\fs30\b MouseScroll \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Verschiebbarkeit der ScrollBar mittels Mausrad. "True" (Standard) oder "False".{\line}Horizontaler Bildlauf per Mausrad bei gedr?ckter Umschalt-Taste (Shift).}\par
\f0\pard\sb180\shading1000{\fs30\b PanningRatio \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das Bildlaufverh?ltnis bei Verschiebung der ScrollBar (Standard: 1).}\par
\f0\pard\sb180\shading1000{\fs30\b Rasterize \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Rasterung f?r gezeichnete (GW.Draw/GW.Fill) Objekte. "True" (Standard) oder "False".{\line}{\line}F?r ?ber 100 gezeichnete Objekte (keine Shapes) rastert SB diese aus Gr?nden der Systemleistung zu einem Bitmap Bild.{\line}F?r sehr gro?e scrollbare Bereiche kommt es zu Platzmangel im Arbeitsspeicher und kann daher hier deaktiviert werden.{\line}Wenn deaktiviert, nicht mehr als 100 gezeichnete Objekte verwenden.{\line}Ist zu setzen bevor LDScrollBars.Add aufgerufen wird.}\par
\f0\pard\sb180\shading1000{\fs30\b ScrollBarChanged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf bei Erkennen einer Bildlauf Operation.}\par
\f0\pard\sb180\shading1000{\fs30\b VerticalScroll \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die vertikale Position der ScrollBar. Bei Positions?nderung wird 'ScrollBarChanged' Event ausgel?st.}\par
\f0\pard\sb180\shading1000{\fs30\b Visibility \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Sichtbarkeit der ScrollBar. "True" (Standard) oder "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDSearch}\par
\f0\pard{\fs20 Methoden zur Onlinesuche mit 'Bing'.{\line}Enth?lt Web-, Bild-, Video-, News- und Rechtschreibungs- Suchvorschl?ge.}\par

\f0\pard\sb180\shading1000{\fs30\b Count \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die maximale Anzahl der erhaltenen Suchergebnisse (Standard: 50).}\par
\f0\pard\sb180\shading1000{\fs30\b GetImage(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ausf?hren einer Bing Websuche nach Bildern.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 Der Suchtext.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array der Suchergebnisse als "url=Beschreibung;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetNews(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ausf?hren einer Bing Websuche nach News.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 Der Suchtext.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array der Suchergebnisse als "url=Beschreibung;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetProof(text,mode) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ausf?hren einer Text Rechtschreibpr?fung (Nachweis) f?r l?ngeren Text mit detailierten Infos wie in Word.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der zu ?berpr?fende Text.}\par
\f0\pard\sb75{\fs24\b mode}\par
\f0\pard{\fs20 Der Modus:{\line}"Proof"	l?ngerer Text (Standard){\line}"Spell"	Kurz- oder Einzelwort Pr?fung}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit Schreibweise und weiteren Vorschl?gen bei Erfolg, sonst "" (keine Treffer).}\par
\f0\pard\sb180\shading1000{\fs30\b GetSpelling(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ausf?hren einer Bing Websuche nach Rechtschreibung oder alternative Suchvorschl?ge.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 Der Suchtext.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array (ab 1) mit Rechtschreibung bzw. alternativen Vorschl?gen bei Erfolg, sonst "" (keine Treffer).}\par
\f0\pard\sb180\shading1000{\fs30\b GetVideo(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ausf?hren einer Bing Websuche nach Videos.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 Der Suchtext.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array der Suchergebnisse als "url=Beschreibung;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b GetWeb(search) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ausf?hren einer Bing Suche nach Webseiten.}\par
\f0\pard\sb75{\fs24\b search}\par
\f0\pard{\fs20 Der Suchtext.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array der Suchergebnisse als "url=Beschreibung;..;".}\par
\f0\pard\sb180\shading1000{\fs30\b Language \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die verwendete Sprache (Standard: aktuelle Kultur, de-DE).{\line}Optionen:{\line}es-AR,en-AU,de-AT,nl-BE,fr-BE,pt-BR,en-CA,fr-CA,es-CL,da-DK,fi-FI,fr-FR,de-DE,zh-HK,en-IN,en-ID,en-IE,it-IT,ja-JP,ko-KR,en-MY,es-MX,nl-NL,en-NZ,no-NO,zh-CN,pl-PL,pt-PT,en-PH,ru-RU,ar-SA,en-ZA,es-ES,sv-SE,fr-CH,de-CH,zh-TW,tr-TR,en-GB,en-US,es-US}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/ee825488.aspx (Kulturnamen, Codes, ISO Werte)}\par
\f0\pard\sb300\shading2000{\fs36\b LDServer}\par
\f0\pard{\fs20 Server- und Klient Kommunikation zwischen Computern.{\line}F?r Server und Klient sind separate Programme erforderlich. Diese Klasse ist f?r den Server (s.a. LDClient).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 client-server\\*.sb}\par

\f0\pard\sb180\shading1000{\fs30\b AutoMessages \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bei 'auto' Modus Verbindungsnachrichten im TextWindow anzeigen?  "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Broadcast(message) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet eine Nachricht an alle Klienten.}\par
\f0\pard\sb75{\fs24\b message}\par
\f0\pard{\fs20 Die Nachricht. Kann eine beliebige Variable (auch Array) sein.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit dem Klientname als Index und einem Wert "SUCCESS", "NOT_CONNECTED", "NO_CLIENT" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ClientConnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein Klient eine Verbindung herstellt.}\par
\f0\pard\sb180\shading1000{\fs30\b ClientDisconnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein Klient getrennt wird.}\par
\f0\pard\sb180\shading1000{\fs30\b ClientMessage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein Klient eine Nachricht an den Server sendet.}\par
\f0\pard\sb180\shading1000{\fs30\b Close(clientName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Trennt und schliesst (beendet) einen Klient.}\par
\f0\pard\sb75{\fs24\b clientName}\par
\f0\pard{\fs20 Der Klientname, gew?hnlich Client1, Client2 usw.{\line}Eine Liste aktueller Klienten kann mittels 'GetClients' Methode erhalten oder vom 'ClientConnected' Ereignis gefunden werden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOT_CONNECTED", "NO_CLIENT" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b CloseDelay \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Eine Verz?gerung [ms] (Standard: 100) bei Trennung, um das Senden einer Nachricht zu erlauben, bevor die Verbindung getrennt wird (Stop, Disconnect und Close).{\line}Diese Verz?gerung sollte auch f?r die Klienten (LDClient.CloseDelay) gesetzt werden.}\par
\f0\pard\sb180\shading1000{\fs30\b Disconnect(clientName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Trennt einen Klient ab.}\par
\f0\pard\sb75{\fs24\b clientName}\par
\f0\pard{\fs20 Der Klientname, gew?hnlich Client1, Client2 usw.{\line}Eine Liste aktueller Klienten kann mittels 'GetClients' Methode erhalten oder vom 'ClientConnected' Ereignis gefunden werden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOT_CONNECTED", "NO_CLIENT" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetClients() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Liste aktuell verbundener Klienten.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit aktuellen Klientnamen oder "" f?r keiner.}\par
\f0\pard\sb180\shading1000{\fs30\b IP \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Die IP Adresse des Servers (bezieht sich standardm??ig auf die aktuelle LAN IP).{\line}Zur Verwendung ?ber das Internet wird eine eigene Web IP ben?tigt.}\par
\f0\pard\sb180\shading1000{\fs30\b LastClient \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der Name des letzten Klienten.}\par
\f0\pard\sb180\shading1000{\fs30\b LastClientConnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der Name des zuletzt verbundenen Klienten.}\par
\f0\pard\sb180\shading1000{\fs30\b LastClientDisconnected \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der Name des zuletzt getrennten Klienten.}\par
\f0\pard\sb180\shading1000{\fs30\b LastClientMessage \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Die letzte Klient Nachricht.}\par
\f0\pard\sb180\shading1000{\fs30\b Port \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Der zu verwendende Windows Port (Standard: 100).}\par
\f0\pard\sb180\shading1000{\fs30\b SendMessage(clientName,message) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet eine Nachricht an einen Klient.}\par
\f0\pard\sb75{\fs24\b clientName}\par
\f0\pard{\fs20 Der Klientname, gew?hnlich Client1, Client2 usw.{\line}Eine Liste aktueller Klienten kann mittels 'GetClients' Methode erhalten oder vom 'ClientConnected' Ereignis gefunden werden.}\par
\f0\pard\sb75{\fs24\b message}\par
\f0\pard{\fs20 Die Nachricht. Kann eine beliebige Variable (auch Array) sein.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS", "NOT_CONNECTED", "NO_CLIENT" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Start(auto) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet den Server.}\par
\f0\pard\sb75{\fs24\b auto}\par
\f0\pard{\fs20 Automatiche Nachrichten?bergabe?  "True" oder "False".{\line}Bei (empfohlener) Verwendung werden alle Klientdaten via Server an alle anderen Klienten ?bergeben,{\line}und es ist keine weitere Verarbeitung von Senden- und Empfangen Ereignissen erforderlich.{\line}Die Daten werden in Arrays (indexiert durch Klientname) aktualisiert, die von den 'LDClient.Update..' Methoden zur?ckgegeben werden.{\line}Die 'auto' Option sollte f?r Server und alle Klienten gleich sein.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die aktuellen Verbindungsparameter als IP:Port (zB. "192.168.1.60:100") oder "FAILED".{\line}Dies ist der zu verwendende Parameter f?r eine Verbindung vom Klient (LDClient.Connect).}\par
\f0\pard\sb180\shading1000{\fs30\b Stop() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt den aktuellen Server und schliesst alle Klienten.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDSettings}\par
\f0\pard{\fs20 Speichern und Abrufen von Benutzereinstellungen f?r Programme in einer bin?ren Settings-Datei.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\ClockWidget.sb}\par

\f0\pard\sb180\shading1000{\fs30\b FilePath \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den vollen Pfad der Einstellungsdatei.{\line}(Standard: Program.Directory\\ExeName.settings, s.a. File.GetSettingsFilePath)}\par
\f0\pard\sb180\shading1000{\fs30\b GetValue(name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Wert f?r eine Einstellung.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der Name der Einstellung in "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ermittelte Wert der Einstellung bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b SetValue(name,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Wert f?r eine Einstellung.{\line}Eine nicht bestehende Einstellungsdatei wird neu erstelllt.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der Name der Einstellung in "".}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Wert f?r die Einstellung.}\par
\f0\pard\sb300\shading2000{\fs36\b LDShapes}\par
\f0\pard{\fs20 Erweiterte Funktionen und Methoden f?r Shapes (Interne Namensverarbeitung erstellter Objekte).{\line}Diverse Pinsel (Brush#) k?nnen mit BrushGradient, BrushImage und BrushText erstellt werden.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 animated\\*.sb{\line}other-samples\\BrushGradients.sb, ShapeEvents.sb{\line}{\line}'Alle Eigenschaften zu 'shp':{\line}prop = LDShapes.GetProperties(shp){\line}idcs = Array.GetAllIndices(prop){\line}For n = 1 To Array.GetItemCount(idcs){\line}  TextWindow.WriteLine(idcs[n] +"="+ prop[idcs[n]]){\line}EndFor{\line}{\line}'Einzeleigenschaft zB. "Name":{\line}name = LDShapes.GetProperty(shp, "Name"){\line}{\line}'Eigenschaft setzen zB. 'Kein Fokus bei TAB':{\line}LDShapes.SetProperty(btn, "IsTabStop","False")}\par

\f0\pard\sb180\shading1000{\fs30\b AddAnimatedGif(imageName,repeat) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Bildshape mit animiertem Gif im GraphicsWindow hinzu (asynchron, Intern: Image#).{\line}Nicht zu viele davon einsetzen, da sonst die Computerleistung schnell abnimmt.{\line}Statische Gif (AnimationCount = 0) wird zwar geladen, aber nicht angezeigt.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Die zu ladende animierte Gif Datei als lokaler Dateipfad oder Url (KEIN ImageList Bild).}\par
\f0\pard\sb75{\fs24\b repeat}\par
\f0\pard{\fs20 Animation endlos wiederholen?  "True" oder "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der animierten Gif Bildshape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddAnimatedImage(imageName,repeat,countX,countY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Bildshape mit Bilderanimation (aus mehreren Einzelbildern) zum GraphicsWindow hinzu (asynchron, Intern: Image#). F?r Hintergrundtransparenz Png bevorzugen.{\line}Nicht zu viele davon einsetzen, da sonst Computerleistung schnell abnimmt.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Die zu ladende Bilddatei (Bilderstreifen) als lokaler Dateipfad, Url oder ImageList Name.}\par
\f0\pard\sb75{\fs24\b repeat}\par
\f0\pard{\fs20 Animation endlos wiederholen?  "True" oder "False".}\par
\f0\pard\sb75{\fs24\b countX}\par
\f0\pard{\fs20 Die Anzahl der Einzelbilder in x-Richtung (horizontal).}\par
\f0\pard\sb75{\fs24\b countY}\par
\f0\pard{\fs20 Die Anzahl der Einzelbilder in y-Richtung (vertikal).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der animierten Bildshape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddPolygon(points) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine gef?llte Vieleck Shape (Intern: Polygon#).}\par
\f0\pard\sb75{\fs24\b points}\par
\f0\pard{\fs20 Ein Array mit den Koordinaten der Ecken des i-Polygons in der Form pkt[i][1] = x, pkt[i][2] = y, usw.{\line}{\line}Die Mindestanzahl der i-Eckpunkte betr?gt 3 (s. AddRegularPolygon bzw. LDFigures.AddRegularPolygon).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Polygon Shape.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Gleichschenkeliges Dreieck:{\line} pkt[0]["X"] = 0{\line} pkt[0]["Y"] = 0{\line} pkt[1]["X"] = 80{\line} pkt[1]["Y"] = 0{\line} pkt[2]["X"] = 40{\line} pkt[2]["Y"] = 70{\line} LDShapes.AddPolygon(pkt)}\par
\f0\pard\sb180\shading1000{\fs30\b AddRegularPolygon(numPoint,radius) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine gef?llte, regelm??ige Vieleck Shape (Intern: Polygon#). Erster Punkt auf (radius;0), Ankerpunkt auf (0;0).{\line}S. AddPolygon, LDFigures.AddRegularPolygon.}\par
\f0\pard\sb75{\fs24\b numPoint}\par
\f0\pard{\fs20 Die Anzahl der Vieleck-Seiten bzw. -Ecken (ab 3).}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Der -/+ Abstand vom Zentrum zu den Ecken (Bei neg. Werten um 180/numPoint [Grad] verdreht).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der regelm??igen Vieleck Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b AddStar(numPoint,innerRadius,outerRadius) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine gef?llte, regelm??ige Stern Shape (Intern: Polygon#).{\line}Spa?effekte k?nnen mit neg. Abst?nden erzielt werden (s. LDFigures.AddRegularPolygon).}\par
\f0\pard\sb75{\fs24\b numPoint}\par
\f0\pard{\fs20 Die Anzahl der Sternpunkte (ab 3).}\par
\f0\pard\sb75{\fs24\b innerRadius}\par
\f0\pard{\fs20 Der -/+ Abstand vom Zentrum zu innereren Punkten.}\par
\f0\pard\sb75{\fs24\b outerRadius}\par
\f0\pard{\fs20 Der -/+ Abstand vom Zentrum zu ?u?eren Punkten.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der regelm??igen Stern Shape.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDShapes.AddStar(4, -50,100)}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateOpacity(shapeName,interval,count) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Shape zur Animation seiner Transparenz bzw. Blinken (aus- und einblenden, asynchron).{\line}gesamt [ms] = interval * count}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement, welche zum Blinken animiert wird.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 Das Intervall [ms] f?r einen vollen Blinkzyklus (<=0 stoppt das Blinken, zum Grundzustand, Standard).}\par
\f0\pard\sb75{\fs24\b count}\par
\f0\pard{\fs20 Die Anzahl voller Blinkzyklen (<=0 f?r stetiges Blinken, Standard).{\line}zB. 1.5 endet mit gegenteiligem Grundzustand.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateRotation(shapeName,interval,count) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Shape auf animierte Rotation um ihren Mittelpunkt (asynchron).{\line}gesamt [ms] = interval * count}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der drehenden Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 Die Dauer [ms] f?r eine volle 360 Grad Drehung (Standard: 0 stoppt die Rotation, <0 f?r Rotation im Gegenuhrzeigersinn).{\line}interval = 60000/umin [ms] bzw.{\line}umin = 60000/interval [1/min]{\line}loopDelay = interval/360 [ms/?]}\par
\f0\pard\sb75{\fs24\b count}\par
\f0\pard{\fs20 Die Anzahl voller Umdrehungen (<=0 f?r stetige Rotation, Standard).{\line}zB. 0.5 f?r Halbdrehung.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimateZoom(shapeName,interval,count,scaleX,scaleY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine Shape auf animierte Gr??en?nderung (gr??er/kleiner, wie Shapes.Zoom auch f?r Textshapes, asynchron) um ihren Mittelpunkt.{\line}gesamt [ms] = interval * count}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der zu zoomenden Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 Die Dauer [ms] f?r einen vollen Zoomzyklus (0 stoppt das Zoomen).}\par
\f0\pard\sb75{\fs24\b count}\par
\f0\pard{\fs20 Die Anzahl voller Zoom-Zyklen (0 f?r stetiges Zoomen, zB. 0.5 f?r Halbzyklus dh. nur in eine Richtung).}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 Der +/- Zoomfaktor in x-Richtung (1 Originalansicht).}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 Der +/- Zoomfaktor in y-Richtung (1 Originalansicht).}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationCount(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der Einzelbilder in einer animierten Bildshape (zB. AnimatedGif).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der animierten Bildshape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Gesamtzahl der Einzelbilder in der Animation, sonst 0 (zB. statische Gif).}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationInterval \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das Intervall in dem eine Shape-Animation abgespielt wird [ms] (Standard: 100).{\line}0 stoppt alle laufenden Animationen, um zB. AnimationSet zu erlauben, ein ausgew?hltes Einzelbild zu setzen.{\line}Dieser interne Taktgeber betrifft alle animierten Bilder, die nicht pausiert wurden oder noch keinen vollen Zyklus durchlaufen haben (f?r nicht-endlos wiederholende Animationen).}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationPause(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pausiert eine Bilderanimation.{\line}Pausierte Animationen k?nnen mittels AnimationSet trotzdem bestimmte Einzelbilder zeigen.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der animierten Bildshape.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationResume(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt eine zuvor pausierte Bilderanimation wieder fort.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der animierten Bildshape.}\par
\f0\pard\sb180\shading1000{\fs30\b AnimationSet(shapeName,image) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt das aktuell anzuzeigende Bild aus einer animierten Bildshape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der animierten Bildshape.}\par
\f0\pard\sb75{\fs24\b image}\par
\f0\pard{\fs20 Das anzuzeigende Einzelbild (ab 1).}\par
\f0\pard\sb180\shading1000{\fs30\b BrushColour(shapeName,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Pinselfarbe f?r ein bestehendes Shape/Control (zB. Hintergrundfarbe f?r Button, TextBox, Textshape).{\line}Sowohl f?r (LD)Controls.- als auch Geometrieshapes (Ellipse usw.).{\line}F?r Bildshapes s. LDShapes.SetImage.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die neue Pinselfarbe, "Transparent" f?r Transparenz (auch f?r Hintergrundbild aus ImageList), s. 'Shapes.SetOpacity'.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 "{\line}		}\par
\f0\pard\sb180\shading1000{\fs30\b BrushEllipse(brush,x,y,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeichnet eine Ellipse gef?llt mit einem Farbgradient. GraphicsWindow mu? bereits initialisiert sein.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 Ein zuvor erstellter Gradient- oder Bildpinsel (LDShapes.BrushGradient, LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate der Ellipse.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate der Ellipse.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der Ellipse.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der Ellipse.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushGradient(colours,orientation) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen linearen oder radialen Pinselfarbe Gradient (Intern: Brush#).}\par
\f0\pard\sb75{\fs24\b colours}\par
\f0\pard{\fs20 Ein Array mit (mind. 2) anzuwendenden Gradientfarben f?r den GW-/Shapehintergrund.}\par
\f0\pard\sb75{\fs24\b orientation}\par
\f0\pard{\fs20 Die Orientierung f?r den Farb?bergang:{\line}"H"	Horizontal (li -> re){\line}"V"	Vertikal (ob -> unt){\line}"DU"	Diagonal rauf (liU -> reO){\line}"DD"	Diagonal runter ("a","Z",0 usw., liO -> reU){\line}"R"	Radial (Standard, oder "", inn -> au?)}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name f?r den Gradientpinsel.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 brush = LDShapes.BrushGradient("1=Blue;2=#80FF0000;", "")}\par
\f0\pard\sb180\shading1000{\fs30\b BrushImage(imageName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen Pinsel aus einem Bild (Intern: Brush#).{\line}Diese Pinsel sollten auch ?berall dort funktionieren, wo BrushGradient verwendet werden kann.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Das als Pinsel zu ladende Bild.{\line}R?ckgabewert von ImageList.LoadImage, lokale oder Netzwerk- Bilddatei.{\line}"" erstellt Leerpinsel mit Farbe #6A5ACD (106,90,205)}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Bildpinsel.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushPolygon(brush,points) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeichnet ein i-Vieleck gef?llt mit einem Farbgradient. GraphicsWindow mu? bereits initialisiert sein.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 Ein zuvor erstellter Gradient- oder Bildpinsel (LDShapes.BrushGradient, LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b points}\par
\f0\pard{\fs20 Ein Array mit Koordinaten f?r die i-Polygonecken in der Form pkt[i][1] = x, pkt[i][2] = y.{\line}Die Mindestanzahl der i-Eckpunkte betr?gt 3.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 s. LDShapes.AddPolygon(points)}\par
\f0\pard\sb180\shading1000{\fs30\b BrushRectangle(brush,x,y,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeichnet ein Rechteck gef?llt mit einem Farbgradient. GraphicsWindow mu? bereits initialisiert sein.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 Ein zuvor erstellter Gradient- oder Bildpinsel (LDShapes.BrushGradient, LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Rechtecks.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Rechtecks.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des Rechtecks.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Rechtecks.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushRoundedRectangle(brush,x,y,width,height,radius) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeichnet ein abgerundetes Rechteck gef?llt mit einem Farbgradient. GraphicsWindow mu? bereits initialisiert sein.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 Ein zuvor erstellter Gradient- oder Bildpinsel (LDShapes.BrushGradient, LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Rechtecks.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 The y-Koordinate des Rechtecks.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite des Rechtecks.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he des Rechtecks.}\par
\f0\pard\sb75{\fs24\b radius}\par
\f0\pard{\fs20 Der Radius der gerundeten Ecken.}\par
\f0\pard\sb180\shading1000{\fs30\b BrushShape(shapeName,brush) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Hintergrund f?r ein bestehendes Shape/Control als Farbgradient.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b brush}\par
\f0\pard{\fs20 Ein zuvor erstellter Gradient- oder Bildpinsel (LDShapes.BrushGradient, LDShapes.BrushImage).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 slider = LDControls.AddSlider(200,22,"H"){\line}brush = LDShapes.BrushGradient("1=Red;2=Blue;","H"){\line}LDShapes.BrushShape(slider,brush)}\par
\f0\pard\sb180\shading1000{\fs30\b BrushText(text,background,foreground) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen Textpinsel (Intern: Brush#).{\line}Diese Pinsel sollten auch ?berall dort funktionieren, wo BrushGradient verwendet werden kann.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der als Pinsel (Brush) zu verwendende Text. Dabei werden aktuelle GraphicsWindow.Font.. Eigenschaften angewandt.}\par
\f0\pard\sb75{\fs24\b background}\par
\f0\pard{\fs20 Die Hintergrundfarbe (BrushColor).}\par
\f0\pard\sb75{\fs24\b foreground}\par
\f0\pard{\fs20 Die Vordergrund-/Textfarbe (PenColor).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Textpinsel.}\par
\f0\pard\sb180\shading1000{\fs30\b Centre(shapeName,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zentriert eine Shape (deren Mittelpunkt) an einem angegebenen Punkt. Auch f?r vergr??erte (gezoomte) Shapes.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des neuen Shape Mittelpunktes.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des neuen Shape Mittelpunktes.}\par
\f0\pard\sb180\shading1000{\fs30\b FastMove(shapeName,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt eine Shape an eine neue Position.{\line}Diese Methode ist f?r maximale Geschwindigkeit optimiert.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der zu verschiebenden Shape.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate der neuen Position.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate der neuen Position.}\par
\f0\pard\sb180\shading1000{\fs30\b Font(shapeName,family,size,bold,italic) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen neuen Schriftstil f?r eine bestehende Shape/Control (Textshape, Button, TextBox usw.).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b family}\par
\f0\pard{\fs20 Der Name der neuen Schriftart (erforderlich, zB. GraphicsWindow.FontName, s. LDUtilities.FontList f?r verf?gbare Schriftarten).}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Die neue Schriftgr??e (erforderlich).}\par
\f0\pard\sb75{\fs24\b bold}\par
\f0\pard{\fs20 Die neue Schrift als Fettdruck?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b italic}\par
\f0\pard{\fs20 Die neue Schrift kursiv?  "True" oder "False" (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllShapes() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die (internen) Name# aller aktuell erstellten Shapes/Controls als Array (zB. "1=Button#;2=Text#;3=Control#;4=_turtle;5=_turtleLine#;..").{\line}Bzgl. Anzahl erstellter Elemente eines Types s. LDUtilities.GetNextMapIndex.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array (ab 1) mit Name# aller vorhandenen Shapes/Controls in Reihenfolge ihrer Erstellung.}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllShapesAt(x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle (Bild-, Geometrie-, Text-) Shapes# (nicht Controls) an einer bestimmten Position im GraphicsWindow als Array.{\line}Dies kann zB. die Position des Mauszeigers sein. Nicht f?r verborgene Shape (Shapes.HideShape).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate der Position.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate der Position.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den (internen) Namen# aller Shapes an dieser Position oder "False" falls dort keine Shape liegt.{\line}Die ermittelten Namen# sind nach Z-Index sortiert, erst die im Vordergrund, dann die im Hintergrund befindlichen.}\par
\f0\pard\sb180\shading1000{\fs30\b GetColour(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt BrushColor, Opacity und PenColor einer Shape (s. LDShapes.GetOpacity).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 3-elementiger Array mit:{\line}1=BrushColor (Hintergrundfarbe, Pinselfarbe) als #AARRGGBB;{\line}2=ShapeOpacity (Deckkraft) von 0 bis 100 [%] (0 transparent, 100 deckend);{\line}3=PenColor (Vordergrundfarbe, Stiftfarbe) als #AARRGGBB;}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDShapes.GetColour("Button#") 'gibt zB:{\line}1=System.Windows.Media.LinearGradientBrush;{\line}2=100;{\line}3=#FF6A5ACD; (SlateBlue)}\par
\f0\pard\sb180\shading1000{\fs30\b GetLeft(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die linke Position des Ankerpunktes einer Shape (auch f?r Dreieck, Polygon und Linie). Unbeeinflu?t von Shapes.Zoom, -Rotate oder LDShapes.ReSize.{\line}Funktioniert auch f?r Shapes w?hrend einer Animation.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die x-Koordinate der linken (oberen) Ecke der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b GetOpacity(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Deckkraft einer Shape (s. LDShapes.GetColour).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert der Deckkraft (0 bis 100 [%]). 0 ist v?llig transparent und 100 ist v?llig deckend.}\par
\f0\pard\sb180\shading1000{\fs30\b GetProperties(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle verf?gbaren Eigenschaften einer Shape/Control als Array. Dies sind NET UIElement Eigenschaften.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array aller verf?gbaren Eigenschaften und deren Werte (zB: Fill, Height, IsMouseOver, IsVisible, Name, Opacity, Stroke, Width, usw.) bei Erfolg, sonst Fehlermeldung.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/system.windows.frameworkelement_properties.aspx{\line}http://msdn.microsoft.com/library/system.windows.uielement_properties.aspx{\line}'Alle Eigenschaften zu 'shp':{\line}prop = LDShapes.GetProperties(shp){\line}idcs = Array.GetAllIndices(prop){\line}For n = 1 To Array.GetItemCount(idcs){\line}  TextWindow.WriteLine(idcs[n] +"="+ prop[idcs[n]]){\line}EndFor}\par
\f0\pard\sb180\shading1000{\fs30\b GetProperty(shapeName,property) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine spezielle Eigenschaft einer Shape/Control. Dies ist eine NET UIElement Eigenschaft.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 Der (buchstabengetreue) Name der zu ermittelnden Eigenschaft (zB: Fill, Height, IsMouseOver, IsVisible, Name, Opacity, Stroke, Width, usw.).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert der Eigenschaft bei Erfolg, sonst Fehlermeldung.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Text in Textshape:{\line}GetProperty(shp, "Text"){\line}'Bild in Bildshape:{\line}GetProperty(shp, "Source"){\line}'Markierungsfarbe/Zeilen in TB:{\line}GetProperty(tb, "SelectionBrush") 'Strd: #FF3399FF{\line}GetProperty(tb, "LineCount"){\line}{\line}http://msdn.microsoft.com/library/system.windows.frameworkelement_properties.aspx{\line}http://msdn.microsoft.com/library/system.windows.uielement_properties.aspx}\par
\f0\pard\sb180\shading1000{\fs30\b GetTop(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die obere Position des Ankerpunktes einer Shape (auch f?r Dreieck, Polygon und Linie). Unbeeinflu?t von Shapes.Zoom, -Rotate oder LDShapes.ReSize.{\line}Funktioniert auch f?r Shapes w?hrend einer Animation.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die y-Koordinate der oberen (linken) Ecke der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b Height(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die tats?chlich sichtbare H?he einer Shape (zB. nach Zoom, umgebende Rechteckh?he bei Erstellung, angenommene PenWidth = 0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die sichtbare H?he der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b LastEventShape \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der letzten Shape, f?r die ein (ShapeEvent) Ereignis aufgetreten ist (s. SetShapeEvent).}\par
\f0\pard\sb180\shading1000{\fs30\b LastEventType \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den letzten Shape-Ereignistyp, der in einem (ShapeEvent) Ereignis aufgetreten ist (s. SetShapeEvent). M?gliche Ereignisse:{\line}"MouseDown", "MouseUp"{\line}"MouseEnter", "MouseLeave"{\line}"GotFocus", "LostFocus"}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 "MouseDown" und "MouseUp" Ereignisse nicht f?r linke Maustaste auf Control (Steuerelement). Jedoch f?r rechte/mittlere Maustaste auf Slider/Button.{\line}Alternativ s. FCControls.RegisterMouseDown(Up)Event}\par
\f0\pard\sb180\shading1000{\fs30\b Move(shapeName,x,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt ein Dreieck oder Polygon an dessen linker, oberer Position (Ankerpunkt).{\line}Diese Methode funktioniert auch f?r Linien- (Shapes.AddLine) und Bildshapes (Shapes.AddImage).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape (Dreieck-, Polygon-, Linien- oder Bildshape).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die neue (linke) x-Koordinate der Shape.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die neue (obere) y-Koordinate der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b MoveLine(shapeName,x1,y1,x2,y2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt eine Linien-Shape (Intern: Line#). Die L?nge der Linie wird je nach Zielkoordinaten ev. ver?ndert.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape (eine Linie, erstellt mit Shapes.AddLine).}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 Die x-Koordinate f?r Zielpunkt 1 der Linie.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 Die y-Koordinate f?r Zielpunkt 1 der Linie.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 Die x-Koordinate f?r Zielpunkt 2 der Linie.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 Die y-Koordinate f?r Zielpunkt 2 der Linie.}\par
\f0\pard\sb180\shading1000{\fs30\b MovePolygon(shapeName,points) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt ein gef?lltes Vieleck-Shape (Intern: Polygon#).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape (ein Polygon, erstellt mit LDShapes.AddPolygon).}\par
\f0\pard\sb75{\fs24\b points}\par
\f0\pard{\fs20 Ein Array mit den neuen Eck-Koordinaten des i-Polygons in der Form pkt[i][1] = x, pkt[i][2] = y, usw.{\line}{\line}Die Mindestanzahl der Eckpunkte betr?gt 3 und kann f?r jeden Aufruf ge?ndert werden.}\par
\f0\pard\sb180\shading1000{\fs30\b MoveTriangle(shapeName,x1,y1,x2,y2,x3,y3) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt ein Dreieck-Shape (Intern: Triangle#). Die Seitenl?nge(n), Form, Fl?che werden je nach Zielkoordinaten ev. ver?ndert}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape (ein Dreieck, erstellt mit Shapes.AddTriangle).}\par
\f0\pard\sb75{\fs24\b x1}\par
\f0\pard{\fs20 Die x-Koordinate f?r Zielpunkt 1 des Dreieckes.}\par
\f0\pard\sb75{\fs24\b y1}\par
\f0\pard{\fs20 Die y-Koordinate f?r Zielpunkt 1 des Dreieckes.}\par
\f0\pard\sb75{\fs24\b x2}\par
\f0\pard{\fs20 Die x-Koordinate f?r Zielpunkt 2 des Dreieckes.}\par
\f0\pard\sb75{\fs24\b y2}\par
\f0\pard{\fs20 Die y-Koordinate f?r Zielpunkt 2 des Dreieckes.}\par
\f0\pard\sb75{\fs24\b x3}\par
\f0\pard{\fs20 Die x-Koordinate f?r Zielpunkt 3 des Dreieckes.}\par
\f0\pard\sb75{\fs24\b y3}\par
\f0\pard{\fs20 Die y-Koordinate f?r Zielpunkt 3 des Dreieckes.}\par
\f0\pard\sb180\shading1000{\fs30\b Overlap(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ob sich die R?nder zweier Shapes beliebiger Form ?berschneiden (Kollisionserkennung).{\line}shape1 darf nicht rotiert oder skaliert (gezoomt) sein.{\line}F?r weitere ?berschneidungsarten s. 'OverlapDetail'.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape (unskaliert, nicht gedreht).}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" wenn sich beide Shapes ?berlappen (gemeinsame Pixel besitzen), sonst "False".}\par
\f0\pard\sb180\shading1000{\fs30\b OverlapBox(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ob sich die R?nder zweier eckiger Shapes ?berschneiden (Kollisionserkennung).{\line}F?r weitere ?berschneidungsarten s. 'OverlapDetail'.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" wenn sich beide Shapes ?berlappen (gemeinsame Pixel besitzen), sonst "False".}\par
\f0\pard\sb180\shading1000{\fs30\b OverlapCircle(shape1,shape2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ob sich die R?nder zweier runder Shapes ?berschneiden (Kollisionserkennung).{\line}F?r weitere ?berschneidungsarten s. 'OverlapDetail'.}\par
\f0\pard\sb75{\fs24\b shape1}\par
\f0\pard{\fs20 Der Name der ersten Shape.}\par
\f0\pard\sb75{\fs24\b shape2}\par
\f0\pard{\fs20 Der Name der zweiten Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" wenn sich beide Shapes ?berlappen (gemeinsame Pixel besitzen), sonst "False".}\par
\f0\pard\sb180\shading1000{\fs30\b OverlapDetail \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt, nach Aufruf einer 'Overlap..' Methode, zus?tzliche Details zu ?berschneidungen.{\line}{\line}M?gliche Ergebnisse:{\line}"Empty"		keine ?berlappung{\line}"FullyContains"	shape1 g?nzlich innerhalb von shape2{\line}"Intersects"	partielle ?berlappung{\line}"FullyInside"	shape2 g?nzlich innerhalb von shape1}\par
\f0\pard\sb180\shading1000{\fs30\b PenColour(shapeName,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Stiftfarbe f?r ein bestehendes Shape/Control (zB. Textfarbe in Button, TextBox oder Textshape, Turtle-Spur "_turtleLine#").}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Die neue Stiftfarbe (zB. "Transparent" verbirgt Buttontext).}\par
\f0\pard\sb180\shading1000{\fs30\b PenStyle(shapeName,dash,space) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Zeichenstil des Stiftes f?r eine bestehende Geometrieshape (Umrandung gestrichelt, gepunktet usw.).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b dash}\par
\f0\pard{\fs20 Die einzelne Strichl?nge oder 0 (keine Linie).}\par
\f0\pard\sb75{\fs24\b space}\par
\f0\pard{\fs20 Die L?nge der Unterbrechungen oder 0 (durchgezogen).}\par
\f0\pard\sb180\shading1000{\fs30\b PenWidth(shapeName,width) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Strichbreite des Stiftes f?r eine bestehende Geometrieshape.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die neue Strichbreite.}\par
\f0\pard\sb180\shading1000{\fs30\b RasteriseTurtleLines() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rastert alle Turtle-Spur Linien (Intern: "_turtleLine#" Linienshape).{\line}Bei gro?er Anzahl an Turtle-Spuren kann die Programmleistung durch die Anzahl vorhandener Linenshapes (Spuren) abnehmen.{\line}Hiermit werden diese Turtle-Spuren von Linienshapes zu Hintergrundzeichnungen konvertiert.}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveTurtleLines() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt alle Turtle-Spur Linien (Intern: "_turtleLine#" Linienshape).}\par
\f0\pard\sb180\shading1000{\fs30\b ResetTurtle() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Turtle nach Aufruf von GW.Clear oder Turtle.Hide an ihre letzte Position zur?ck und blendet diese stets ein.}\par
\f0\pard\sb180\shading1000{\fs30\b ReSize(shapeName,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt optisch eine neue Breite und H?he f?r ein bestehendes Shape/Control (uneingeschr?nkte Zoom-M?glichkeit, s. Shapes.Zoom, nicht f?r Text-Shapes).{\line}Die Gr??en?nderung erfolgt um den Mittelpunk der Shape nur optisch, dh. dieser und die tats?chlichen Abmessungen der Form bleiben erhalten.{\line}s.a. SetSize, bzw. Controls.SetSize.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die neue Breite der Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die neue H?he der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b RotateAbout(shapeName,x,y,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotiert eine Shape optisch um einen angegebenen Punkt (Ankerpunkt bleibt unver?ndert).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Koordinate des Pols um den die Shape gedreht wird.}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Koordinate des Pols um den die Shape gedreht wird.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Winkel [Grad] um den die Shape gedreht wird (+/- f?r im/gegen Uhrzeigersinn).}\par
\f0\pard\sb180\shading1000{\fs30\b SetImage(shapeName,imageName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt oder ?ndert ein Bild auf einem Button oder Bildshape (Intern: ImageList#+1). Bildgr??e von ImageList/Dateipfad wird automatisch an Gr??e der Bildshape angepasst bzw. Buttongr??e wird an Bildgr??e angepasst (Buttonbreite/-h?he = Bildbreite/-h?he + 4).{\line}ImageList Bild kann danach aus ImageList entfernt werden (LDImage.Remove). Entfernen des Bildes durch Ersetzen oder "none".}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name des Button oder Bildshape.}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Das zu setzende Bild als ImageList Name, Dateipfad oder Url. Sonstiger "string" oder Wert (au?er "") entfernt Bild/Titel und setzt Buttongr??e auf 4x4 bzw. Bildshape auf 0x0 Pxl.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Eine Leershape von Shapes.AddImage("") wird nicht akzeptiert.}\par
\f0\pard\sb180\shading1000{\fs30\b SetProperty(shapeName,property,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Wert einer Eigenschaft f?r eine Shape/Control. Dies ist eine NET UIElement Eigenschaft. Fehlermeldung bei Mi?erfolg.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 Der (buchstabengetreue) Name der zu setzenden Eigenschaft (zB: Fill, Height, IsMouseOver, IsVisible, Name, Opacity, Stroke, Width, usw.).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu setzende Eigenschaftswert.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Markierungsfarbe in TB{\line}SetProperty(tb, "SelectionBrush","#FFRRGGBB"){\line}'TB-Text zentriert,Block,links-/rechtsb?ndig{\line}SetProperty(tb, "TextAlignment","Center") 'Justify,Left,Right{\line}http://msdn.microsoft.com/library/system.windows.frameworkelement_properties.aspx{\line}http://msdn.microsoft.com/library/system.windows.uielement_properties.aspx}\par
\f0\pard\sb180\shading1000{\fs30\b SetShapeEvent(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Registriert eine bestehende Shape/Control zum Erkennen von Mausereignissen (per ShapeEvent) wie:{\line}MouseDown, MouseUp,{\line}MouseEnter, MouseLeave{\line} (f?r Maus- Unten/Oben, Ein-/Austritt) und{\line}GotFocus und LostFocus.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement (f?r Controls kein MouseDown/-Up).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Alternativ s. FCControls.RegisterMouseDown(Up)Event}\par
\f0\pard\sb180\shading1000{\fs30\b SetSize(shapeName,width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Gr??e einer bestehenden Shape, als ob sie in dieser Gr??e neu erstellt wurde (auch f?r Text-Shapes).{\line}Die Position (l.o. Ankerpunkt) bleibt unver?ndert (?hnlich Controls.SetSize), s.a. ReSize.}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die neue Breite der Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die neue H?he der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b SetTurtleImage(imageName,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt ein alternatives Turtle-Bild anstatt der orig. Schildkr?te (Intern: "_turtle" Bildshape) und zeigt dieses auch sofort an (Turtle.Show ist unn?tig).}\par
\f0\pard\sb75{\fs24\b imageName}\par
\f0\pard{\fs20 Das zu ladende Alternativbild f?r die Turtle.{\line}R?ckgabewert von ImageList.LoadImage, lokale oder Netzwerk-Bilddatei (bmp, gif, ico, jpg, png).}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Die Abmessungen/Skalierung [Pxl] f?r das neue Turtle-Bild (size=B=H, Standard Turtle ist 16x16 Pxl).{\line}"" zeigt kein Turtle-Bild. Unquadratische Originalbilder werden verzerrt dargestellt.{\line}Das neue Turtle-Bild wird am Mittelpunkt zentriert.}\par
\f0\pard\sb180\shading1000{\fs30\b ShapeEvent \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein Shape-Ereignis f?r eine (SetShapeEvent-) registrierte Shape/Control erkannt wird. Die Shape/Control mu? bereits erstellt und (mittels SetShapeEvent) daf?r registriert sein.}\par
\f0\pard\sb180\shading1000{\fs30\b Skew(shapeName,angleX,angleY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abschr?gen einer Shape um die angegebenen Winkel um den Shapemittelpunkt (2D Neigung, Scherung).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der abzuschr?genden Shape.}\par
\f0\pard\sb75{\fs24\b angleX}\par
\f0\pard{\fs20 Der -/+ Scherwinkel [Grad] in x-Richtung (Neigungswinkel ab y-Achse im/gegen Uhrzeigersinn, Standard: 0).}\par
\f0\pard\sb75{\fs24\b angleY}\par
\f0\pard{\fs20 Der -/+ Scherwinkel [Grad] in y-Richtung (Neigungswinkel ab x-Achse im/gegen Uhrzeigersinn, Standard: 0).}\par
\f0\pard\sb180\shading1000{\fs30\b Width(shapeName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die tats?chlich sichtbare Breite einer Shape (zB. nach Zoom, umgebende Rechteckbreite bei Erstellung, angenommene PenWidth = 0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die sichtbare Breite der Shape.}\par
\f0\pard\sb180\shading1000{\fs30\b ZIndex(shapeName,z_index) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Z-Index (Schichtposition) f?r eine Shape/Control (<0 im Hintergrund, >0 im Vordergrund, Standard: 0).}\par
\f0\pard\sb75{\fs24\b shapeName}\par
\f0\pard{\fs20 Der Name der Shape/Steuerelement.}\par
\f0\pard\sb75{\fs24\b z_index}\par
\f0\pard{\fs20 Der Z-Index (0, -/+ Ganzzahl).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/windows/apps/system.windows.controls.canvas.setzindex.aspx}\par
\f0\pard\sb180\shading1000{\fs30\b ZoomAll(scaleX,scaleY) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Vergr??ert oder verkleinert alle Shapes im GraphicsWindow optisch mittels der angegebenen Zoomwerte.{\line}Die Gr??en?nderungen erfolgen im Mittelpunkt jeder Shape nur optisch, dh. dieser, der Ankerpunkt und die tats?chlichen Abmessungen der Basisshape bleiben erhalten.{\line}Alle l?ngenbezogenen Werte/Vektoren (zB. in LDPhysics) werden proportional mitskaliert.}\par
\f0\pard\sb75{\fs24\b scaleX}\par
\f0\pard{\fs20 Der -/+ Zoomfaktor in x-Richtung (1 Originalansicht).}\par
\f0\pard\sb75{\fs24\b scaleY}\par
\f0\pard{\fs20 Der -/+ Zoomfaktor in y-Richtung (1 Originalansicht).}\par
\f0\pard\sb300\shading2000{\fs36\b LDShell}\par
\f0\pard{\fs20 Funktionen f?r erweiterte Dateiinfos, lnk/url Verkn?pfungen und Shell Anwendungen. (Code und Methoden von Pappa Lapub).}\par

\f0\pard\sb180\shading1000{\fs30\b AllDetails \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Namen aller verf?gbaren erweiterten Eigenschaften als Array (zB. Win7  "-1=Infotip;0=Name;..;286=Gesamtbitrate;").}\par
\f0\pard\sb180\shading1000{\fs30\b ApplyVerbOn(path,verb) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Wendet das angegebene Verb (Kontextmen?eintrag) f?r die angegebene Datei oder Ordner an.{\line}Liste verf?gbarer Verben (f?r Datei/-typ oder Ordner) unter s. 'GetAllVerbsFor'.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der volle Datei- oder Ordnerpfad.}\par
\f0\pard\sb75{\fs24\b verb}\par
\f0\pard{\fs20 Das anzuwendende Verb (Gro?-/Kleinschreibung bzw. '&' egal).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Textdatei bearbeiten (Systemstandard):{\line}LDShell.ApplyVerbOn(txtPfad, "Bearbeiten")}\par
\f0\pard\sb180\shading1000{\fs30\b CascadeWindows() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ordnet alle offenen Fenster in Kaskade unterteilt am Desktop an (Zur?cksetzen mit RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b DateTimeSettings() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt den Dialog 'Datum- und Uhrzeiteinstellungen' an.}\par
\f0\pard\sb180\shading1000{\fs30\b DTIconsHide() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blendet alle Desktopsymbole aus.}\par
\f0\pard\sb180\shading1000{\fs30\b DTIconsOn \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Anzeige der Desktopsymbole?  "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b DTIconsShow() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt alle ausgeblendeten Desktopsymbole wieder an.}\par
\f0\pard\sb180\shading1000{\fs30\b DTIconsToggle() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schaltet die Anzeige aller Desktopsymbole automatisch um (Ein/Aus).}\par
\f0\pard\sb180\shading1000{\fs30\b ExploreFolder(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet Explorer mit dem angegebenen Ordnerpfad (bzw. Elternordner f?r existierenden Dateipfad) in der Baumansicht. Neuer Tab in QTTabBar.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der im Explorer zu startende Ordner- bzw. Dateipfad (?ffnet Elternordner). Der Ordner mu? existieren.}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllDetailNamesFor(path,step1) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Namen aller verf?gbaren erweiterten Eigenschaften f?r angegebene Datei oder Ordner als Array (bis max. 316, ohne -1=Infotip).}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der volle Datei- oder Ordnerpfad.}\par
\f0\pard\sb75{\fs24\b step1}\par
\f0\pard{\fs20 Indizes in 1-Schritten?  "True" oder "False" (Standard, tats?chlicher Eigenschaftenindex).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Namen aller verf?gbaren erweiterten Eigenschaften als Array ("idx=Eigenschaftname;...", ohne Infotip) bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllDetailsFor(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle verf?gbaren erweiterten Eigenschaften f?r angegebene Datei oder Ordner als Array (bis max. 316, ohne -1=Infotip).}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der volle Datei- oder Ordnerpfad.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Alle verf?gbaren erweiterten Eigenschaften als Array ("Eigenschaftname=Wert;...", ohne Infotip) bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetAllVerbsFor(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle verf?gbaren Verben (Kontextmen?eintr?ge) f?r angegebene Datei/-typ oder Ordner als Array.{\line}Anwendung eines Verbs f?r Datei/Ordner unter s. 'ApplyVerbOn'.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der volle Datei- oder Ordnerpfad.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Alle verf?gbaren Verben als Array ("idx=Verb;...", ohne '&') bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b GetDetail(path,infoType) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Wert einer erweiterten Eigenschaft zu einem angegebenen Datei- oder Ordnerpfad.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der volle Datei- oder Ordnerpfad.}\par
\f0\pard\sb75{\fs24\b infoType}\par
\f0\pard{\fs20 Die Indexnummer oder Name der Eigenschaft (zB. -1="Infotip"|"", 0="Name", 1="Gr??e", usw.){\line}Indexnummern und Namen aller verf?gbaren Eigenschaften unter s. 'AllDetails'.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert der Eigenschaft wenn vorhanden, sonst "". "FAILED" bei Mi?erfolg (zB. fehlender Pfad).{\line}Infotip Zeilen getrennt durch lf, endend mit crlf.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 iTip = GetDetail(pfad, ""){\line}name = GetDetail(pfad, 0){\line}size = GetDetail(pfad, "gR?sse")}\par
\f0\pard\sb180\shading1000{\fs30\b GetSetting(value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Werte f?r globale Shell Einstellungen (s. Ordneroptionen-Ansicht, CheckedStatus).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Eine ganzzahlige Konstante f?r den zu ermittelnden Wert (zB. 1, 2, 4, "8", "32" usw.).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/windows/desktop/gg537739.aspx{\line}ShowAllObjects = SBShell.GetSetting(1){\line}ShowExtensions = SBShell.GetSetting(2){\line}ShowInfoTip = SBShell.GetSetting(8192){\line}ShowSuperHidden = SBShell.GetSetting(262144)}\par
\f0\pard\sb180\shading1000{\fs30\b GetSystemInfo(info) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine angegebene Systeminformation.}\par
\f0\pard\sb75{\fs24\b info}\par
\f0\pard{\fs20 Der Name des zu ermittelnden Wertes. Optionen:{\line}"DirectoryServiceAvailable", "DoubleClickTime", "ProcessorLevel", "ProcessorSpeed", "ProcessorArchitecture", "PhysicalMemoryInstalled", "IsOS_DomainMember"{\line}(Nur XP: "IsOS_Professional", "IsOS_Personal").}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ermittelte Wert bei Erfolg, sonst "" oder "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b LinkCreate(shortcut,target) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine neue lnk/url Verkn?pfung (Shell32). Weitere Bearbeitung mittels 'LinkSetProperty'.}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 Der volle Pfad der neuen lnk/url Verkn?pfung.}\par
\f0\pard\sb75{\fs24\b target}\par
\f0\pard{\fs20 Der volle Pfad f?r Zieldatei/-ordner bzw. url Adresse.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der volle Dateipfad der erstellten Verkn?pfung bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b LinkGetProperty(shortcut,property) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Eigenschaften einer lnk/url Verkn?pfung, wie Zielpfad, Argumente usw. (* f?r url, Shell32).}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 Der volle Pfad der lnk/url Verkn?pfung.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 Die zu ermittelnde Eigenschaft (Schreibweise egal, * f?r url):{\line}"Target"	 Zielpfad *{\line}"Args"	 Argumente{\line}"Folder"	 Startordner{\line}"Desc"	 Kommentar *{\line}"Icon"	 Symbolpfad,# (Strd: ,0)*{\line}"Hotkey" Tastencode (Strd: 0) *{\line}"Style"	 Stil (1 normal, 3 max, 7 min) *}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert der Eigenschaft oder "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b LinkSetProperty(shortcut,target,args,folder,desc,icoPath,icoIdx,hotkey,style) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Eigenschaften f?r eine bestehende lnk/url Verkn?pfung, wie Zielpfad, Argumente usw. (* f?r url, Shell32).}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 * Der volle Pfad der bestehenden lnk/url Verkn?pfung.}\par
\f0\pard\sb75{\fs24\b target}\par
\f0\pard{\fs20 * Voller Pfad f?r Zieldatei/-ordner bzw. url Adresse.}\par
\f0\pard\sb75{\fs24\b args}\par
\f0\pard{\fs20 Startparameter bei Aufruf oder "" (bei url).}\par
\f0\pard\sb75{\fs24\b folder}\par
\f0\pard{\fs20 Voller Pfad des Startordners oder "" (bei url).}\par
\f0\pard\sb75{\fs24\b desc}\par
\f0\pard{\fs20 * Kommentar/Beschreibung oder "".}\par
\f0\pard\sb75{\fs24\b icoPath}\par
\f0\pard{\fs20 * Voller Pfad der Symboldatei oder "".}\par
\f0\pard\sb75{\fs24\b icoIdx}\par
\f0\pard{\fs20 * Iconindex# in der Symboldatei (Strd: 0, f?r .ico).}\par
\f0\pard\sb75{\fs24\b hotkey}\par
\f0\pard{\fs20 * Tastencode zum Aufruf (Strd: 0).}\par
\f0\pard\sb75{\fs24\b style}\par
\f0\pard{\fs20 * Fensterstil bei Aufruf (Strd: 1 normal, 3 max, 7 min).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der volle Dateipfad der ge?nderten Verkn?pfung bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Name \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Name der ausf?hrenden Assembly f?r diese Extension.}\par
\f0\pard\sb180\shading1000{\fs30\b OpenFolder(path) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ffnet den angegebenen Ordnerpfad (bzw. Elternordner f?r existierenden Dateipfad) im Explorer. Neuer Tab in QTTabBar.}\par
\f0\pard\sb75{\fs24\b path}\par
\f0\pard{\fs20 Der im Explorer zu ?ffnende Ordner- bzw. Dateipfad (?ffnet Elternordner). Der Ordner mu? existieren.}\par
\f0\pard\sb180\shading1000{\fs30\b RestoreWindows() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stellt alle minimierten Fenster in der Taskleiste (nach ShowDesktop, TileAll.., CascadeWindows) wieder her.}\par
\f0\pard\sb180\shading1000{\fs30\b RunBox() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt den 'Ausf?hren' Dialog an.}\par
\f0\pard\sb180\shading1000{\fs30\b SelectFolder(title,initDir) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt einen Dialog zur Auswahl eines Ordners (unabh?ngig vom GW, s. 'LDDialogs.GetFolder').}\par
\f0\pard\sb75{\fs24\b title}\par
\f0\pard{\fs20 Der im Dialog anzuzeigende Titel.}\par
\f0\pard\sb75{\fs24\b initDir}\par
\f0\pard{\fs20 Der Startordner bei ?ffnen des Dialogs oder "" f?r zuletzt gew?hlten Ordner (Standard: Arbeitsplatz).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der volle Ordnerpfad bei Auswahl oder "" bei Abbruch, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShellLink(shortcut,target) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine neue lnk/url Verkn?pfung (IWshRuntimeLibrary). Weitere Bearbeitung mittels 'ShellLinkSet'.}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 Der volle Pfad der neuen lnk/url Verkn?pfung.}\par
\f0\pard\sb75{\fs24\b target}\par
\f0\pard{\fs20 Der volle Pfad f?r Zieldatei/-ordner bzw. url Adresse.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der volle Dateipfad der erstellten Verkn?pfung bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShellLinkGet(shortcut,property) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Eigenschaften einer lnk/url Verkn?pfung, wie Zielpfad, Argumente usw. (* f?r url, IWshRuntimeLibrary).}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 Der volle Pfad der lnk/url Verkn?pfung.}\par
\f0\pard\sb75{\fs24\b property}\par
\f0\pard{\fs20 Die zu ermittelnde Eigenschaft (Schreibweise egal, * f?r url):{\line}"Target"	 Zielpfad *{\line}"Args"	 Argumente{\line}"Folder"	 Startordner{\line}"Desc"	 Kommentar *{\line}"Icon"	 Symbolpfad,# (Strd: ,0)*{\line}"Hotkey" Tastenkomb. (Strd: "") *{\line}"Style"	 Stil (1 normal, 3 max, 7 min) *}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Wert der Eigenschaft oder "" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShellLinkSet(shortcut,target,args,folder,desc,icon,hotkey,style) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt Eigenschaften f?r eine bestehende lnk/url Verkn?pfung, wie Zielpfad, Argumente usw. (* f?r url, IWshRuntimeLibrary).}\par
\f0\pard\sb75{\fs24\b shortcut}\par
\f0\pard{\fs20 * Der volle Pfad der bestehenden lnk/url Verkn?pfung.}\par
\f0\pard\sb75{\fs24\b target}\par
\f0\pard{\fs20 * Voller Pfad f?r Zieldatei/-ordner bzw. url Adresse.}\par
\f0\pard\sb75{\fs24\b args}\par
\f0\pard{\fs20 Startparameter bei Aufruf oder "" (bei url).}\par
\f0\pard\sb75{\fs24\b folder}\par
\f0\pard{\fs20 Voller Pfad des Startordners oder "" (bei url).}\par
\f0\pard\sb75{\fs24\b desc}\par
\f0\pard{\fs20 * Kommentar/Beschreibung oder "".}\par
\f0\pard\sb75{\fs24\b icon}\par
\f0\pard{\fs20 * Voller Pfad(,#) der Symboldatei oder "". '#' ist Index in der Symboldatei (Strd: 0, f?r .ico).}\par
\f0\pard\sb75{\fs24\b hotkey}\par
\f0\pard{\fs20 * Tastenkomb. zum Aufruf (Strd: "").}\par
\f0\pard\sb75{\fs24\b style}\par
\f0\pard{\fs20 * Fensterstil bei Aufruf (Strd: 1 normal, 3 max, 7 min).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der volle Dateipfad der ge?nderten Verkn?pfung bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ShowDesktop() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Minimiert alle offenen Fenster in die Taskleiste und zeigt den Desktop an (Zur?cksetzen mit RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b ShowFileProperties(filePath) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt den Shell Eigenschaftendialog f?r angegebene Datei oder Ordner an (GW ist daf?r erforderlich, nicht von TW/Console oder nach GW.Hide/GW.Show).{\line}Erfordert Aufruf als STAThread oder mittels Ereignis Sub.}\par
\f0\pard\sb75{\fs24\b filePath}\par
\f0\pard{\fs20 Der volle Datei- oder Ordnerpfad.}\par
\f0\pard\sb180\shading1000{\fs30\b SpecialFolderConstants \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle CSIDL Nummern mit deren speziellen System-/Shellordnernamen als Array ("csidl#=Ordnername;..;").}\par
\f0\pard\sb180\shading1000{\fs30\b SpecialFolderList(csidl) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle Objekte in einem speziellen System-/Shellordner (oberste Ebene).}\par
\f0\pard\sb75{\fs24\b csidl}\par
\f0\pard{\fs20 Die CSIDL Nummer des Systemordners (0 bis 47, Konstanten und Namen m?glicher Ordner unter s. 'SpecialFolderConstants').}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Namen der Objekte im Systemordner als Array (nur oberste Ebene) bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'zB. csidl# .. Ordner:{\line} 3  Systemsteuerung{\line} 5  Eigene Dokumente{\line} 8  Zuletzt verwendet{\line} 9  SendTo{\line}10  Papierkorb{\line}16  Desktopordner{\line}17  Computer{\line}20  Fonts{\line}32  Temp Inet Files{\line}...{\line}http://msdn.microsoft.com/library/bb774096.aspx}\par
\f0\pard\sb180\shading1000{\fs30\b SpecialFolderPaths \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle speziellen System-/Shellordnernamen mit deren Ordnerpfaden als Array ("Ordnername=Pfad;..;").}\par
\f0\pard\sb180\shading1000{\fs30\b SpecialFolders \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Pfade aller speziellen Systemodner als Array ("Ordnername=Pfad;.."). F?r Shellordner s. 'SpecialFolderPaths'.}\par
\f0\pard\sb180\shading1000{\fs30\b StartSettings() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt den Dialog 'Startmen?-/Taskleiste Eingenschaften' an.}\par
\f0\pard\sb180\shading1000{\fs30\b Switch3D() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ordnet alle offenen Fenster in einem 3D-Stapel zur Durchwahl (mit Pfeiltasten, Auswahl mit Eingabe Taste).}\par
\f0\pard\sb180\shading1000{\fs30\b TileAllHoriz() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ordnet alle offenen Fenster waagrecht unterteilt am Desktop an (Zur?cksetzen mit RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b TileAllVert() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ordnet alle offenen Fenster senkrecht unterteilt am Desktop an (Zur?cksetzen mit RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b ToggleDesktop() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Schaltet die Anzeige des (fensterlosen) Desktop um (Ein/Aus, s. ShowDesktop/RestoreWindows).}\par
\f0\pard\sb180\shading1000{\fs30\b Version \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die aktuelle Dateiversion dieser Extension (sonst 0.0.0.0).}\par
\f0\pard\sb300\shading2000{\fs36\b LDSort}\par
\f0\pard{\fs20 Sortieren von SB Arrays (numerische oder Stringarrays).{\line}Strings sind mit/ohne Beachtung von Gro?-/Kleinschreibung sortierbar, s. 'CaseSensitive'.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\ListBox.sb}\par

\f0\pard\sb180\shading1000{\fs30\b ByIndex(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sortiert einen Array beliebiger Dimension nach aufsteigenden Indizes.{\line}Der Eingabearray bleibt unver?ndert.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu sortierende Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der sortierte Array.}\par
\f0\pard\sb180\shading1000{\fs30\b ByValue(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sortiert einen 1D Array nach aufsteigenden Arraywerten (Alle Indizes werden neu durchnummeriert ab 1, s. 'LDStatistics.SetArray').{\line}Der Eingabearray bleibt unver?ndert.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu sortierende 1D Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der sortierte Array.}\par
\f0\pard\sb180\shading1000{\fs30\b ByValueWithIndex(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sortiert einen 1D Array nach Arraywerten (Indizes bleiben unver?ndert aber sortiert).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu sortierende 1D Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der sortierte Array.}\par
\f0\pard\sb180\shading1000{\fs30\b CaseSensitive \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Beachtung von Gro?-/Kleinschreibung bei Stringvergleich.  "True" (Standard) oder "False".}\par
\f0\pard\sb300\shading2000{\fs36\b LDSound}\par
\f0\pard{\fs20 Soundaufnahme von einem erforderlichen (ev. internen) Mikrofon in eine angegebene wav Datei. Diese wird mit LDSound.Stop gespeichert.{\line}SystemSounds k?nnen ebenfalls abgespielt werden, wenn diese passend gesetzt sind (s.a. SB Sound Objekt, mmsys.cpl,2, %WinDir%\\Media).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDSound.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Asterisk() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Spielt den 'Asterisk (Sternchen)' Systemsound ab.}\par
\f0\pard\sb180\shading1000{\fs30\b Beep() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Spielt den 'Beep (Standardton Warnsignal)' Systemsound ab.}\par
\f0\pard\sb180\shading1000{\fs30\b Exclamation() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Spielt den 'Exclamation (Hinweis)' Systemsound ab.}\par
\f0\pard\sb180\shading1000{\fs30\b Hand() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Spielt den 'Hand (Kritischer Abbruch)' Systemsound ab.}\par
\f0\pard\sb180\shading1000{\fs30\b MusicPlayTime(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die L?nge (Gesamtabspieldauer [sec]) einer Audiodatei (mp3, wav, wma bzw. flac, m4a, ogg). Ev. Videodatei (avi, mp4).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der Audiodatei zB. "C:\\Users\\Public\\Music\\song.mp3".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die L?nge der Audiodatei [sec] bei Erfolg, sonst 0 (und Fehlermeldung).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 s = LDSound.MusicPlayTime(audio) '[sec]{\line}mmss = Math.Floor(s/60) +":"+ Math.Remainder(s,60) '[mm:ss]}\par
\f0\pard\sb180\shading1000{\fs30\b Pause() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pausiert die aktuelle Soundaufnahme.}\par
\f0\pard\sb180\shading1000{\fs30\b Question() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Spielt den 'Question (Frage)' Systemsound ab.}\par
\f0\pard\sb180\shading1000{\fs30\b Resume() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt die Aufnahme einer pausierten Soundaufnahme fort.}\par
\f0\pard\sb180\shading1000{\fs30\b Start() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet die Soundaufnahme.}\par
\f0\pard\sb180\shading1000{\fs30\b Stop(wavFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt und speichert die aktuelle Soundaufnahme in eine angegebene wav Datei.}\par
\f0\pard\sb75{\fs24\b wavFile}\par
\f0\pard{\fs20 Voller Pfad der wav Datei zum Speichern der Audioaufnahme.{\line}Dateierweiterung wird zu .wav gesetzt, falls anders angegeben.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei erfolgreichem Speichern, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Tone(frequency,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Spielt einen BeepSound mit angegebener Frequenz und Dauer ?ber den internen Lautsprecher ab.{\line}Verwendet den Motherboard Lautsprecher (nicht Soundkarte) und mag von geringer Qualit?t oder gar nicht verf?gbar sein.}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Die Tonfrequenz des Beeps (37 bis 32767 [Hz]).}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Tondauer [ms].}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Kammerton 'a' hat 440 Hz. Halbtonschritt Fakt. = 2^(1/12) = 1.059463, Ganztonschritt Fakt. = 2^(1/6) = 1.1222462, Oktave Fakt. = 2.{\line}http://de.wikipedia.org/wiki/Frequenzen_der_gleichstufigen_Stimmung}\par
\f0\pard\sb180\shading1000{\fs30\b Volume(command) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den Lautst?rkepegel f?r Sounds im aktuellen GraphicsWindow.}\par
\f0\pard\sb75{\fs24\b command}\par
\f0\pard{\fs20 Die Option zum ?ndern der Lautst?rke:{\line}"Up"	- Lautst?rke{\line}"Down"	+ Lautst?rke{\line}"Mute"	Stumm <-> Laut}\par
\f0\pard\sb300\shading2000{\fs36\b LDSpeech}\par
\f0\pard{\fs20 Erm?glicht Sprachausgabe von Text (TTS) oder das Erkennen von Sprache (Sprachbefehlen).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\SpeechRecognition.sb}\par

\f0\pard\sb180\shading1000{\fs30\b LastSpoken \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Text der zuletzt gesprochen und vom System erkannt wurde.}\par
\f0\pard\sb180\shading1000{\fs30\b LastSpokenConfidence \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das Vertrauen in die Korrektheit der zuletzt erkannten Spracheingabe (0 bis 1).}\par
\f0\pard\sb180\shading1000{\fs30\b Listen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn Text gesprochen und vom Computer erkannt wird.{\line}Ein gutes Mikrofon, einige ?bung und ein pr?gnantes Vokabular werden f?r brauchbare Ergebnisse ben?tigt.}\par
\f0\pard\sb180\shading1000{\fs30\b Speak(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Spricht den angegebenen Text mit der gew?hlten Stimme (sonst Standardstimme [1]).}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der auszusprechende Text.}\par
\f0\pard\sb180\shading1000{\fs30\b Speed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Geschwindigkeit der Sprachausgabe (-10 bis 10).}\par
\f0\pard\sb180\shading1000{\fs30\b Vocabulary(dictionary) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein Vokabular an W?rtern und S?tzen zur Verwendung f?r die Spracherkennung.{\line}Falls dieses nicht erstellt wurde, wird eine sehr gro?e Sprachbibliothek verwendet und die daraus resultierenden Ergebnisse sind nicht optimal (unbrauchbar!).{\line}Deutlich gesprochene S?tze werden besser erkannt als einzelne Worte.}\par
\f0\pard\sb75{\fs24\b dictionary}\par
\f0\pard{\fs20 Ein Array von W?rtern oder S?tzen die erkannt werden sollen.{\line}Ist dieser leer, wird das voreingestellte (englische) Sprachvokabular benutzt.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\SpeechRecognition.sb}\par
\f0\pard\sb180\shading1000{\fs30\b Voice \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die aktuell verwendete Sprechstimme.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 voc = LDSpeech.Voices(){\line}'Standardstimme voc[1] bzw.{\line}TextWindow.WriteLine(LDSpeech.Voice){\line}LDSpeech.Voice = voc[2] 'andere Stimme{\line}LDSpeech.Speak("text")}\par
\f0\pard\sb180\shading1000{\fs30\b Voices() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Namen der verf?gbaren installierten Sprechstimmen als Array (nur 64bit Stimmen auf 64bit Win).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Namen aller verf?gbaren Stimmen (alphabetisch sortiert, ab 1).}\par
\f0\pard\sb180\shading1000{\fs30\b Volume \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Lautst?rke der Sprachausgabe (0 bis 100 [%]).}\par
\f0\pard\sb300\shading2000{\fs36\b LDStatistics}\par
\f0\pard{\fs20 Ermittelt statistische Werte f?r einen numerischen 1D Array (wird zuerst sortiert).{\line}Zuerst mit 'SetArray' einen numerischen 1D Array definieren.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 graph_samples\\graph-statistics.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Count \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der Punkte.}\par
\f0\pard\sb180\shading1000{\fs30\b Differentiate(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die numerischen Differentialwerte (Tangententrapezregel) f?r einen 1D Array.{\line}Die Elementanzahl im Ausgabearray ist um 1 verringert (Intervall Mittelpunkte).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der abzuleitende Array (arr[x]=y).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die einzelnen Intervallsteigungen des Eingabearrays als 1D Array.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Numerische_Differentiation}\par
\f0\pard\sb180\shading1000{\fs30\b DistBinomial(n,p) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die binomische Verteilung als Array (Indizes von 0 bis n).{\line}Etwa die Wahrscheinlichkeit k-mal Kopf in 20 (n) M?nzw?rfen zu erhalten, mit einer Wahrscheinlichkeit von 0.5 (p) f?r jeden Wurf, Kopf zu erhalten.}\par
\f0\pard\sb75{\fs24\b n}\par
\f0\pard{\fs20 Die Anzahl der Versuche.}\par
\f0\pard\sb75{\fs24\b p}\par
\f0\pard{\fs20 Die Erfolgswahrscheinlichkeit f?r jeden Versuch.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 1D Array mit Binomialverteilung, Wahrscheinlichkeit von k Erfolgen (arr[k]=y).}\par
\f0\pard\sb180\shading1000{\fs30\b DistNormal(distMean,distSTD,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Normal- oder Gau?-Verteilung als Array.}\par
\f0\pard\sb75{\fs24\b distMean}\par
\f0\pard{\fs20 Die mittlere Verteilung.}\par
\f0\pard\sb75{\fs24\b distSTD}\par
\f0\pard{\fs20 Die Standardabweichung der Verteilung.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Die Anzahl der Punkte.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 1D Array mit Normalverteilung (arr[x]=y).}\par
\f0\pard\sb180\shading1000{\fs30\b DistTriangular(rangeMin,rangeMax,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die (triangul?re) Dreiecksverteilung als Array.}\par
\f0\pard\sb75{\fs24\b rangeMin}\par
\f0\pard{\fs20 Der untere Grenzwert.}\par
\f0\pard\sb75{\fs24\b rangeMax}\par
\f0\pard{\fs20 Der obere Grenzwert.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Die Anzahl der Punkte.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 1D Array mit (triangul?rer) Dreiecksverteilung (arr[x]=y).}\par
\f0\pard\sb180\shading1000{\fs30\b DistUniform(rangeMin,rangeMax,size) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die einheitliche (stetige) Gleichverteilung als Array.}\par
\f0\pard\sb75{\fs24\b rangeMin}\par
\f0\pard{\fs20 Der untere Grenzwert.}\par
\f0\pard\sb75{\fs24\b rangeMax}\par
\f0\pard{\fs20 Der obere Grenzwert.}\par
\f0\pard\sb75{\fs24\b size}\par
\f0\pard{\fs20 Die Anzahl der Punkte.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 1D Array mit stetiger Gleichverteilung (arr[x]=y).}\par
\f0\pard\sb180\shading1000{\fs30\b Frequency(array,bins,normalised) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die H?ufigkeitsverteilung in den Daten eines Arrays.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der Array dessen H?ufigkeitsverteilung zu berechnen ist.}\par
\f0\pard\sb75{\fs24\b bins}\par
\f0\pard{\fs20 Die Anzahl der Werte die die Daten umfassen.}\par
\f0\pard\sb75{\fs24\b normalised}\par
\f0\pard{\fs20 Normierte H?ufigkeitsverteilung mit einer Gesamtsumme 1?  "True" oder "False".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die H?ufigkeitsverteilung als Array (arr[bin]=H?ufigkeit).}\par
\f0\pard\sb180\shading1000{\fs30\b GeometricMean \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das geometrische Mittel aller Punkte (wenn alle Werte >0, sonst 0).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Mittelwert}\par
\f0\pard\sb180\shading1000{\fs30\b HarmonicMean \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das harmonische Mittel aller Punkte (wenn alle Werte >0, sonst 0).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Mittelwert}\par
\f0\pard\sb180\shading1000{\fs30\b Integrate(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die numerische Integration (Sehnentrapezregel) ?ber einen 1D Array.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der aufzusummierende Array (arr[x]=y).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die aufsummierten Einzelintegrale ?ber den Eingabearray (ab unterem Grenzwert) als 1D Array.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Numerische_Integration}\par
\f0\pard\sb180\shading1000{\fs30\b InterpolateX(array,y) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Interpoliert einen 1D Array um den Wert von x(y) zu finden.{\line}Die y-Werte sollten monoton mit x ansteigen.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu interpolierende Array (arr[x]=y).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Der y-Wert (oder Array mit y-Werten).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der interpolierte x-Wert (oder Array von x-Werten).}\par
\f0\pard\sb180\shading1000{\fs30\b InterpolateY(array,x) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Interpoliert einen 1D Array um den Wert von y(x) zu finden.{\line}Die x-Werte sollten monoton ansteigen.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu interpolierende Array (arr[x]=y).}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Der x-Wert (oder Array mit x-Werten).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der interpolierte y-Wert (oder Array von y-Werten).}\par
\f0\pard\sb180\shading1000{\fs30\b Max \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Maximalwert aller Punkte.}\par
\f0\pard\sb180\shading1000{\fs30\b Mean \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das arithmetische Mittel aller Punkte (Sum / Count).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Mittelwert}\par
\f0\pard\sb180\shading1000{\fs30\b Median \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den mittenliegenden Zentralwert aller Punkte.}\par
\f0\pard\sb180\shading1000{\fs30\b Min \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Minimalwert aller Punkte.}\par
\f0\pard\sb180\shading1000{\fs30\b Mode \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Modalwert (h?ufigster Wert der Stichprobenergebnisse) aller Punkte.}\par
\f0\pard\sb180\shading1000{\fs30\b PDev \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Abweichung von der Grundgesamtheit aller Punkte.}\par
\f0\pard\sb180\shading1000{\fs30\b SDev \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Standardabweichung aller Punkte.}\par
\f0\pard\sb180\shading1000{\fs30\b SetArray(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen numerischen 1D Array als LDStatistics-Objekt (Sortiert zuvor nach aufsteigenden Arraywerten, s. 'LDSort.ByValue').{\line}Diese Methode mu? vor allen anderen aus dieser Klasse aufgerufen werden.}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Der zu setzende und sortierende Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 1D Array mit sortierten Daten (aufsteigende Arraywerte, fortlaufende Indizes ab 1).}\par
\f0\pard\sb180\shading1000{\fs30\b Sum \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Summe aller Punktewerte.}\par
\f0\pard\sb180\shading1000{\fs30\b Sum2 \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Summe der Quadrate aller Punktewerte.}\par
\f0\pard\sb300\shading2000{\fs36\b LDStopwatch}\par
\f0\pard{\fs20 Genaue System Stoppuhren (Intern: Stopwatch#).}\par

\f0\pard\sb180\shading1000{\fs30\b Add() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine neue Stoppuhr (Intern: Stopwatch#+1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Stoppuhr.}\par
\f0\pard\sb180\shading1000{\fs30\b DelayUpTo(delay) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verz?gerung bis zu einem maximalen Intervall seit dem letzten Aufruf.{\line}Sinnvoll in einer Hauptschleife um eine gleichm??ige Abspielgeschwindigkeit beizubehalten (frameRate, fps).}\par
\f0\pard\sb75{\fs24\b delay}\par
\f0\pard{\fs20 Die maximale Verz?gerung [ms].}\par
\f0\pard\sb180\shading1000{\fs30\b ElapsedMilliseconds(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die abgelaufene Gesamtzeit [ms] f?r die angegebene Stoppuhr.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 Der Name der Stoppuhr.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl abgelaufener Millisekunden bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b ElapsedTicks(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die abgelaufene Zeit [TimerTicks] f?r sehr kurze Intervalle.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 Der Name der Stoppuhr.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl abgelaufener Ticks bei Erfolg, sonst -1.}\par
\f0\pard\sb180\shading1000{\fs30\b Frequency \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Frequenz des Stoppuhr Zeitgebers [Ticks/sec].{\line}Dies repr?sentiert die genaueste Zeitaufl?sung, welche die Hardware mit ElapsedTicks messen kann.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 hz = LDStopwatch.Frequency{\line}TextWindow.WriteLine(hz +" Hz ("+ hz/"1e6" +" MHz)"){\line}TextWindow.WriteLine("1e9"/hz +" ns/Tick")}\par
\f0\pard\sb180\shading1000{\fs30\b Reset(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt die angegebene Stoppuhr und setzt die abgelaufene Zeit auf 0 zur?ck.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 Der Name der Stoppuhr.}\par
\f0\pard\sb180\shading1000{\fs30\b Restart(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt die angegebene Stoppuhr, setzt die abgelaufene Zeit auf 0 zur?ck und startet diese Stoppuhr erneut.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 Der Name der Stoppuhr.}\par
\f0\pard\sb180\shading1000{\fs30\b Start(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet oder setzt eine pausierte Stoppuhr wieder fort.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 Der Name der Stoppuhr.}\par
\f0\pard\sb180\shading1000{\fs30\b Stop(stopwatch) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt oder pausiert die angegebene Stoppuhr.}\par
\f0\pard\sb75{\fs24\b stopwatch}\par
\f0\pard{\fs20 Der Name der Stoppuhr.}\par
\f0\pard\sb300\shading2000{\fs36\b LDText}\par
\f0\pard{\fs20 Methoden zur String-/Textmanipulation.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDxml.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Compare(text1,text2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Lexikalischer Vergleich zweier Textstrings (rel. Position in deren Sortierreihenfolge) oder SB Arrays. Der Vergleich ist unabh?ngig von Gro?-/Kleinschreibung und Kultur.}\par
\f0\pard\sb75{\fs24\b text1}\par
\f0\pard{\fs20 Der erste Vergleichsstring.}\par
\f0\pard\sb75{\fs24\b text2}\par
\f0\pard{\fs20 Der zweite Vergleichsstring.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine Ganzzahl, wobei:{\line}<0  text1 ist kleiner als text2{\line}=0  beide Strings sind gleichwertig{\line}>0  text1 ist gr??er als text2}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDText.Compare("ABCD", "abd") '-1{\line}LDText.Compare("ABCD", " abd") '1{\line}LDText.Compare("A?", "ass") '0{\line}LDText.Compare(arr1, arr2)}\par
\f0\pard\sb180\shading1000{\fs30\b FastStringAppend(fastString,text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Textstring an ein FastString Objekt an.}\par
\f0\pard\sb75{\fs24\b fastString}\par
\f0\pard{\fs20 Der Name des FastString Objekts.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der anzuf?gende Textstring.}\par
\f0\pard\sb180\shading1000{\fs30\b FastStringClear(fastString) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Bereinigt ein FastString Objekt, Zur?cksetzen auf "".}\par
\f0\pard\sb75{\fs24\b fastString}\par
\f0\pard{\fs20 Der Name des FastString Objekts.}\par
\f0\pard\sb180\shading1000{\fs30\b FastStringGet(fastString) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den aktuellen Textinhalt in einem FastString Objekt.}\par
\f0\pard\sb75{\fs24\b fastString}\par
\f0\pard{\fs20 Der Name des FastString Objekts.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der aktuelle FastString Text oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b FastStringNew() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein neues FastString Objekt zum schnellen Anf?gen von Textstrings (Intern: FastString#, StringBuilder).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name f?r das neue FastString Objekt.}\par
\f0\pard\sb180\shading1000{\fs30\b FindAll(text,find) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle Vorkommen eines Untertextes im Basistext.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der zu durchsuchende Basistext.}\par
\f0\pard\sb75{\fs24\b find}\par
\f0\pard{\fs20 Der zu suchende Teiltext (buchstabengetreu).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Startpositionen f?r jeden gefundenen Subtext (0 bei keinem Treffer).}\par
\f0\pard\sb180\shading1000{\fs30\b GetHeight(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die H?he [Pxl] in der ein Text im GraphicsWindow bei aktuell gesetzter Schrift angezeigt wird. Gesamth?he aller Zeilen bei mehrzeiligem Text (incl. endendem CrLf).{\line}Das GraphicsWindow mu? f?r diese Methode ge?ffnet sein.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der Text dessen H?he zu ermitteln ist.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Texth?he [Pxl].}\par
\f0\pard\sb180\shading1000{\fs30\b GetWidth(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Breite [Pxl] in der ein Text im GraphicsWindow bei aktuell gesetzter Schrift angezeigt wird. Breite der l?ngsten Zeile bei mehrzeiligem Text.{\line}Das GraphicsWindow mu? f?r diese Methode ge?ffnet sein.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der Text dessen Breite zu ermitteln ist.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Textbreite [Pxl].}\par
\f0\pard\sb180\shading1000{\fs30\b Replace(text,find,replace) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sucht und ersetzt alle Vorkommen einer Zeichenfolge in einem Text durch einen Ersatzstring.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der zu durchsuchende Text (bleibt unver?ndert).}\par
\f0\pard\sb75{\fs24\b find}\par
\f0\pard{\fs20 Die zu suchende und ersetzende Zeichenfolge (buchstabengetreu).}\par
\f0\pard\sb75{\fs24\b replace}\par
\f0\pard{\fs20 Der Ersatzstring, wodurch alle Vorkommen der Zeichenfolge ersetzt werden oder "".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ge?nderte Kopie des Textes.}\par
\f0\pard\sb180\shading1000{\fs30\b Split(text,separator) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zerteilt einen Text an einem/mehreren angegebenen Trennzeichen zu Teilstrings als Array.{\line}Mehrere aufeinanderfolgende Trennzeichen im Text werden als einzelnes behandelt (zB. "  " entspricht " ").}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der aufzuteilende String.}\par
\f0\pard\sb75{\fs24\b separator}\par
\f0\pard{\fs20 Das Trennzeichen als String (zB. " " oder ";") oder mehrere Trennzeichen als Array ("" f?r Gesamttext nach Arrayindex 1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die einzelnen aufgetrennten Textteile als Array (ab 1).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 A. Split an ":{\line} 'qu = Text.GetCharacter(34){\line} Split(text, """") 'oder qu{\line}B. Split zu Zeilen:{\line} Split(text, crlf){\line}C. Array splitten:{\line} arr = "name=wert;..;"{\line} Split(arr, ";"){\line}D. Split an (mehreren) " ":{\line} Split("a  b c", " ")}\par
\f0\pard\sb180\shading1000{\fs30\b Trim(text) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt einen String in dem alle f?hrenden und endenden 'White Space' (Leerzeichen) entfernt sind.}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Die zu beschneidende Zeichenfolge (bleibt unver?ndert).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Eine beschnittene Kopie des Eingabestrings.}\par
\f0\pard\sb300\shading2000{\fs36\b LDTextWindow}\par
\f0\pard{\fs20 Funktionen f?r das TextWindow.{\line}Enth?lt untergeordnete Tastatur Ereignisse. S. LDGraphicsWindow.ExitButtonMode f?r Status des 'Schlie?en' Feldes ('X').}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 client-server\\LDServer(Auto).sb}\par

\f0\pard\sb180\shading1000{\fs30\b Capture(fileName,border) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert den Inhalt des TextWindow als Bilddatei (bmp, gif, jp(e)g, png, tiff oder ico) oder in ImageList (Intern: ImageList#+1).{\line}Das Fenster mu? sichtbar sein. Kurzes Abwarten zB. Program.Delay kann vor Aufruf der Methode n?tig sein.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad f?r die zu speichernde Bilddatei (bmp, gif, jp(e)g, png, tiff oder ico) oder{\line}"" zum Speichern des Bildes in ImageList (Intern: ImageList#+1).}\par
\f0\pard\sb75{\fs24\b border}\par
\f0\pard{\fs20 Fensterrahmen auch Bestandteil des Bildes?  "True" oder "False" (Standard).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ImageList Name (wenn fileName ""), sonst "" (bei Ausgabe in Bilddatei).}\par
\f0\pard\sb180\shading1000{\fs30\b Encoding \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt eine erweiterte Zeichencodierung (Zeichensatz) f?r das TextWindow. G?ltige Werte:{\line}""	Standard:{\line}	Westeurop?isch (Win){\line}"ASCII"	US-ASCII{\line}"Unicode" Unicode UTF-16{\line}"UTF7"	Unicode UTF-7{\line}"UTF8"	Unicode UTF-8}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Westeurop?isch (Windows){\line}TextWindow.WriteLine(LDTextWindow.Encoding){\line}http://msdn.microsoft.com/library/system.text.encoding.aspx}\par
\f0\pard\sb180\shading1000{\fs30\b Hide() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Blendet das TextWindow aus, wobei ein Textinhalt erhalten bleibt (SB 1.0 Fix).{\line}Ersatz f?r die SB Standardmethode, die fehlschlagen kann (Beide Methoden nicht vermischen).}\par
\f0\pard\sb180\shading1000{\fs30\b KeyDown \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf (LowLevel) bei Dr?cken einer Taste.{\line}Ist UNabh?ngig vom Fensterfokus, dh. global und nicht nur innerhalb des TW/GW.{\line}Funktioniert f?r TW und/oder GW ohne da? das Fenster aktiviert ist oder der Mauszeiger im Fenster steht.{\line}F?r weitere Mausereignisse s. LDEvents.}\par
\f0\pard\sb180\shading1000{\fs30\b KeyUp \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf (LowLevel) bei Loslassen einer Taste.{\line}Ist UNabh?ngig vom Fensterfokus, dh. global und nicht nur innerhalb des TW/GW.{\line}Funktioniert f?r TW und/oder GW ohne da? das Fenster aktiviert ist oder der Mauszeiger im Fenster steht.{\line}F?r weitere Mausereignisse s. LDEvents.}\par
\f0\pard\sb180\shading1000{\fs30\b LastKey \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die zuletzt gedr?ckte oder losgelassene Taste (Tastencode, Standard: None).{\line}s. GraphicsWindow.LastKey}\par
\f0\pard\sb180\shading1000{\fs30\b Print(border) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Druckt den Inhalt des TextWindow.{\line}Das Fenster mu? sichtbar sein. Kurzes Abwarten zB. Program.Delay kann kann vor Aufruf dieser Methode n?tig sein.}\par
\f0\pard\sb75{\fs24\b border}\par
\f0\pard{\fs20 Fensterrahmen auch Bestandteil des Bildes?  "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Read(delay) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest eine Eingabe vom TextWindow nach w?hlbarer max. Verz?gerung.{\line}Sendet nach Ablauf der Verz?gerung ein Return (ENTER) an das TextWindow.{\line}Nach Dr?cken der Eingabetaste vor Ablauf der Verz?gerung, wird keine weitere Aktion durchgef?hrt.}\par
\f0\pard\sb75{\fs24\b delay}\par
\f0\pard{\fs20 Die max. Wartezeit [ms] vor Abbruch des Read Befehls.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der vom TextWindow eingelesene Text.}\par
\f0\pard\sb180\shading1000{\fs30\b ReadNumber(delay) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Liest eine Zahleneingabe vom TextWindow nach w?hlbarer max. Verz?gerung.{\line}Sendet nach Ablauf der Verz?gerung ein Return (ENTER) an das TextWindow.{\line}Nach Dr?cken der Eingabetaste vor Ablauf der Verz?gerung, wird keine weitere Aktion durchgef?hrt.}\par
\f0\pard\sb75{\fs24\b delay}\par
\f0\pard{\fs20 Die max. Wartezeit [ms] vor Abbruch des ReadNumber Befehls.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die vom TextWindow eingelesene Zahl.}\par
\f0\pard\sb180\shading1000{\fs30\b SendKey(window,key) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet einen einzelnen Tastendruck an ein GW oder TW Fenster. Ist gleichbedeutend mit einem Tastendruck im Fenster.{\line}Im GW kann damit ein Tastendruck/Zeichen an das fokusierte Steuerelement gesendet werden (zB. Button, TextBox).}\par
\f0\pard\sb75{\fs24\b window}\par
\f0\pard{\fs20 Der Fenstertitel zB. TextWindow.Title oder GraphicsWindow.Title.}\par
\f0\pard\sb75{\fs24\b key}\par
\f0\pard{\fs20 Der einzelne zu sendende Tastencode zB. "Return" (s. R?ckgabestring von GraphicsWindow.LastKey).{\line}Gro?-/Kleinschreibung egal. Buchstabentasten ("A" bis "Z") werden als Kleinbuchstaben gesendet.}\par
\f0\pard\sb180\shading1000{\fs30\b SetColour(index,colour) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ersetzt eine Standardfarbe f?r das TextWindow.{\line}16 verf?gbare Farben mit Standardindex 0 bis 15:{\line}0=Black		8=DarkGray{\line}1=DarkBlue	9=Blue{\line}2=DarkGreen	10=Green{\line}3=DarkCyan	11=Cyan{\line}4=DarkRed	12=Red{\line}5=DarkMagenta	13=Magenta{\line}6=DarkYellow	14=Yellow{\line}7=Gray		15=White.{\line}{\line}Weiterhin k?nnen auch TextWindow.BackgroundColor und -.ForegroundColor f?r neue Farben verwendet werden (mit Originalfarbname).{\line}Alternativ k?nnen diese Farben mit LDTextWindow.SetColours als Indizes gesetzt werden.{\line}Die Farben m?ssen vor ihrer Anwendung mit einer der Methoden gesetzt werden.}\par
\f0\pard\sb75{\fs24\b index}\par
\f0\pard{\fs20 Der Standard Farbindex der zu ersetzenden Farbe (0 bis 15).}\par
\f0\pard\sb75{\fs24\b colour}\par
\f0\pard{\fs20 Eine beliebige Farbe zum Ersetzen der Standardfarbe als #(AA)RRGGBB oder (LDColours.)Farbname.}\par
\f0\pard\sb180\shading1000{\fs30\b SetColours(fgIndex,bgIndex) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den aktuellen Index f?r Vorder- und Hintergrundfarbe im TextWindow.}\par
\f0\pard\sb75{\fs24\b fgIndex}\par
\f0\pard{\fs20 Der Index f?r die Vordergrundfarbe (0 bis 15).}\par
\f0\pard\sb75{\fs24\b bgIndex}\par
\f0\pard{\fs20 Der Index f?r die Hintergrundfarbe (0 bis 15).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDTextWindow.SetColour(0, "Pink") 'Black zu Pink{\line}LDTextWindow.SetColours(0, 9) 'Pink auf Blue}\par
\f0\pard\sb180\shading1000{\fs30\b Show() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Zeigt das TextWindow und setzt es als aktives Fenster mit Fokus, wobei ein Textinhalt erhalten bleibt (SB 1.0 Fix).{\line}Ersatz f?r die SB Standardmethode, die fehlschlagen kann (Beide Methoden nicht vermischen).}\par
\f0\pard\sb300\shading2000{\fs36\b LDTimer}\par
\f0\pard{\fs20 Zus?tzliche Timer (Intern: Timer#).}\par

\f0\pard\sb180\shading1000{\fs30\b Add() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen neuen Timer (Intern: Timer#+1). Alle hiermit erstellten Timer rufen die Ereignis Sub auf, die mittels 'Tick' definiert wurde.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen Timer.}\par
\f0\pard\sb180\shading1000{\fs30\b AddTick(tick) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt einen neuen Timer (Intern: Timer#+1). Dieser Timer l?st nur seine eigene Ereignis Sub aus.}\par
\f0\pard\sb75{\fs24\b tick}\par
\f0\pard{\fs20 Die aufzurufende Ereignis Sub f?r diesen Timer.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen Timer.}\par
\f0\pard\sb180\shading1000{\fs30\b Interval(timer,interval) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Startet oder setzt einen pausierten Timer fort (mit angegebenem Intervall).}\par
\f0\pard\sb75{\fs24\b timer}\par
\f0\pard{\fs20 Der Name des Timer.}\par
\f0\pard\sb75{\fs24\b interval}\par
\f0\pard{\fs20 Setzt das Intervall [ms] f?r den Takt, in dessen Abst?nden der Timer das Tick-Ereignis ausl?st (10 bis 100000000 = 10^8).}\par
\f0\pard\sb180\shading1000{\fs30\b LastTimer \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den letzten Timer (erstellt mit 'Add'), der ein Tick-Ereigis ausgel?st hat.}\par
\f0\pard\sb180\shading1000{\fs30\b Pause(timer) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pausiert einen Timer. Tick-Ereignisse werden nicht mehr ausgel?st.}\par
\f0\pard\sb75{\fs24\b timer}\par
\f0\pard{\fs20 Der Name des Timer.}\par
\f0\pard\sb180\shading1000{\fs30\b Resume(timer) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt einen pausierten Timer wieder fort. Tick-Ereignisse werden wieder ausgel?st.}\par
\f0\pard\sb75{\fs24\b timer}\par
\f0\pard{\fs20 Der Name des Timer.}\par
\f0\pard\sb180\shading1000{\fs30\b Tick \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein Timer (erstellt mit 'Add') abgelaufen ist.}\par
\f0\pard\sb300\shading2000{\fs36\b LDTranslate}\par
\f0\pard{\fs20 Methoden f?r Sprachen und ?bersetzungen (Online mit 'Google Translator', http://translate.google.com).}\par

\f0\pard\sb180\shading1000{\fs30\b Languages() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle Sprachcodes der verf?gbaren Sprachen als Array (gesamt 90).{\line}Die Arrayindizes zeigen den erforderlichen Sprachcode f?r die 'Translate' Methode.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein 1D Array mit den verf?gbaren Sprachk?rzel und -namen (als "Code=Sprache;..").}\par
\f0\pard\sb180\shading1000{\fs30\b Translate(input,languageFrom,languageTo) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?bersetzt einen angegebenen Text von einer Sprache in eine andere (Online).}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 Der zu ?bersetzende Text.}\par
\f0\pard\sb75{\fs24\b languageFrom}\par
\f0\pard{\fs20 Das K?rzel f?r die Ausgangssprache (zB. "en" f?r Englisch).}\par
\f0\pard\sb75{\fs24\b languageTo}\par
\f0\pard{\fs20 Das K?rzel f?r die Zielsprache (zB. "de" f?r Deutsch).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der ?bersetzte Text bei Erfolg, sonst Fehlermeldung oder "".}\par
\f0\pard\sb300\shading2000{\fs36\b LDUnits}\par
\f0\pard{\fs20 Allgemeines, editierbares System zur Einheitenumrechnung.{\line}Alle Einheiten und Dimensionen unterscheiden zwischen Gro?-/Kleinschreibung.{\line}Eine Basiseinheit besteht aus unabh?ngiger Einzeldimension und Name.{\line}Eine abgeleitete Einheit besteht aus Beschreibung, Name und Einheitsdefinition (aus Basis- oder abgeleiteten Einheiten), sowie optionalem Additionsterm (Standard: 0).{\line}Eine Einheit wird geparst durch trennende . / + - und *, dann rekursive Aufl?sung abgeleiteter Einheitenumrechnungen, () Klammerterme zuerst.{\line}Werte (spez. mit Dezimalpunkt '.' oder Minus '-') sollten in () eingeschlossen werden.{\line}Einer Einheit kann eine Vorsilbe/Pr?fix oder Zahlenwert vorangestellt sein (zB. m f?r milli 0.001, k f?r kilo 1000 usw.).{\line}Jeder Einheit kann eine Potenz nachgestellt sein.{\line}Eine typische Einheit w?re "mile/hr", "m/s2", "kg.m/s2", "MJ/day" usw. jede Kombination von Basis-/abgeleiteten Einheiten. Jedes Einheitenpaar mit gleicher Dimension kann konvertiert werden.{\line}Ein Additionswert wird nur f?r nicht-zusammengesetzte Einheitsumrechnung verwendet (zB. C zu F).{\line}Zur Konflikvermeidung durch unklare Einheitsvorsilben, vollen Vorsilbename verwenden (zB. min kann 60 sec oder 0.001 inch bedeuten, letzeres sollte milliin sein).{\line}W?hrungsumrechnungen werden t?glich aktualisiert.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDUnits.sb{\line}http://de.wikipedia.org/wiki/Internationales_Einheitensystem}\par

\f0\pard\sb180\shading1000{\fs30\b AddBaseUnit(dimension,name) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine Basiseinheit zum Einheitensystem hinzu.}\par
\f0\pard\sb75{\fs24\b dimension}\par
\f0\pard{\fs20 Die Dimension der Basiseinheit (zB. TEMPERATUR).}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der Einheitenname/Formelzeichen (Achtung vor Konflikt mit existierenden Einheitennamen).}\par
\f0\pard\sb180\shading1000{\fs30\b AddConstant(description,name,value) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine dimensionslose Konstante zum Einheitensystem hinzu.}\par
\f0\pard\sb75{\fs24\b description}\par
\f0\pard{\fs20 Optionaler Langname oder Beschreibung der Konstanten.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der Konstantenname (Achtung vor Konflikt mit existierenden Konstantennamen).}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der Wert der Konstante.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Mathematische_Konstante{\line}http://de.wikipedia.org/wiki/Physikalische_Konstante{\line}http://en.wikipedia.org/wiki/Astronomical_constant}\par
\f0\pard\sb180\shading1000{\fs30\b AddDerivedUnit(description,name,units,add) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt eine abgeleitete Einheit zum Einheitensystem hinzu.}\par
\f0\pard\sb75{\fs24\b description}\par
\f0\pard{\fs20 Optionaler Langname oder Beschreibung der abgeleiteten Einheit.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der Einheitenname/Formelzeichen (Achtung vor Konflikt mit existierenden Einheitennamen).}\par
\f0\pard\sb75{\fs24\b units}\par
\f0\pard{\fs20 Die Definition der abgeleiteten Einheit.}\par
\f0\pard\sb75{\fs24\b add}\par
\f0\pard{\fs20 Ein optionaler Additionsterm (Standard: 0).}\par
\f0\pard\sb180\shading1000{\fs30\b Convert(value,fromUnit,toUnit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert einen Wert von einer Einheit zu einer anderen.}\par
\f0\pard\sb75{\fs24\b value}\par
\f0\pard{\fs20 Der zu konvertierende Wert.}\par
\f0\pard\sb75{\fs24\b fromUnit}\par
\f0\pard{\fs20 Die zu konvertierende Ausgangseinheit (Formelzeichen).}\par
\f0\pard\sb75{\fs24\b toUnit}\par
\f0\pard{\fs20 Die Zieleinheit nach Konvertierung (Formelzeichen).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der konvertierte Wert bei Erfolg, sonst "FAILED" (zB. nicht-existente Einheit oder unvereinbare Dimensionen).}\par
\f0\pard\sb180\shading1000{\fs30\b Export() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert das aktuelle Einheitensystem in eine UTF8 Textdatei ('units.txt' in Program.Directory).}\par
\f0\pard\sb180\shading1000{\fs30\b GetBaseUnits() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle aktuellen Basiseinheiten als Array "DIM=Basiseinheit;..;".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array verf?gbarer Basiseinheiten, indexiert durch die Dimension der Einheit.{\line}Arraywert ist der Name der Basiseinheit (Formelzeichen).}\par
\f0\pard\sb180\shading1000{\fs30\b GetConstants() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle aktuellen Konstanten als Array "pi=3.14..;e=2.718..;".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array verf?gbarer Konstanten, mit dem Konstantenname (und Beschreibung) als Index und deren Wert als Arraywert.}\par
\f0\pard\sb180\shading1000{\fs30\b GetDerivedUnits() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle aktuellen abgeleiteten Einheiten als Array "Einheit=(Konst)Umrechnung (Beschreibung);..;".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array verf?gbarer abgeleiteter Einheiten mit dem Name der Einheit als Index.{\line}Arraywert ist die Basis-/abgeleitete Einheit (Formelzeichen), die zur Umrechnung verwendet wird (mit Beschreibung).}\par
\f0\pard\sb180\shading1000{\fs30\b GetDimensions(unit) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt f?r eine Einheit alle enthaltenen Dimensionen und deren Potenzen als Array.}\par
\f0\pard\sb75{\fs24\b unit}\par
\f0\pard{\fs20 Die Einheit deren Dimensionen zu ermitteln sind (Gro?-/Kleinschr. beachten).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit der Dimension als Index und deren Potenz als Arraywert oder "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Dimensionen f?r 1 N (Newton = kg*m/sec2):{\line}GetDimensions("N") ' "TIME=-2;LENGTH=1;MASS=1;"}\par
\f0\pard\sb180\shading1000{\fs30\b GetErrors() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt Fehlermeldungen bei 'Convert' Mi?erfolg oder Konflikt mit hinzugef?gten Einheiten oder Konstanten als Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit Fehlermeldungen oder "".}\par
\f0\pard\sb180\shading1000{\fs30\b GetPrefixes() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle aktuellen Pr?fixe (Vorsilben) als Array "..;centi=0.01;milli=0.001;..;".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array verf?gbarer Pr?fixe mit der Vorsilbe als Index und deren Potenzwert als Arraywert.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Vors?tze_f?r_Ma?einheiten}\par
\f0\pard\sb180\shading1000{\fs30\b Import() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?dt ein gespeichertes Einheitensystem von einer Datei ('units.txt' in Program.Directory).}\par
\f0\pard\sb300\shading2000{\fs36\b LDUtilities}\par
\f0\pard{\fs20 Allgemeine Methoden und Funktionen.}\par

\f0\pard\sb180\shading1000{\fs30\b CleanTemp() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht alle SB bezogenen Dateien aus dem %TEMP% Ordner des Benutzers.{\line}Dies betrifft alle dortigen Dateien mit Erweiterungen tmp, pdb und dll.{\line}M?glicherweise verwenden weitere Anwendungen diese ebenfalls. Also bestenfalls nur anwenden, w?hrend diese Anwendungen geschlossen sind.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Anzahl gel?schter Dateien.}\par
\f0\pard\sb180\shading1000{\fs30\b ColourList() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle 141 verf?gbaren SB-Farbnamen als Array (alphabetisch, ab 1=Transparent bzw. #00FFFFFF).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit Namen der 141 verf?gbaren CSS3 Farben (wobei Aqua = Cyan, Fuchsia = Magenta).}\par
\f0\pard\sb180\shading1000{\fs30\b CSVDeliminator \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt das EINZELNE Trennzeichen zum Lesen und Schreiben von CSV Dateien (Standard: "," Komma, s. LDFile).}\par
\f0\pard\sb180\shading1000{\fs30\b CurrentCulture \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt (f?r aktuellen Thread) die aktuelle Sprachkultur (zB. "de-DE", "en-US", "en-GB").{\line}http://msdn.microsoft.com/library/ee825488.aspx (Kulturnamen, Codes, ISO Werte)}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'en-US Datum-/Zeitformat{\line}LDUtilities.CurrentCulture = "en-US"{\line}TextWindow.WriteLine(Clock.WeekDay +", "+ Clock.Date +" "+ Clock.Time){\line}mod = LDFile.ModifiedTime(path){\line}TextWindow.WriteLine(mod)}\par
\f0\pard\sb180\shading1000{\fs30\b DPIX \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die x-Aufl?sung des Anzeigeger?tes [X DPI] (Punkte/Zoll bzw. Pkte/2.54cm, zB. 96, 120).}\par
\f0\pard\sb180\shading1000{\fs30\b DPIY \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die y-Aufl?sung des Anzeigeger?tes [Y DPI] (Punkte/Zoll bzw. Pkte/2.54cm, zB. 96, 120).}\par
\f0\pard\sb180\shading1000{\fs30\b FixFlickr() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Korrigiert das Flickr Objekt (Fehlschlag in SB 1.0). Einmaliger Aufruf im Programm vor Verwendung des Flickr Objekts.}\par
\f0\pard\sb180\shading1000{\fs30\b FontList() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt alle verf?gbaren (installierten) Schriftartnamen als Array.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein Array mit den Namen der verf?gbaren Schriftarten in alphabetischer Reihenfolge.}\par
\f0\pard\sb180\shading1000{\fs30\b ForceInvoke \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt eine experimentelle Option zum Beschleunigen einiger Interaktionen mit SmallBasicLibrary Objekten:{\line}0  keine Erzwingung (Standard){\line}1  erzwingt Invoke (seriell){\line}2  erzwingt BeginInvoke (asynchron)}\par
\f0\pard\sb180\shading1000{\fs30\b GetCultureInvariantNumber(input) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Zahl, ausgedr?ckt in kulturUNabh?ngiger Form.{\line}Eine Zahl mu? kulturUNabh?ngig sein, um f?r Berechnungen als Zahl behandelt zu werden.{\line}Eine aktuell kulturabh?ngige Zahl ist die Form, in der sie ein- oder ausgegeben wird.{\line}zB. "3.14" ist kulturUNabh?ngig, w?hrend "3,14" der deutschen Kultur entspricht.}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 Eine Zahl, ausgedr?ckt entsprechend der aktuellen Kultur.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Zahl, ausgedr?ckt in kulturUNabh?ngiger Form bei Erfolg, sonst die Eingabe.}\par
\f0\pard\sb180\shading1000{\fs30\b GetCurrentCultureNumber(input) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt eine Zahl, ausgedr?ckt entsprechend der aktuellen Kultur.{\line}Eine Zahl mu? kulturUNabh?ngig sein, um f?r Berechnungen als Zahl behandelt zu werden.{\line}Eine aktuell kulturabh?ngige Zahl ist die Form, in der sie ein- oder ausgegeben wird.{\line}zB. "3.14" ist kulturUNabh?ngig, w?hrend "3,14" der deutschen Kultur entspricht.}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 Eine kulturUNabh?ngige Zahl.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Zahl, ausgedr?ckt gem?? der aktuellen Kultur bei Erfolg, sonst die Eingabe.}\par
\f0\pard\sb180\shading1000{\fs30\b GetNextMapIndex(listName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die n?chste Ganzzahl (#) f?r ObjName# eines neu erstellten Objekts im GW, bzw. #-1 gibt die Anzahl bereits erstellter Objekt# dieses Typs (m?ssen nicht mehr alle existieren), zB. Buttons werden durchnummeriert "Button1", "Button2" usw.{\line}Ermittelt den Index der f?r das n?chste hinzugef?gte Objekt verwendet wird (zB. 3 wenn der n?chste "Button3").}\par
\f0\pard\sb75{\fs24\b listName}\par
\f0\pard{\fs20 Der SB-interne Listenname. G?ltige Objekttypen (buchstabengetreu) sind:{\line}"Button"		(Controls){\line}"Control"	(LDControls){\line}"Ellipse"		(Shapes){\line}"Figure"		(LDFigures){\line}"Image"	(Shapes, LDShapes.AddAnim.., LDWebCam){\line}"ImageList"{\line}"Line"		(Shapes){\line}"Polygon"	(LDShapes){\line}"Rectangle"	(Shapes){\line}"Text"		(Shapes){\line}"TextBox"	(Controls){\line}"Triangle"	(Shapes){\line}"View3D"	(LD3DView){\line}"_turtleLine" (Turtle){\line}("ListView" (LDDataBase), "Brush", "Geometry", "Light" NICHT)}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die n?chst folgende Indexnummer bei Hinzuf?gen eines Objekts desselben Typs. 0 bei Fehler ("_turtle" immer 1).}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Anzahl aktuell erstellter Buttons:{\line}nBtns = LDUtilities.GetNextMapIndex("Button") - 1}\par
\f0\pard\sb180\shading1000{\fs30\b IsNumber(input) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Testet ob die Eingabe von SB als eine Zahl behandelt wird. Ber?cksichtigt auch f?hrendes '-' (Minus).  Dezimalpunkt '.' anstatt ',' (Komma).{\line}Dies ist eine kulturUNabh?ngige Zahl, zB. "3.14", jedoch nicht "3,14" oder "24x".}\par
\f0\pard\sb75{\fs24\b input}\par
\f0\pard{\fs20 Die zu ?berpr?fende Eingabe.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b KeyDown(key) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt ob eine Taste gedr?ckt wird.{\line}N?tzlich f?r einfache Tastatur-Steuerung zB. bei einem Spiel.}\par
\f0\pard\sb75{\fs24\b key}\par
\f0\pard{\fs20 Taste deren Status abgefragt wird zB. "Space".}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "True" sobald die Taste gedr?ckt wird, sonst "False".}\par
\f0\pard\sb180\shading1000{\fs30\b NetworkURL \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Webadresse zur Verwendung mit LDNetwork, wenn die Methoden .GameData und .HighScore ?ber einen anderen Server (als LitDev Homepage) verarbeitet werden sollen.}\par
\f0\pard\sb180\shading1000{\fs30\b Priority \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt eine experimentelle Option zum Beschleunigen einiger Dispatcher (Verteiler) Interaktionen mit SmallBasicLibrary Objekten:{\line}1 bis 10 (Standard: 7, gleiche Priorit?t wie Rendering)}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://msdn.microsoft.com/library/system.windows.threading.dispatcherpriority.aspx}\par
\f0\pard\sb180\shading1000{\fs30\b SendClick(x,y,button) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Sendet einen Mausklick an der angegebenen Bildschirmposition. Dies sind Mouse.MouseX/Y (nicht GraphicsWindow.MouseX/Y) Koordinaten.}\par
\f0\pard\sb75{\fs24\b x}\par
\f0\pard{\fs20 Die x-Bildschirmposition zum Klick (-1 aktuelle x-Mausposition).}\par
\f0\pard\sb75{\fs24\b y}\par
\f0\pard{\fs20 Die y-Bildschirmposition zum Klick (-1 aktuelle y-Mausposition).}\par
\f0\pard\sb75{\fs24\b button}\par
\f0\pard{\fs20 Die zu klickende Maustaste ("Left", "Right" oder "Middle").}\par
\f0\pard\sb180\shading1000{\fs30\b ShowErrors \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Fehlerausgabe im TextWindow bei Auftreten eines Fehlers.  "True" (Standard) oder "False".{\line}(zB. bei LDEmail.Send, LDFile.GetExtension("name_ext"), LDGraph, LDUtilities.Version, LDZip.ZipList, usw.)}\par
\f0\pard\sb180\shading1000{\fs30\b ShowFileErrors \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Fehlerausgabe im TextWindow bei Auftreten eines 'Datei nicht gefunden' Fehlers.  "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b ShowNoShapeErrors \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Fehlerausgabe im TextWindow 'detected shapeName not found' (nicht existierende Shape zu einer Methode).  "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b ShowPrintPreview \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Anzeige des Druckvorschau Fensters beim Drucken mit LDGraphicsWindow.Print und LDTextWindow.Print.  "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b UseDispatcher \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt eine experimentelle Option zum Beschleunigen einiger Interaktionen mit SmallBasicLibrary Objekten?  "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b UseExpression \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt eine experimentelle Option zum Beschleunigen einiger Interaktionen mit SmallBasicLibrary Objekten?  "True" (Standard) oder "False".}\par
\f0\pard\sb180\shading1000{\fs30\b Version() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Versionsnummer dieser LitDev-Extension (LitDev.dll) und zeigt ein Fenster mit dieser Information und ChangeLog.{\line}Bei Webzugriff auch Anzeige der aktuellsten Version (ev. kompilierte Exe ausf?hren, Fehleranzeige im TW ist mit LDUtilities.ShowErrors deaktivierbar).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die aktuelle Versionsnummer.}\par
\f0\pard\sb300\shading2000{\fs36\b LDVector}\par
\f0\pard{\fs20 Algebraische 3D Vektormethoden (hilfreich f?r Berechnungen in 'LD3DView').{\line}Alle Vektoren oder Punkte sind 3-elementige Arrays der Form "1=x;2=y;3=z;".{\line}Zur Verwendung als 2D Vektoren als "1=x;2=y;3=0;".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Vektor}\par

\f0\pard\sb180\shading1000{\fs30\b Add(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Summe zweier Vektoren.}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 Der erste Vektor.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 Der zweite Vektor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Summenvektor (Resultierende) bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b AngleBetween(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Winkel zwischen zwei Vektoren.}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 Der erste Vektor.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 Der zweite Vektor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Winkel (0 bis +180?) zwischen den beiden Vektoren bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'v zu Kugelkoord(r,theta,phi){\line}vT = v{\line}vT[3] = 0 'tmp 2D [x,y,0]{\line}vX = "1=1;2=0;3=0;"{\line}vZ = "1=0;2=0;3=1;"{\line}{\line}r = LDVector.Length(v){\line}theta = LDVector.AngleBetween(v,vZ){\line}phi = LDVector.AngleBetween(vT,vX){\line}{\line}'v zu Zylinderkoord(rho,phi,z){\line}rho = LDVector.Length(vT){\line}phi = LDVector.AngleBetween(vT,vX){\line}z = v[3]{\line}{\line}'Atan2(x,y) [0?,+/-180?]{\line}P = "1="+x+";2="+y+";3=0;"{\line}x = "1=1;2=0;3=0;"{\line}w = LDVector.AngleBetween(P,x) ' *sgn(y){\line}w = w * LDLogic.Switch(LDLogic.LT(y,0), -1,1)}\par
\f0\pard\sb180\shading1000{\fs30\b CrossProduct(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das (?u?ere) Kreuz-/Vektorprodukt zweier Vektoren.{\line}Dies ist der Normalvektor zur aufgespannten Vektorenebene, im Rechtssystem.}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 Der erste Vektor.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 Der zweite Vektor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Ergebnisvektor (Nullvektor f?r parallele Vektoren) bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Kreuzprodukt}\par
\f0\pard\sb180\shading1000{\fs30\b DotProduct(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt das (innere) Skalarprodukt zweier Vektoren, |v1|*|v2| * cos(AngleBetween).}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 Der erste Vektor.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 Der zweite Vektor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Das Skalarprodukt bei Erfolg, sonst "".{\line}=0  rechtwinkelig{\line}>0  spitzwinkelig{\line}<0  stumpfwinkelig{\line}(-) |v1|*|v2|  (entgegen) parallel}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://de.wikipedia.org/wiki/Skalarprodukt}\par
\f0\pard\sb180\shading1000{\fs30\b Length(vector) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die L?nge/Betrag (|vector|) f?r einen Vektor.}\par
\f0\pard\sb75{\fs24\b vector}\par
\f0\pard{\fs20 Der Vektor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die Vektorl?nge bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 |v| = Math.SquareRoot(v[1]*v[1] + v[2]*v[2] + v[3]*v[3])}\par
\f0\pard\sb180\shading1000{\fs30\b Multiply(vector,scalar) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Multipliziert einen Vektor komponentenweise mit einem Skalar.{\line}Verl?ngert oder k?rzt die L?nge des Vektors um den angegebenen Faktor. Bei negativem Skalar wird auch die Vektorrichtung umgekehrt.}\par
\f0\pard\sb75{\fs24\b vector}\par
\f0\pard{\fs20 Der Vektor.}\par
\f0\pard\sb75{\fs24\b scalar}\par
\f0\pard{\fs20 Der skalare Faktor zur L?ngen?nderung des Vektors.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der skalierte Vektor bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 'Vektor v zu L?nge l skalieren{\line}v = LDVector.Multiply(v, l/LDVector.Length(v)){\line}v = LDVector.Multiply(LDVector.Normalise(v), l)}\par
\f0\pard\sb180\shading1000{\fs30\b Normalise(vector) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Normalisiert einen Vektor zur Einheitsl?nge (gleiche Richtung).}\par
\f0\pard\sb75{\fs24\b vector}\par
\f0\pard{\fs20 Der Vektor.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der skalierte Einheitsvektor (L?nge = 1) bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Rotate(vector,about,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotiert einen Vektor um eine Drehachse (als Richtungsvektor definiert).}\par
\f0\pard\sb75{\fs24\b vector}\par
\f0\pard{\fs20 Der zu drehende Vektor.}\par
\f0\pard\sb75{\fs24\b about}\par
\f0\pard{\fs20 Der Richtungsvektor der Drehachse um die gedreht wird.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Winkel [?] um den der Vektor gedreht wird.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der rotierte Vektor bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b RotatePoint(point,center,about,angle) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Rotiert einen Punkt um einen angegebenen Zentralpunkt und Richtung.}\par
\f0\pard\sb75{\fs24\b point}\par
\f0\pard{\fs20 Der zu drehende Punkt.}\par
\f0\pard\sb75{\fs24\b center}\par
\f0\pard{\fs20 Der Zentralpunkt um den gedreht wird.}\par
\f0\pard\sb75{\fs24\b about}\par
\f0\pard{\fs20 Der Richtungsvektor der Drehachse um die gedreht wird.}\par
\f0\pard\sb75{\fs24\b angle}\par
\f0\pard{\fs20 Der Winkel [?] um den der Punkt gedreht wird.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der gedrehte Punkt bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Subtract(vector1,vector2) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Differenz zweier Vektoren (Addition mit Gegenvektor von vector2).}\par
\f0\pard\sb75{\fs24\b vector1}\par
\f0\pard{\fs20 Der erste Vektor.}\par
\f0\pard\sb75{\fs24\b vector2}\par
\f0\pard{\fs20 Der zweite Vektor (zur Subtraktion von vector1).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Differenzvektor bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 dif = LDVector.Subtract(v1,v2){\line}dif = LDVector.Add(v1,LDVector.Multiply(v2,-1))}\par
\f0\pard\sb300\shading2000{\fs36\b LDWaveForm}\par
\f0\pard{\fs20 Erstellt PPM (Pulse Position Modulation) Soundsignale zur Steuerung von RC (RemoteControl) Ger?ten.{\line}S. http://blogs.msdn.microsoft.com/smallbasic/2014/05/10/small-basic-pulse-position-modulation-extension{\line}Weiters Erstellung einfacher Sound Wellenformen, welche gleichzeitig asynchron abgespielt werden k?nnen (Intern: WaveForm#).{\line}{\line}SlimDX (Net 4.0) Laufzeit-Dll mu? installiert sein, um dieses Objekt zu verwenden (http://slimdx.org/download.php).}\par

\f0\pard\sb180\shading1000{\fs30\b Amplitude \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die H?he der Signalamplitude f?r PlayDX7.{\line}(Min: -2^15=-32768, Max: 2^15-1=32767, Standard: 20262 bzw. 2^14.3, tats?chlich 1.3 V).}\par
\f0\pard\sb180\shading1000{\fs30\b Async \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Abbruch vor Wiedergabeende (beim asynchronem Abspielen von Sound)?  "True" oder "False" (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b Loop \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt kontinuierliches Abspielen in einer Schleife?  "True" oder "False" (Standard).{\line}Dieses kann durch Aufruf der 'Stop' Methode w?hrend der Wiedergabe beendet werden.}\par
\f0\pard\sb180\shading1000{\fs30\b Pan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die linke (-100) bis rechte (100) Stereo Balance (Standard: 0).}\par
\f0\pard\sb180\shading1000{\fs30\b PlayDX7(channels) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abspielen von DX7 PPM (Pulse Position Modulation) Sound mit 192 kHz (Intern: WaveForm#+1).}\par
\f0\pard\sb75{\fs24\b channels}\par
\f0\pard{\fs20 Ein Array mit Werten (zwischen 0 und 1) f?r jeden Kanal (gew?hnlich 8 Kan?le).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Wellenform bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 http://www.insecure.ws/2010/03/09/control-rc-aircrafts-from-your-computer-for-0/{\line}http://blogs.msdn.microsoft.com/smallbasic/2014/05/10/small-basic-pulse-position-modulation-extension}\par
\f0\pard\sb180\shading1000{\fs30\b PlayHarmonics(frequency,duration,harmonics) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abspielen einer benutzerdefinierten Wellenform als Summe von harmonischen Oberschwingungen/-t?nen (Intern: WaveForm#+1).}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Die Tonfrequenz [Hz].}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Abspieldauer [ms]. Bei negativem Wert wird die Wellenform |duration| mal wiederholt.}\par
\f0\pard\sb75{\fs24\b harmonics}\par
\f0\pard{\fs20 Harmonische Amplituden.{\line}Ein Array, wobei der Index ein ganzzahliges Harmonische Vielfaches der Basisfrequenz (2,3, usw.) und der Wert die relative Amplitude der Harmonischen angibt.{\line}s. http://www.sengpielaudio.com/Rechner-harmonische.htm}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Wellenform bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Formen einer Rechteckschwingung (http://de.wikipedia.org/wiki/Rechteckschwingung):{\line}For i = 3 To 21 Step 2{\line}  harmonics[i] = 1/i{\line}EndFor{\line}rectWave = LDWaveForm.PlayHarmonics(256,1000, harmonics)}\par
\f0\pard\sb180\shading1000{\fs30\b PlaySineWave(frequency,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abspielen einer Sinus Wellenform (Intern: WaveForm#+1).}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Die Tonfrequenz [Hz].}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Abspieldauer [ms]. Bei negativem Wert wird die Wellenform |duration| mal wiederholt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Wellenform bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b PlaySquareWave(frequency,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abspielen einer Rechteck Wellenform (Intern: WaveForm#+1).}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Die Tonfrequenz [Hz].}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Abspieldauer [ms]. Bei negativem Wert wird die Wellenform |duration| mal wiederholt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Wellenform bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b PlayWave(frequency,duration,waveform) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abspielen einer benutzerdefinierten Wellenform (Intern: WaveForm#+1).}\par
\f0\pard\sb75{\fs24\b frequency}\par
\f0\pard{\fs20 Die Tonfrequenz [Hz].}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Abspieldauer [ms]. Bei negativem Wert wird die Wellenform |duration| mal wiederholt.}\par
\f0\pard\sb75{\fs24\b waveform}\par
\f0\pard{\fs20 Die Form der wiederholenden Welle.{\line}Ein Array, wobei der Index die zunehmende relative Zeit (aktueller Wert wird bez?glich Frequenz normalisiert) und der Wert die zugeh?rige Amplitude (-1 bis 1) darstellt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Wellenform bei Erfolg, sonst "".}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 Dreieckwelle/S?gezahn: "0=-1;1=1;2=-1;"}\par
\f0\pard\sb180\shading1000{\fs30\b PlayWavFile(fileName,duration) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Abspielen einer wav Datei (Intern: WaveForm#+1).}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der wav Datei.}\par
\f0\pard\sb75{\fs24\b duration}\par
\f0\pard{\fs20 Die Abspieldauer [ms]. Bei negativem Wert wird die Wellenform |duration| mal wiederholt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der Wellenform bei Erfolg, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b Stop(waveName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Stoppt eine laufende Soundwiedergabe.}\par
\f0\pard\sb75{\fs24\b waveName}\par
\f0\pard{\fs20 Der Name der Sound Wellenform.}\par
\f0\pard\sb180\shading1000{\fs30\b Volume \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Lautst?rke beim Abspielen einer WaveForm (0 bis 100, Standard).}\par
\f0\pard\sb300\shading2000{\fs36\b LDWebCam}\par
\f0\pard{\fs20 Erm?glicht Zugriff auf eine angeschlossene WebCam.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 webcam\\webcam.sb, motion-detection.sb{\line}http://blogs.msdn.microsoft.com/smallbasic/2014/10/25/small-basic-webcam-motion-detection}\par

\f0\pard\sb180\shading1000{\fs30\b Effect \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den aktuellen Effekt (s. LDImage.Effect..).{\line}Setzen durch Bestimmung einer Effect.. Eigenschaft (0 bis 20), zB.{\line}LDWebCam.Effect = LDWebCam.EffectGray bzw. 4}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBlocks \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Kl?tzcheneffekt ein (12, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBlue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Blau (3, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectBulge \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen W?lbungseffekt ein (19, ?hnlich FishEye/Fischauge, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectContrast \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt h?heren Kontrast ein (11, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectCyan \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Cyan (7, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectFishEye \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Fischauge Effekt ein (18, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectFuzzy \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Unsch?rfe-Effekt ein (10, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGamma \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Gamma Effekt ein (17, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGray \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Schwarz/Wei? (4, Grayscale gewichtet, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectGreen \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Gr?n (2, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectHue \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung des Farbtons (22, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectInverse \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Invers (5, Negativ 255-[R,G,B], "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectJagged \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Zackeneffekt ein (14, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectLightness \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung der Helligkeit (24, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectMagenta \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Magenta (8, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectNone \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ohne Effekt (0, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectOilPaint \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen ?lfarbe Effekt ein (25, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectParameter \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt den Effekt Parameter, s. LDImage.Effect.. f?r Parameterwerte zu den Effekten.}\par
\f0\pard\sb180\shading1000{\fs30\b EffectPixelate \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Verpixelungseffekt ein (16, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectPosterise \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Postereffekt ein (21, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectRed \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Rot (1, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectReflect \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Horizontale Reflexion, Spiegelung an der y-Bildachse (13, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectRotate \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Rotationseffekt ein (15, Standard: +90 Grad, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSaturation \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung der S?ttigung (23, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSnow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Schneeeffekt ein (9, 4% wei?e Pixel, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectSwirl \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen Wirbeleffekt ein (20, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b EffectYellow \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertierung zu Gelb (6, "GET").}\par
\f0\pard\sb180\shading1000{\fs30\b End() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Beendet die Darstellung im WebCam-Fenster. Mu? aufgerufen werden bevor die Shape entfernt wird.}\par
\f0\pard\sb180\shading1000{\fs30\b Interval \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die Mindestverz?gerung der WebCam zwischen den Updates [ms] (Standard: 20).{\line}In der Realit?t werden diese Zeiten aber selten erreicht, insbesondere wenn Spezialeffekte verwendet werden.}\par
\f0\pard\sb180\shading1000{\fs30\b Pause() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Pausiert das Updaten der WebCam.}\par
\f0\pard\sb180\shading1000{\fs30\b PreWin8Mode \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt Verwendung der (?lteren) Vor-Windows 8 Methode.  "True" (zB. XP, Vista, W7) oder "False" (Standard).}\par
\f0\pard\sb180\shading1000{\fs30\b Resume() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt zuvor pausiertes Updaten der WebCam fort.}\par
\f0\pard\sb180\shading1000{\fs30\b Snapshot() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein Bild vom WebCam-Fenster und speichert es mittels 'Speichern als' Dialog als jpg-Datei.}\par
\f0\pard\sb180\shading1000{\fs30\b SnapshotToFile(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein Bild vom WebCam-Fenster und speichert es unter angegebenem Dateipfad.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Voller Dateipfad zum Speichern des Bildes als jpg-Datei.}\par
\f0\pard\sb180\shading1000{\fs30\b SnapshotToImageList() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein Bild vom WebCam-Fenster in ImageList.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen ImageList Bildes.}\par
\f0\pard\sb180\shading1000{\fs30\b Start(width,height) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt eine WebCam Anzeige ('Schirm') als Shape (Intern: Image#).{\line}Bei mehrfachem Aufruf werden mehrere Kopien desselben WebCam Bildes erstellt.{\line}Dieses Objekt l??t sich mit Standard 'Shapes...' Methoden bewegen, zoomen, rotieren usw.{\line}Maximale Aufl?sung ist gew?hnlich 640x480 Pxl, wobei kleiner = schneller.}\par
\f0\pard\sb75{\fs24\b width}\par
\f0\pard{\fs20 Die Breite der WebCam Shape.}\par
\f0\pard\sb75{\fs24\b height}\par
\f0\pard{\fs20 Die H?he der WebCam Shape.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name der WebCam Shape.}\par
\f0\pard\sb300\shading2000{\fs36\b LDWindows}\par
\f0\pard{\fs20 Erstellt zus?tzliche GraphicsWindows (Intern: #).{\line}{\line}Alle Variablen werden von den Fenstern gemeinsam verwendet (global scope).{\line}GraphicsWindow Ereignisse m?ssen f?r jedes Fenster einzeln behandelt werden, jedoch kann die Ereignis-Sub von allen Fenstern gemeinsam verwendet werden.{\line}Alle anderen Ereignisse k?nnen einzeln behandelt werden, wie sonst auch.{\line}Alle Befehle oder Methoden gehen an das gerade aktuelle Fenster (festgelegt durch CurrentID).{\line}Das originale GraphicsWindow hat die ID 0.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDWindows.sb}\par

\f0\pard\sb180\shading1000{\fs30\b Activated \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ereignisaufruf wenn ein Fenster aktiviert wird.{\line}Dieses Ereignis sollte mit Vorsicht verwendet werden. F?r die meisten F?lle nicht empfohlen.}\par
\f0\pard\sb180\shading1000{\fs30\b Active \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die ID (#) des derzeit aktiven (im Vordergrund befindlichen) Fensters (Orig. GW hat ID 0).{\line}-1 bedeuted 'kein aktives Fenster'. Kann durch aktivierte 'X-Maus' beeinflusst werden.}\par
\f0\pard\sb180\shading1000{\fs30\b Create() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein neues GraphicsWindow (Intern: #+1) und setzt dieses als aktuelles Fenster (s. 'CurrentID').}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die ID (#) des erstellten Fensters (Orig. GW hat die ID 0).}\par
\f0\pard\sb180\shading1000{\fs30\b CurrentID \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt oder setzt die ID (#) des gerade aktuellen Fensters (Orig. GW hat ID 0). Jedes neue Fenster erh?lt neue ID #+1 zugewiesen.}\par
\f0\pard\sb180\shading1000{\fs30\b LastActivated \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die ID (#) des zuletzt aktiv gewesenen Fensters.}\par
\f0\pard\sb300\shading2000{\fs36\b LDxml}\par
\f0\pard{\fs20 Methoden zur Erstellung, Bearbeitung sowie Parser Methoden f?r Auswertung und Vergleich von Xml Dateien.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 other-samples\\LDxml.sb}\par

\f0\pard\sb180\shading1000{\fs30\b AddNode(name,attributes,text,location) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 F?gt einen neuen Knoten ein.{\line}Der aktuelle Knoten bleibt unver?ndert und wird nicht als neuer Knoten aktualisiert.}\par
\f0\pard\sb75{\fs24\b name}\par
\f0\pard{\fs20 Der Elementname f?r den neuen Knoten.}\par
\f0\pard\sb75{\fs24\b attributes}\par
\f0\pard{\fs20 Ein Array mit Attributen (Werte indexiert durch Attributname) f?r den neuen Knoten oder "".}\par
\f0\pard\sb75{\fs24\b text}\par
\f0\pard{\fs20 Der innere Text f?r den neuen Knoten oder "".}\par
\f0\pard\sb75{\fs24\b location}\par
\f0\pard{\fs20 Einf?geposition f?r den neuen Knoten:{\line}"Append"   am Ende aller Unterknoten im aktuellen Knoten{\line}"Prepend"  am Beginn der Unterknoten im aktuellen Knoten{\line}"Before"   vor dem aktuellen Knoten{\line}"After"    nach dem aktuellen Knoten}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Attributes \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Attribute f?r den aktuellen Knoten als Array mit den Attribut-Textwerten (indexiert durch die Attributnamen, zB. "name=T:LitDev.LDxml;..."), sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b AttributesCount \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der Attribute f?r den aktuellen Knoten.}\par
\f0\pard\sb180\shading1000{\fs30\b ChildrenCount \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt die Anzahl der Unterknoten innerhalb des aktuellen Knoten.}\par
\f0\pard\sb180\shading1000{\fs30\b FirstChild() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt den aktuellen Knoten an den ersten Unterknoten, falls vorhanden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b FirstNode() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Setzt den aktuellen Knoten als ersten Knoten im Xml Dokument.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b FromArray(array) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Erstellt ein neues Xml Dokument von einer Array Definition, als Umkehrung der 'ToArray' Methode (Intern: XMLDoc#+1).}\par
\f0\pard\sb75{\fs24\b array}\par
\f0\pard{\fs20 Ein SB Array im korrekten Format (Arrayformat wie s. 'ToArray').}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des neuen Xml Dokuments bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b LastChild() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt den aktuellen Knoten an den letzten Unterknoten, falls vorhanden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b NextSibling() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt den aktuellen Knoten an den n?chst folgenden Nachbarknoten, falls vorhanden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b NodeInnerText \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den gesamten inneren Text im aktuellen Knoten und allen Unterknoten, sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b NodeName \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Elementname des aktuellen Knoten (zB. code, doc, example, member, note, param, remarks, returns, summary, usw.), sonst "".}\par
\f0\pard\sb180\shading1000{\fs30\b NodeType \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt den Typ des aktuellen Knoten (Einer vieler Typen, meist jedoch "Element" oder "Text").}\par
\f0\pard\sb180\shading1000{\fs30\b Open(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 ?ffnet eine bestehende Xml Datei (Intern: XMLDoc#).{\line}Ist vor allen weiteren 'LDxml' Methoden aufzurufen.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu ?ffnenden Xml Datei. Bei "" wird ein neues Xml Leerdokument erstellt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der Name des Xml Dokuments (Intern: XMLDoc#+1) bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Parent() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt den aktuellen Knoten an den Elternknoten, falls vorhanden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b PreviousSibling() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Verschiebt den aktuellen Knoten an den vorhergehenden Nachbarknoten, falls vorhanden.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b RemoveNode() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Entfernt den aktuellen Knoten incl. Unterknoten.{\line}Der aktuelle Knoten wird zur?ckgesetzt auf den vorhergehenden Nachbarknoten bzw. Elternknoten, wenn kein vorhergehender Nachbarknoten existiert.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Der neue aktuelle Knoten ("SIBLING" bzw. "PARENT") bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Save(fileName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Speichert das aktuelle Xml Dokument in eine Datei.}\par
\f0\pard\sb75{\fs24\b fileName}\par
\f0\pard{\fs20 Der volle Pfad der zu speichernden Xml Datei.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b Switch(docName) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Umschalten zu einem anderen geladenen Xml Dokument. Der aktuelle Knoten wird f?r jedes Dokument beibehalten.}\par
\f0\pard\sb75{\fs24\b docName}\par
\f0\pard{\fs20 Der Name des Xml Dokuments (R?ckgabewert von 'Open', Intern: XMLDoc#).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "SUCCESS" bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb180\shading1000{\fs30\b ToArray() \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Konvertiert das aktuelle Xml Dokument zu einem SB Array.{\line}Die Struktur und Tiefe des Arrays k?nnen dabei ziemlich komplex werden.{\line}Jeder Knoten besitzt optionale Arrays "Attributes" und "Children" oder "Data".{\line}Sind Unterknoten vorhanden, so werden diese erst nach Nummer indexiert (zur Unterscheidug mehrerer gleichnamiger Unterknoten).}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Ein (mehrdimensionaler) SB Array bei Erfolg, sonst "FAILED".}\par
\f0\pard\sb300\shading2000{\fs36\b LDZip}\par
\f0\pard{\fs20 Erweiterungen f?r zip(x) Archive (bzw. Dateitypen mit PK Header wie apk, jar, nupkg, wmz, xpi, xps, usw. oder Containertypen wie docx, xlsx, usw.).{\line}Fehlermeldung bei Archivdefekt, falschem Dateityp/Pfadangabe oder 0-Byte Datei (deaktivierbar mit LDUtilities.ShowErrors).}\par

\f0\pard\sb180\shading1000{\fs30\b Remove(zipFile,files) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 L?scht eine Datei (oder gesamten Ordner mit Inhalt) aus einem bestehenden zip Archiv (apk, jar, nupkg, wmz, xpi, xps, usw. mit PK Header).{\line}Keine Verarbeitung untergeordneter (nested) Archive.}\par
\f0\pard\sb75{\fs24\b zipFile}\par
\f0\pard{\fs20 Der volle Pfad f?r das zu ?ndernde zip Archiv.}\par
\f0\pard\sb75{\fs24\b files}\par
\f0\pard{\fs20 Die aus dem Archiv zu l?schenden Datei-/Ordnernamen als Array.{\line}Zum L?schen einer Einzeldatei oder -ordner auch als String (Gro?-/Kleinschreibung egal).{\line}Angegebene Ordner werden rekursiv aus dem zip Archiv entfernt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst Fehlermeldung.}\par
\f0\pard\sb75{\fs24\b example}\par
\f0\pard{\fs20 LDZip.Remove(arch, "textDatei.TXT"){\line}LDZip.Remove(arch, "1=dATeI.ext;2=Sub Dir\\file.txt;")}\par
\f0\pard\sb180\shading1000{\fs30\b UnZip(zipFile,directory) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Dekomprimiert und entpackt ein gesamtes zip Archiv rekursiv in den angegebenen Ordner (apk, jar, nupkg, wmz, xpi, xps, usw. mit PK Header).{\line}Keine Verarbeitung untergeordneter (nested) Archive.}\par
\f0\pard\sb75{\fs24\b zipFile}\par
\f0\pard{\fs20 Der volle Pfad f?r das zu entpackende zip Archiv.}\par
\f0\pard\sb75{\fs24\b directory}\par
\f0\pard{\fs20 Der volle Ordnerpfad in den der Archivinhalt entpackt wird (bestehende Dateien werden still ?berschrieben). Zielordner wird automatisch erstellt, falls nicht existent.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst Fehlermeldung.}\par
\f0\pard\sb180\shading1000{\fs30\b Zip(zipFile,files) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Komprimiert Dateien in ein neues oder bestehendes zip Archiv (apk, jar, nupkg, wmz, xpi, xps, usw. mit PK Header).}\par
\f0\pard\sb75{\fs24\b zipFile}\par
\f0\pard{\fs20 Der volle Pfad f?r das zu erstellende (oder bestehende) zip Archiv.}\par
\f0\pard\sb75{\fs24\b files}\par
\f0\pard{\fs20 Ein Array von Dateien die in das zip Archiv hinzugef?gt werden.{\line}Auch eine Einzeldatei oder -ordner kann angegeben werden.{\line}Jeder Ordner wird rekursiv in das zip Archiv gepackt. Fehlermeldung, wenn beim Hinzuf?gen einer Datei diese bereits im Archivpfad besteht.{\line}Alle Leerzeichen in Datei- oder Ordnernamen werden durch "_" ersetzt.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 "" bei Erfolg, sonst Fehlermeldung.}\par
\f0\pard\sb180\shading1000{\fs30\b ZipList(zipFile) \fs18\b0\i OPERATION}\par
\f0\pard{\fs20 Ermittelt rekursiv alle Datei-/Ordnerpfade in einem bestehenden zip Archiv (apk, jar, nupkg, wmz, xpi, xps, usw. mit PK Header).{\line}Keine Verarbeitung untergeordneter (nested) Archive.}\par
\f0\pard\sb75{\fs24\b zipFile}\par
\f0\pard{\fs20 Der volle Pfad f?r das zu durchsuchende zip Archiv.}\par
\f0\pard\sb75{\fs24\b returns}\par
\f0\pard{\fs20 Die enthaltenen Ordner-/Dateipfade als Array ("1=Ordner/Dateiname.ext;2=..;") bei Erfolg, sonst Fehlermeldung (zB. "LDZip.ZipList Cannot read that as a ZipFile").}\par
}
